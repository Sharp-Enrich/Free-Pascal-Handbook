我们在第二章介绍数据型别的时候，曾经提到过 Object Pascal 同时存在数据型别与型别建构子。型别建构子的简单例子是列举型别，会在本章介绍。

型别定义的力量，来自更多高深的机制，像是数组、记录与类别。在本章的篇幅中，我们先介绍前两个，他们的本质可以追溯到 Pascal 语言被定义出来的初期，但经过了这么多年以后，也已经有所改变(变得更强了)。现在的版本几乎已经跟原来的定义完全不同了，只剩名字还被留着。

到本章的结尾，我也会稍微提到一些 Object Pascal 进阶的数据型别，像是指标。然而自定数据型别的强大，我们要到第七章才能体会，在第七章里面，我们会开始深入类别与面向对象程序设计。


## 数组数据型别

数组型别定义了以清单列出特定型别的表示法。这些列表当中可以存放固定数量的元素(静态数组)，也可以存放变动的元素数量(动态数组)。我们通常以方括号括住一个索引值来存取数组中的特定元素。方括号也用来代表固定数量元素数组的数量。

Object Pascal 语言支持不同的数组型别，从传统的静态数组到动态数组。我们推荐使用动态数组，尤其是在使用行动版的编译器时。我们先介绍静态数组，然后稍后再来看动态数组吧。


### 静态数组 (Static	Arrays)

传统的 Pascal 语言数组都是静态的，也就是其元素的数量在宣告的时候就确定了，底下的程序片段就是个范例，在这个范例中，定义了一个 24 个整数的清单，用来表示一天 24 小时的温度：

```pascal
type
 TDayTemperatures = array [1..24] of Integer;
```

在这个传统的数组定义里，我们可以透过方括号来使用次范围型别，实际用两个有序型别的常数值来定义一个新的次范围型别。这个次范围指数组中有效的索引值。既然我们定义了该数组索引的最大值与最小值，那么这个索引就不必非得从 0 开始了，就像在 C, C++, Java 以及他大多数的语言一样(从 0 开始作为起始点的数组也已经在 Object Pascal 里面普及了)。注意，在 Object Pascal 里面，索引值可是数字，或者其他有序型别的值，像是字符、列举型别等等。非整数型的索引目前还是很少见。

!!! note "笔记"
    仍有许多编程语言，像 JavaScript，特别倚重关系型数组(associative arrays)。Object Pascal 的数组限制索引必须是有序型别，所以我们不能用字符串当成索引值。在 RTL 里面有提供了 Dictionary 跟其他类似的数据结构可以用，我会在本书的第三部分，介绍 Generic 的篇幅里面介绍他们。

既然数组索引值是以次范围为型别，编译器就可以检查他们的范围了。使用不合法的常数次范围值会导致编译错误，而超过范围的索引值则会导致运行时错误，不过，这也得要设定了对应的编译选项才会发生。

!!! note "笔记"
    次范围检查的选项在设定页的 Compiling 页签里的 Runtime errors 群组里面。我们可以从 IDE 的 Project Options 对话框找到(在项目名称上面点选鼠标右键，就会出现 Project Options 选项了)。在第二章的『次范围型别』那一小节我们已经提过啰。

使用以上的数组定义，我们可以设定一个名为 DayTemp1 的变量，型别就用TDayTemperatures(我已经写好在范例项目 ArrayTests 里面，以下就是该项目的源码节录):

```pascal
type
 TDayTemperatures = array [1..24] of Integer;
var
 DayTemp1: TDayTemperatures;
begin
 DayTemp1 [1] := 54;
 DayTemp1 [2] := 52;
 ...
 DayTemp1 [24] := 66;
 // The following line causes:
 // E1012 Constant expression violates subrange bounds
 // DayTemp1 [25] := 67;
```

这么一来，我们当然可以用标准的方法来处理数组了，也就是 for 循环。这个范例是使用循环来显示一天当中的所有温度数字：

```pascal
var
 I: Integer;
begin
 for I := 1 to 24 do
 Show (I.ToString + ': ' + DayTemp1[I].ToString);
```

当然，这段源码执行不会有问题，但因为它的数组范围是写死的(从1到24)，这种写法还不尽理想。因为数组的定义会随时间改变，所以我们可能会想要使用动态数组。


### 数组的大小跟边界

当我们在处理数组的时候，记得！永远都要用标准函式 Low 跟 High 检查它的边界，这两个函式会回传上下两个边界值。(译者也这么认为，因为这几年越来越常碰到初学者，甚至已经写了几年的程序人员，完全不管数组边界值，直接就抓数据，然后就发生数组超出边界的错误，在手机就会闪退，在桌面应用程序就会发生不断出现错误) 请永远在存取数组内容之前，先检查该索引值是不是在数组的合法范围之内！尤其是在循环里面处理数组数据时，更需要逐一检查，因为循环可能从 0 到数组数量-1，或者从 1 到数组数量，或者任何次范围的定义，在执行过程中，什么时候会出问题很难预料，所以务必一一检查。

即使我们在程序写好之后，还需要更改数组索引的范围，Low 跟 High 这两个函式仍旧是有效的，但如果我们把范围写死，我们就得在每次数组范围有异动的时候，修改数组使用的源码了。Low 跟 High 这两个函式会让我们不用花太多时间在维护数组的源码，并使源码可靠性更高。

!!! note "笔记"
    顺便一提，对静态数组使用 Low 跟 High 函式，在运行时间完全没有多花时间。因为它们是在编译阶段就已经完成了解析，所以不用任何额外的函式来处理。类似的编译阶段解决的作法，在其他系统函式里面也常出现喔。

另一个相关的函式是 Length，这个函式会回传数组的元素数量，我把上述三个函式整合在下面的范例源码里面，用来显示当天的平均温度：

```pascal
var
 I: Integer;
 Total: Integer;
begin
 Total := 0;
 for I := Low(DayTemp1) to High(DayTemp1) do
 Inc (Total, DayTemp1[I]);
 Show ((Total / Length(DayTemp1)).ToString);
```

上面的源码也是 ArraysTest 范例项目的一部分。

### 多维度静态数组

数组可以包含超过一个以上的维度，以矩阵或者方块的形式来呈现，不一定是一维的线性列表。以下是两个简单的定义：

```pascal
type
 TAllMonthTemps = array [1..24, 1..31] of Integer;
 TAllYearTemps = array [1..24, 1..31, 1..12] of Integer;
```

我们可以这样来存取里面的元素：

```pascal
var
 AllMonth1: TAllMonthTemps;
 AllYear1: TAllYearTemps;
begin
 AllMonth1 [13, 30] := 55; // hour, day
 AllYear1 [13, 30, 8] := 55; // hour, day, month
```

!!! note "笔记"
静态数组会立即使用许多内存空间(例如使用掉堆栈里的内存)，这些浪费是可以被避免的。AllYear1 变量需要使用 8,928 个整数，以每个整数 4 bytes来计算，就将近 35KB 了。不管在全局内存空间或者堆栈里面(如上例的程序，就会耗用堆栈的内存)，预先配置这么大的空间都是不对的。相反地，动态数组使用的是 heap 的记忆空间，而且在内存的配置跟管理上弹性也都更大。

假设这两个数组型别是以相同的核心型别建置，我们最好使用前例的资料型别，可以写成：

```pascal
type
 TMonthTemps = array [1..31] of TDayTemperatures;
 TYearTemps = array [1..12] of TMonthTemps;
```

这样的宣告颠倒了前例的顺序，但也允许两个变量之间整个区块的指派动作。我们看一下可以怎么指派独立的数值：

```pascal
Month1 [30][14] := 44;
Month1 [30, 13] := 55; // day, hour
Year1 [8, 30, 13] := 55; // month, day, hour
```

使用中介型别的重要性，只基于数组中元素相同时，元素型别可以兼容的特性而来(这当中的型别是完全相同的)。而当元素型别不同的时候，这个特性就不存在了。这个型别兼容的规则，对于 Object Pascal 的所有型别都成立，只有少数情况例外。

举例来说，以下的源码会复制一个月的温度到该年的第三个月份：

`Year1[3] := Month1;`

反之，一个类似的指令如果是套用到独立的数组时(这数组跟温度的数组型别并不相同):

`AllYear1[3] := AllMonth1;`

就会引发错误：

`Error: Incompatible types: 'array[1..31] of array[1..12] of Integer' and 'TAllMonthTemps'`

像我提过的，静态数组在内存管理的问题上做出了牺牲，特别是当我们想要把它作为参数进行传递，或者只配置一个大数组的一部分时。再者，我们无法在执行过程中，对仍处在合法生命周期的数组变量进行重新配置。这也是为什么使用动态数组占有比较多优势的原因，即使动态数组需要使用一些额外的管理机制，例如对内存的管理。


### 动态数组.143

在传统的 Pascal 语言里，数组是固定大小的，当我们宣告了数组的元素数量以后，这个数组可以储存的元素数量就被固定了。Object Pascal 也提供了一个原生、直接的动态数组功能。

!!! note "笔记"
『直接的动态数组功能』指的是相对于使用指针与易失存储器配置等技术来得到类似的效果，那样做程序会很复杂，而且容易出错。顺带一提，动态数组也是大多数现代编程语言唯一的构筑风格。

动态数组是动态配置，并且对参考进行计数(这个作法会使得传递参数的时候快上许多，且只有参考会被传递，而不是把完整的数组复制一份传过去)。当我们完成处理时，我们可以透过把数组变量指向 nil 或者把数组的长度设定为 0 这两种作法来把数组内容清除掉，而动态数组因为是使用参考计数在管理内存的，编译器就会帮我们把内存自动清除掉了。要记得数组的每个元素是有使用内存的：如果数组中掌控了其他内存空间的地址(例如对象的参考地址)，我们就得在释放数组之前，确保数组中每个元素指向的内存空间确实有被释放掉。

透过动态数组，我们宣告数组型别时，就不用指定元素数量了，等到我们需要使用的时候，再透过 SetLength 程序设定数组的长度即可：

```pascal
var
 Array1: array of Integer;
begin
 // this would cause a runtime Range Check error
 // Array1 [1] := 100;
 SetLength (Array1, 10);
 Array1 [1] := 100; // this is OK
```

在还没有设定数组的长度之前，我们不能直接使用数组，透过 SetLength 程序，我们会在 heap 的内存里面配置数组需要的空间。如果我们没有这么做，要不会出现范围检查错误(如果对应的编译器设定没有设定为启动的话)，或者就会在 Windows 上面出现存取违规或者在其他作业平台上出现类似的内存存取错误。在上述源码里面，SetLength 函式会设定所有值先设为 0。初始源码会让这个数组立刻可以开始被读写，不用担心任何内存错误(当然，如果我们硬是存取数组范围之外的值，还是会错的)。

如果我们想要自己配置内存，我们也不用直接释放它，在上面的源码里面，当 Array1 变量的生命周期结束，而程序也结束时，编译器就会自己释放掉当中使用的内存了(以上面的源码为例，原本配置的 10 个整数的内存空间会被释放掉)。所以我们可以直接把 nil 指派给动态数组变量，或者呼叫SetLength(0)，这通常都是不需要的(编译器会自己处理)。

请注意，SetLength 程序可以用来调整数组大小，如果我们把数组的长度加大，原有的元素并不会受到影响，而如果我们把数组的长度缩短，则被裁减到的元素也会被释放，但没有被裁减的元素则不会受影响。

在最初呼叫 SetLength 程序的时候，我们只指定了数组元素的数量，数组的起始索引仍旧是 0，最后一个索引则是指定的数量减一。换句话说，动态数组并不支持传统 Pascal 静态数组的两个功能：指定从非 0 的元素作为初始索引，以及以非整数作为索引值。同时，Object Pascal 动态数组的动作与行为也更像 C 语言或其他从 C 衍生而来的编程语言了。

要查询动态数组目前的长度，我们可以用跟静态数组相同的作法：透过Length，也可以使用 High 跟 Low 函式。只是在动态数组使用 Low 函式，永远都会得到 0，使用 High 函式，则永远都会得到数组长度减一。也就是说，对一个长度为 0 的动态数组执行 High 函式，会得到-1(想一想，这是个奇怪的数值，对吧，因为 High 比 Low 传回的值还小！！)


所以，当成个例子吧，在 DynArray 范例项目里面，我透过可变循环来把信息放进，也从动态数组取出，这是型别跟变量定义：

```pascal
type
 TIntegersArray = array of Integer;
var
 IntArray1: TIntegersArray;
```

数组被以索引值的数据进行配置与存放，使用以下的循环：

```pascal
var
 I: Integer;
begin
 SetLength (IntArray1, 20);
 for I := Low (IntArray1) to High (IntArray1) do
 IntArray1 [I] := I;
end;
```

第二个按钮的程序则包办了显示每个数值与计算平均值的功能，类似前一个范例，不同的是只使用单一循环：

```pascal
var
 I: Integer;
 total: Integer;
begin
 Total := 0;
 for I := Low(IntArray1) to High(IntArray1) do begin
 Inc (Total, IntArray1[I]);
 Show (I.ToString + ': ' + IntArray1[I].ToString);
 end;
  Show ('Average: ' + (Total / Length(IntArray1)).ToString);
end;
```

这段程序的输出则相当的浅显易懂(我省去了大部分):

```
0: 0
1: 1
2: 2
3: 3
...
17: 17
18: 18
19: 19
Average: 9.5
```

除了 Length, SetLength, Low, High 之外，我们还有一些常用的程序会跟数组搭配使用的，例如 Copy 函式，我们可以用它来复制数组的部份元素(也可以复制全部)。注意到，我们也可以把数组变量指派给另一个变量，但这么做并不是把所有元素都复制了一份过去喔，这么做只会把数组的指针复制过去，两个数组变量所使用的内存空间会是同一份，所以当我们修改其中一个数组的元素时，另一个也会一起变动。

唯一略为复杂的源码是 DynArray 程序的最后部分，用两种方法来把一个数组复制到另一个去：

+ 使用 Copy 函式，可以把数组的数据复制到使用不同的内存空间的一个新的数组去。
+ 使用指派运算符(:=)，这作法只会做出另一个变量的替身，储存的还是同一份内存空间。


在这时候，如果我们修改了其中一个数组的元素时，原来那数组的元素会不会跟着一起发生异动，就要看你用哪一种方法来做这个复制的动作了，以下是完整的源码：

```pascal
var
 IntArray2: TIntegersArray;
 IntArray3: TIntegersArray;
begin
 // Alias
 IntArray2 := IntArray1;

 // Separate copy
 IntArray3 := Copy (IntArray1, Low(IntArray1), Length(IntArray1)); 
 // Modify items
 IntArray2 [1] := 100;
 IntArray3 [2] := 100;
// Check values for each array
 Show (Format ('[%d] %d -- %d -- %d', [1, IntArray1 [1], IntArray2 [1], IntArray3 [1]]));
 Show (Format ('[%d] %d -- %d -- %d', [2, IntArray1 [2], IntArray2 [2], IntArray3 [2]])); 
```

执行结果，我们会看到如下的输出：

```
[1] 100 -- 100 -- 1
[2] 2 -- 2 -- 100 
```

对 IntArray2 的变动也同步影响了 IntArray1，因为用 := 指派运算符，只是把 IntArray1 的地址存一份到 IntArray2 而已，内存空间是完全相同的一份，但在 IntArray3 则已经是独立的一份，所以对 IntArray3 的变动不会影响到IntArray1。

**对动态数组提供⼀些新的原⽣处理**

动态数组已经支持把常数数组指派给动态数组，以及提供动态数组的连接。

!!! note "笔记"
    这些对动态数组的功能延伸，是从 Delphi XE7 开始提供。


在实务上，我们可以写出像以下的源码，这比以往的源码都要来的更为精简：

```pascal
var
 DI: array of Integer;
 I: Integer;
begin
 DI := [1, 2, 3]; // Initialization
 DI := DI + DI; // Concatenation
 DI := DI + [4, 5]; // Mixed concatenation
 for I in DI do
 begin
 Show (I.ToString);
 end;
```
请注意，在上面的源码里面的 for-in 循环会扫描整个数组里面的元素，这源码是范例项目 DynArrayConcat 的一部分。另外，这些数组的元素型别可以是任何一种，上例是 Integer，我们也可以改为 record 或类别。

还有第二个功能增强，就是可以在指派时直接进行连接，但这是 RTL 的部份，不是编程语言上有所改变。要把动态数组弄的像字符串那么容易操作是不太可能的，但我们可以用 Insert 跟 Delete 来处理元素的连接跟删除。

这表示我们可以写出以下这样的源码了(也是同一个项目的源码):

```pascal
var
 DI: array of Integer;
 I: Integer;
begin
 di := [1, 2, 3, 4, 5, 6];
 Insert ([8, 9], di, 4);
 Delete (di, 2, 1); // remove the third (0-based)
```

### 开放数组参数.148

在数组的使用上有些情境非常特别，例如把一个不确定长度的清单作为参数传给函式。除了直接传一个数组作为参数，我们还会在这一节跟下一节介绍两个特殊的语法结构。具备这特性的函式之一，就是 Format 函式，我们在前面几个范例源码里面有使用到，它的第二个参数，就是以方括号建立起来的一个数组。

跟 C 语言不同(当然跟其他从 C 衍生的语言也不同)，在传统的 Pascal 语言里，函式跟程序的参数永远都是固定个数的。然而在 Object Pascal 里面，就有方法把不特定个数的参数透过数组参数来传递，从技术上来说，这就称为开放数组参数。

!!! note "笔记"
    从历史纵轴来看，开放数组参数的出现早于动态数组，但今日看来，这两个技术从实际作用的方法来看非常相似，几乎越来越无法区别了。这也是为什么我把开放数组参数放在动态数组之后进行讨论的原因。

开放数组参数的基本定义跟已定义的动态数组型别是一样的，前面加上const 叙述字。这表示我们可以定义参数的型别，但我们不用定义这个数组中一定要放几个元素不可。以下是这种定义的范例之一，也是从 OpenArray范例项目中撷取而来：

```pascal
function Sum (const A: array of Integer): Integer;
var
 I: Integer;
begin
 Result := 0;
 for I := Low(A) to High(A) do
 Result := Result + A[I];
end;
```

我们可以呼叫这个函式，传给它一个整数数组作为参数(当中当然可以参杂变量与常数，这个函式就会把其中每个数值拿来使用):

`X := Sum ([10, Y, 27*I]);`

假设有个整数型别的动态数组，我们可以把它直接传给一个要求开放数组参数的函式(假设这里就是要求整数数组)，以下就是这样一个范例，整个数组会被传进去作为参数：

```pascal
var
 List: array of Integer;
 X, I: Integer;
begin
 // Initialize the array
 SetLength (List, 10);
 for I := Low (List) to High (List) do
 List [I] := I * 2;
 // obtain sum of list elements using our function
 X := Sum (List);
```

这是如果我们是用动态数组，假如我们是用相同元素型别的静态数组，就可以也把它传给要求开放数组参数的函式，或者我们也可以呼叫 Slice 函式，把数组的一部分传去当参数(当成其中的第二个参数)。以下的程序片段(也是OpenArray 范例的一部分)示范了如何把一个静态数组的一部分传给 Sum 函式作为参数:

```pascal
var
 List: array [1..10] of Integer;
 X, I: Integer;
begin
 // Initialize the array
 for I := Low (List) to High (List) do
  List [I] := I * 2;
 // Obtain sum of list elements using our function
 X := Sum (List);
 Show (X.ToString);
 // Sum portion of the array
 X := Sum (Slice (List, 5));
 Show (X.ToString);
```
**变异型别的开放数组参数**

除了这些指定型别的开放数组参数，Object Pascal 也允许我们定义变异型别(type-variant)或者不指定型别(untyped)的开放数组作为参数。这个特殊的数组会拥有不定数量的元素，而这些元素的数据型别也可能各自不同。这也正是 Object Pascal 的限制进入区域之一，因为这里已经不是完全型别安全的区域了。

技术上来说，我们可以定义一个参数，它的型别是 array of const，用以把一个不确定数量与元素型别的数组作为参数来传给函式。举例来说，以下是Format 函式的定义(我们在第六章里面会讨论这个函式，在讨论字符串的时候，不过我已经在几个范例里面提过它了):

```pascal
function Format (const Format: string;
 const Args: array of const): string;
```


第二个参数是一个开放数组，他会接受不确定数量的值，事实上，我们可以用以下方式呼叫这个函式：

```pascal
N := 20;
S := 'Total:';
Show (Format ('Total: %d', [N]));
Show (Format ('Int: %d, Float: %f', [N, 12.4]));
Show (Format ('%s %d', [S, N * 2]));
```

请注意，我们可以把一个常数、变量内容，甚至是表达式当做参数传递。宣告这样的函式很容易，但我们要怎么实作它？我们怎么知道这些参数的型别？变异型别的开放数组参数是和 TVarRec 这个型别的元素完全兼容的。

!!! note "笔记"
    别把 TVarRec 记录和 Variant(变异型别)使用的 TvarData 记录搞混了。这两个结构的作用不同，也完全不兼容。即使连列出的可能型别也不一样，因为 TVarRec 所处理的型别都是 Object Pascal 的数据型别，而 TVarData 处理的型别都是 Windows 的 OLE 数据型别。关于 Variant(变异型别)，我们会在本章后面的篇幅来加以介绍。


以下我们列出在变异型别开放数组当中可以支持的资料型别，当然 TVarRec记录也就能支持：

```
vtInteger vtExtended vtPChar
vtWideChar vtCurrency vtWideString
vtBoolean vtString vtObject
vtPWideChar vtVariant vtInt64
vtChar vtPointer vtClass
vtAnsiString vtInterface vtUnicodeString
```

这个记录的结构包含型别(VType)，以及一个变异型别字段，我们可以透过这个字段来存取实际的资料(比一些页面的纪录更多，即使这是这些结构的进阶功能)

一般的作法是当我们的函式接收到这种型别的参数时，就透过 case 叙述句来对不同型别的数据进行处理。在范例源码函式 SumAll 里面，我想把不同型别的数据做加总，把字符串转换成整数，字符转成对应的有序数值，把布尔值的 True 转成 1。这个源码可以说相当的高端(里面还用到了指标引用：pointers dereference)，所以如果现在看不懂也不用担心：

```pascal
function SumAll (const Args: array of const): Extended;
var
 I: Integer;
begin
 Result := 0;
 for I := Low(Args) to High (Args) do
 case Args [I].VType of
 vtInteger:
 Result := Result + Args [I].VInteger;
 vtBoolean:
 if Args [I].VBoolean then
 Result := Result + 1;
 vtExtended:
 Result := Result + Args [I].VExtended^;
  vtWideChar:
 Result := Result + Ord (Args [I].VWideChar);
 vtCurrency:
 Result := Result + Args [I].VCurrency^;
 end; // case
end;
```

我已经把上面这个函式加入 OpenArray 范例程序里，可以用以下的源码来呼叫它：

```pascal
var
 X: Extended;
 Y: Integer;
begin
 Y := 10;
 X := SumAll ([Y * Y, 'k', True, 10.34]);
 Show ('SumAll: ' + X.ToString);
end;
```

这个函式的输出加入了 Y 平方值，以及 K 的有序值(107)，以 1 表示布尔值的 True，以及浮点数，结果如下：

`SumAll: 218.34`

## 记录数据型别.152

数组以数字索引定义了一连串的元素，而记录则以名称定义对应的成群元素。换句话说，记录是一连串被赋予名称与对应字段的元素，每一组都元素都有其特定的资料型别。记录数据型别的定义会把这些字段全部列出，包含每个字段的名称，以及对应数据应有的型别。早期的 Pascal 语法中，记录只能储存数据，改进到现在，记录也可以包含方法跟运算方法了，我们在本章稍后会再介绍。

!!! note "笔记"
    在大多数的编程语言里面都有记录这个型别，在 C 语言里面，被以 struct这个关键词建构，在 C++里面则是用方法的延伸定义来处理，跟 Object Pascal 的作法很像。有些『纯』面向对象式的编程语言则只能在类别里面进行加注，就没有提供 record 或 struct 这样的功能了。

以下是段简单的源码(这段源码是从 RecordsDemo 范例项目节录的)，里面定义了一个记录型别，并用这个型别定义了一个变量，以及一些使用这个变量的源码：

```pascal
type
 TMyDate = record
 Year: Integer;
 Month: Byte;
 Day: Byte;
 end;
var
 BirthDay: TMyDate;
begin
 BirthDay.Year := 1997;
 BirthDay.Month := 2;
 BirthDay.Day := 14;
 Show ('Born in year ' + BirthDay.Year.ToString);
```

!!! note "笔记"
    『记录』这个词在 Object Pascal 里面可能代表两种意思，一个是『记录』型别的定义，另一个则是使用记录型别的变量(或者也可以叫『记录』变量)。所以『记录』这个词有两种意思，一定要认清我们用这个名词的时候所指的是什么。

在 Object Pascal 里面，记录用来代表数据结构的时候，多于代表简单的字段列表，在本章的剩余部分会试着说明，但我们先从记录的传统用法开始。记录所使用的内存通常会被配置在局部变量的堆栈，或者全局变量所使用的全局内存空间。我们用 SizeOf 这个函式来强调这个现象，SizeOf 会回传一个变量所使用的内存空间大小(单位为 byte)，可以写成以下指令这样:

`Show ('Record size is ' + SizeOf (BirthDay).ToString);`

上面这个指令在 Win32 平台上，使用预设的编译设定时会回传 8 (它回传 8, 而不是 6 或 4 bytes，是因为使用了一个整数，以及另外两个 byte 字段-我们等下会在”字段对齐”的小节加以说明)。

换句话说：记录是值类型，这表示如果我们把记录指派给另一个记录变量，我们就会做一份完整的数据复制。如果我们对新的变量内容做修改，原来的记录变量内容是不会变动的。以下的程序片段用源码来说明这个概念：

```pascal
var
 BirthDay: TMyDate;
 ADay: TMyDate;
begin
 BirthDay.Year := 1997;
 BirthDay.Month := 2;
 BirthDay.Day := 14;
 ADay := Birthday;
 ADay.Year := 2008;
 Show (MyDateToString (BirthDay));
 Show (MyDateToString (ADay));
```

输出结果(用国际日期格式):

```
1997.2.14
2008.2.14
```

对同样一份数据做异动的情况，会发生在当我们把记录当成函式的参数传入时，就像上面的源码里面我们呼叫的 MyDateToString 函式：

```pascal
function MyDateToString (MyDate: TMyDate): string;
begin
 Result := MyDate.Year.ToString + '.' +
 MyDate.Month.ToString + '.' +
 MyDate.Day.ToString;
end;
```

呼叫这个函式的时候，都会完整复制一整份记录型别的数据。为了避免这个复制的情形发生，我们可以透过宣告该函式的参数是引用参数的作法，来达成对原始记录数据的变更。在下面这个范例源码里面，就特别以引用参数的作法来实作：

```pascal
procedure IncreaseYear (var MyDate: TMyDate); begin
 Inc (MyDate.Year);
end;
var
 ADay: TMyDate;
begin
 ADay.Year := 2016;
 ADay.Month := 3;
 ADay.Day := 18;
 Increaseyear (ADay);
 Show (MyDateToString (ADay));
```

假使原始记录变量的 Year 字段会因为呼叫这个程序而被增加，则呼叫完函式之后，原始变量的 Year 字段就会比呼叫前多一年：

`2021.3.18 `

### 使用记录数组

就像之前提到过的，数组可以把同一个型别的数据重复建置出来，而记录是在单一结构里面包含不同的元素。假使这两个型别建构子的用途是不同的，那么把它们两个混着用就是很正常的想法，也就是定义一个数组，让该数组的元素型别是记录型别(另一种混用法就很少见: 在记录中使用数组)。

这个数组的源码还是跟其他任何的数组一样，每个数组的元素使用一个记录型别的空间。我稍晚会介绍如何使用更复杂的结构，像是 Collection 或者Container 类别(用来储存多个元素)，在记录数组的使用上，我们可以学到更多数据管理的名词。

在 RecordTest 项目里面，我加进了一个 TMyDate 型别的数组，我们可以用以下的源码对这个数组进行配置、初始化并使用它：

```pascal
var DatesList: array of TMyDate; I: Integer;
begin
 // Allocate array elements
 SetLength (DatesList, 5);
 // Assign random array element values
 for I := Low(DatesList) to High(DatesList) do begin
 DatesList[I].Year := 2000 + Random (50);
 DatesList[I].Month := 1 + Random (12);
 DatesList[I].Day := 1 + Random (27);
 end;
 // Display the values
 for I := Low(DatesList) to High(DatesList) do
 Show (I.ToString + ': ' +
 MyDateToString (DatesList[I]));
```

假设 app 使用随机数据，则输出值就会每次都不一样，就像我以下撷取的结果:

```
0: 2014.11.8
1: 2005.9.14
2: 2037.9.21
3: 2029.3.12
4: 2012.7.2
```

!!! note "笔记"
    在数组中的记录，会自动以受管理的记录被自动初始化，这是 Delphi 10.4 Sydney 的新功能，我们在本章后段会再介绍。



### 变异记录 (Variant	Records) 

在Object Pascal 早期的版本中，记录型别也可以有变动的部份，也就是说，多个字段可能对应到相同的一个内存空间，即使这些字段的型别不同。(这个概念可以对应到 C 语言里面的 union)。另一个作法，我们可以使用这些变异字段或者群组来存取记录里面的同一个内存空间，但这些数据还必须考虑到不同的型别的观点。这种型别的主要用途，使用来储存大同小异的数据，或者用型别转换的方式来对同一块内存数据进行不同解译(透过强制转型，这在 Object Pascal 早期版本是可以的，今日的版本已经不允许直接做强制转型了)。变异记录的应用已经大幅被面向对象或其他更新的技术所取代了，目前只剩很少的系统函式库在很特别的情境下会内部使用到这个技术了。

变异记录型别的使用并不保证型别使用上的安全，在程序实务上也不建议使用。除非您已经是 Object Pascal 的专家，不然您不用特别去抓出这些情况。总之，这也是我决定不以实例说明这个观念的原因，当然也就不会特别介绍其用法了。如果您真的需要这方面的相关概念，请看一下我在 121 页中『变异型别的开放数组参数』那一节的范例程序中，对 TVarRec 的使用吧



### 字段对齐 (Fields	Alignments)

另一个跟记录相关的进阶议题，是这些记录用来进行对齐的方法，这个方法也让我们对于了解记录的实际大小更有帮助。如果我们深入观察函式库，我们会常常看到 packed 这个关键词在记录型别上出现：这表示记录必须尽可能使用最小的空间，即使这样的作法可能导致数据存取的动作变慢。

这个差异是从变异字段的对齐有 16bit 或 32bit 两种选项的时候开始出现的，所以在变异字段的内容储存的是整数时，即使这个整数只使用了 8bit，这字段的下一个内存开始的地址，也会是在该整数起始位置后的 32bit 处。这样的内存对齐机制，会使得源码的执行更为快速。

!!! note "笔记"
    字段的大小跟对齐作业会取决于型别的大小。所有大小不是 2 的 N 次方的型别，内存大小会自动配置为大于该大小的下一个 2 的 N 次方。举例来说，Extended 型别大小是 10 bytes，在记录中就会被配置 16 bytes(除非该记录在宣告时使用了 packed 关键词)


一般的字段对齐技术，都是被用在类似记录型别的数据结构，部分 CPU 架构在使用了这样的技术后，就能加速对独立字段的数据存取。我们可以透过＄ALIGN 这个编译器开关来改变字段对齐的设定。


使用{$ALIGN 1}这个设定，编译器会尽量节省内存的使用，就像我们在记录型别上使用 packed 这个描述字的效果，另一种极端，则是使用{$ALIGN 16}，这个设定会使用最大量的内存进行对齐机制，此外还有 4 跟 8 两种对齐的参数可以设定。

如果我们回头拿 RecordsTest 项目当成个例子，在里面的记录定义加上packed 关键词：

```pascal
type
 TMyDate = packed record
 Year: Integer;
 Month: Byte;
 Day: Byte;
 end;
```

SizeOf 这个函式的回传值现在就会回传 6, 而不是回传 8 了.用以下的例子作为进阶的范例，如果您对 Object Pascal 还不是很熟悉，可以先跳过这个例子。我们先看一下以下的结构(可以在 AlignTest 这个范例项目里面看到):

```pascal
type
 TMyRecord = record
 C: Byte;
 W: Word;
 B: Boolean;
 I: Integer;
 D: Double;
end;
```

当设定了{$ALIGN 1}，上面的结构会使用 16 bytes(这是 SizeOf 的回传值)，而在相对的内存地址里面，内容会像以下这样：


`C: 0 W: 1 B: 3 I: 4 D: 8`

!!! note "笔记"
    相对地址是以记录布局和以数值、字段配置之间的差异计算出来的。例如这样的算式：UIntPtr(@MyRec.w) – UIntPtr(@MyRec1)。指针跟地址符号(@)我们会在本章后面的部分介绍。

比较一下，如果我们把对齐的尺寸改为 4 (这会使数据存取的速度变快)，这个 size 就变成了 20 bytes，相对地址就变成了:

`C: 0 W: 2 B: 4 I: 8 D: 12`

如果我们用了很极端的选项{$ALIGN 16}，这个结构就需要 24 byte，对应的字段如下:

`C: 0 W: 2 B: 4 I: 8 D: 16`


### With 叙述句是什么?

另一个旧版 Pascal 的语言叙述句，会被用来跟记录或类别一起使用，就是With。这个关键词是比较奇特的 Pascal 叙述句，但它后来也在 JavaScript 跟Visual Basic 里面出现了。这个关键词的使用，能让程序人员少打一些字，但也很危险，因为许多原本该写清楚的类别、记录的名称被省却了之后，整段源码就变得不容易读了。我们可以发现，一直以来关于 With 这个叙述句的争论不断，因此我也建议我们使用这个叙述句的时候，要持保守的态度。不管怎么说，我觉得一定要把这个叙述句在本书当中加以介绍（这跟稍早提到的 goto 叙述句是不同的）

!!! note "笔记"
    对于是否要把 goto 叙述句从 Object Pascal 移除也一直有许多争论，对 with叙述句是否要从行动版的编译器中移除也一样。虽然有些使用情境是合法的，但有些范围的问题会随着 with 叙述句的使用而发生，这就是不再继续支持这个功能的好理由了（或者像 C#一样用一个别名来提供该功能）

with 叙述句的功能就是让源码能够简写。当我们需要使用一个记录型别变量(或者需要使用对象)时，为了不用每次要用到该变量时就输入该变量的名字，我们就可以用 with 叙述句来省却输入这个变量的名字，举例来说，当需要使用到记录型别时，我把以下这段源码：

```pascal
var
 ABirthDay: TMyDate;
begin
 ABirthDay.Year := 2008;
 ABirthDay.Month := 2;
 ABirthDay.Day := 14;
加上了 with 叙述句之后，可以把这段程序改写成：
with ABirthDay do
begin
 Year := 2008;
 Month := 2;
 Day := 14;
end;
```

这个作法可以在 Object Pascal 的源码当中套用在使用组件或其他类别的使用上。当我们的源码需要使用到对象或类别的时候，with 叙述句就允许我们可以简化源码，尤其是在巢状数据结构的使用上。

所以，我之所以不鼓励使用 with 叙述句的原因，就是它可能让微小的错误难以被找出来。这些难以发现的错误在本书的这个点当中很难说明。我们先来思考一个比较没有伤害性的情境，这已经会让我们白头搔更短，浑欲不胜簪。以下是一个记录以及使用这个记录的一些源码：

```pascal
type
 TMyRecord = record
 MyName: string;
 MyValue: Integer;
 end;
procedure TForm1.Button2Click(Sender: TObject);
var
 Record1: TMyRecord;
begin
 with Record1 do
 begin
 MyName := 'Joe';
 MyValue := 22;
 end;
 with Record1 do
 Show (Name + ': ' + MyValue.ToString);
```

是吧?这个应用程序可以编译、执行，但它的执行结果却跟我们第一眼看完以后期盼的结果不一样：

`Form1: 22`

这个输出结果的字符串部分并不是前面的程序设定的记录值，原因是第二个with 叙述句误用了 Name 字段，这不是记录里面定义的字段，而是另一个不在此程序范围中的变量(特别是使用到了 Button2Click 这个方法所在的 form组件的 name 字段了)

如果我们这么写:

`Show (Record1.Name + ': ' + Record1.MyValue.ToString);`

编译器就会显示错误讯息，表示这个记录里面并没有定义一个名为 Name 的字段。

通常我们可以说从 with 叙述句出现的时候，就在当时的范围内定义了一个新的识别符号，我们可以隐藏既有的识别符号，在同一段源码的范围内使用到其他的识别符号。这也是一个用来警惕大家不要使用 with 叙述句的好理由，尤其我们更该避免使用多个 with 叙述句，例如:

`with MyRecord1, MyDate1 do...`

在上面这个 with 叙述句里面的源码会变得很难懂，因为每个在该程序片段当中的字段，我们都得想想到底是从哪个记录参考来的。


## 带有⽅法的纪录

在 Object Pascal 里面的纪录，比以前的 Pascal 语言的纪录或者 C 语言里面的 struct 都要更为强大。事实上，记录跟类别一样，可以包含有与之相关的方法(我们稍后会介绍)，例如程序或函式。这些方法甚至可以重新定义语言本身的运算方法(这个功能称之为运算符多载: operator overloading)，我们会在下个章节介绍。

一个带有方法的纪录，基本上已经跟类别非常接近了，我们稍后就会发现这一点。而这两者之间最大的不同，只在他们管理内存的方式不同而已。Object Pascal 的记录具备现代编程语言的两种基本功能：

+ **方法**：也就是和记录数据结构直接链接的程序或函式，这些方法可以直接使用记录的数据字段。换句话说，方法就是在宣告记录型别的时候同时宣告的程序或函式(也可以只是预先宣告)。

+ **封装**：透过封装，我们可以限制某些数据字段或方法不被其他源码直接使用。我们可以透过 private 这个存取描述字来提供封装的功能，好让其他源码无法看见位于 private 区段的数据或方法。而 public 区段的字段跟方法则可以被所有源码所使用。预设的存取描述字是 public。

现在我们对记录的延伸功能有了核心观念的认识，我们来看一个简单的记录定义，这是从 RecordMethods 范例项目所节录的：

```pascal
type
 TMyRecord = record
 private
 FName: string;
 FValue: Integer;
 FSomeChar: Char;
 public
 procedure Print;
 procedure SetValue (NewString: string);
 procedure Init (NewValue: Integer); 
end; 
```

我们可以看到这个记录结构被分成两个部分:private 跟 public。我们可以宣告多个部分，public 跟 private 这些关键词在同一个记录宣告可以出现不只一次。但如果使用多次，就要留意到在不同区段的变量跟方法究竟是属于 private还是属于 public，不然我们的源码以后会很难懂。其次，上述的程序片段中，里面的方法都只有宣告名称，并没有实作方法的源码在里面，所以这些是属于预先宣告。

我们要怎么撰写这些方法的源码，好让整个定义完整呢?方法几乎完全一样，我们得写个全局的函式或程序。唯一不同的是，我们得用记录的名字来帮这些方法冠名，这些方法是以记录型别的名称跟实际上的方法名称组合而成的。实际写作的时候，我们可以直接指名要存取的域名，甚至是直接使用该记录型别的其他方法，而不用再写一次该记录的名字：

```pascal
procedure TMyRecord.SetValue (NewString: string);
begin
 FName := NewString;
end;
```

在这段源码里面，NewString 只是函式的参数，而 FName 则是记录的字段。

!!! tip "提示"
    先写好方法的定义，然后再一一写好完整的定义，这方法挺无聊的。我们可以直接在 IDE 里面按 Ctrl+Shift+C 这组快捷键，就能自动依照宣告的内容把实作所需要的程序样板全部自动产生出来了。我们也可以按Ctrl+Shift+箭头键(上/下)在方法宣告与完整源码之间快速切换。

以下是这个记录型别的其他方法实作源码：

```pascal
procedure TMyRecord.Init(NewValue: Integer);
begin
 FValue := NewValue;
 FSomeChar := 'A';
end;
function TMyRecord.ToString: string;
begin
 Result := FName + ' [' + FSomeChar + ']: ' + FValue.ToString;
end;
```

以下是介绍如何使用这个记录型别的简单程序范例：

```pascal
var
 MyRec: TMyRecord;
begin
 MyRec.Init(10);
 MyRec.SetValue ('Hello');
 Show (MyRec.ToString);
```

您可能已经猜到，输出的结果是这样子的:

`Hello [A]: 10`

而如果我们想要直接使用这个记录里的字段，会发生什么事呢?

`MyRec.FValue := 20;`

这段程序不仅可以编译，也可以执行。这就跟我们在 private 区段里面需告了字段一样令人惊讶。因为一般应该只有记录方法可以存取这些字段。原因是因为 Object Pascal 的 private 存取描述字，只对不同 unit 有作用。

所以如果这段程序是放在不同 unit 里面，就会变成不合法的指令了。但在宣告该记录型别的同一 unit 里面，这是完全合法的。同样的规则，适用在记录型别以及类别上面。


### Self:	 记录神奇的地方

假设我们有两个记录，例如叫做 MyRec1 跟 MyRec2，这两个记录是相同的记录型别，当我们呼叫一个方法，并执行它的源码。我们怎么知道这两个记录的源码到底是哪一个会被执行？在幕后，当我们定义了一个方法，编译器会自动加一个隐藏参数进去，我们呼叫该方法时，就有一个记录的参考存在了。


换句话说，上述的源码里面会被编译器转换成类似以下这样：

```
// 您写的： MyRec.SetValue ('Hello');
// 编译器产生： SetValue (@MyRec, 'Hello');
```

在上述的伪码里面，＠(address of)这个符号是用来表示内存所在的地址，通常用来取得一个记录型别的变量所配置的内存。

!!! note "笔记"
    重申一次，@( address of)这个符号我们会在本章最后再介绍一次，章节标题会是”那关于指标呢?”

这是呼叫方法的源码被转译的方法，但实际上的源码呼叫是怎么参考到这个隐藏参数的? 实际上是使用了一个特别的关键词”Self”.所以这个方法应该要写成：

```pascal
procedure TMyRecord.SetValue (NewString: string);
begin
 Self.FName := NewString;
end;
```

在这段程序编译的过程中，使用 Self 这个关键词至为重要，除非我们需要把记录整个进行参考。例如，把记录当做参数传给另一个函式。这个情境在类别的使用上就蛮常见的，在同样的情形下，类别也会使用完全相同的关键词”Self”来处理。

使用了”Self”这个关键词作为参数，会让源码更容易懂(虽然多写 Self 并不是必要的)，其中一个情境，是我们需要用同一个记录型别复制完全相同的数据时。在这个情境下，我们如果要对另一个实体进行数值测试：

```pascal
function TMyRecord.IsSameName (ARecord: TMyRecord): Boolean;
begin
 Result := (Self.FName = ARecord.FName);
end;
```

!!! note "笔记"
    Object Pascal 隐藏的参数 Self, 在 C++跟 Java 里面叫做 this，在 objective-C里面也一样用 self 喔。


### 为记录初始化

当我们定义了一个记录型别跟变量(或者称为记录的实体)，并把它宣告为全局变量时，记录里面的字段就已经被初始化了，但当我们在堆栈当中宣告的时候(可以想象这是个程序或函式内部的局部变量)，就不会自动初始化。所以当我们写了以下的源码(也是 RecordMethods 范例项目的一部分)：

```pascal
 var
 MyRec: TMyRecord;
 begin
 Show (MyRec.ToString);
 ```

这段程序的输出值则会多少有些随机变化。当字符串初始值是个空字符串时，字符字段跟整数字段会直接从被配置的内存空间中取值来用(就跟一般局部变量初始化的动作一样)。通常这个值会随着每次执行的时候，从内存取得的随机地址有所不同，像是：

`[  ]: 1637580`


这就是为什么在使用记录型别变量前，为记录执行初始化程序是很重要的(跟其他变量进行初始化一样重要)，避免读取非法的数据，因为那很容易导致整个应用程序挂点。

要处理这个情况，有两种不同的方式，第一种作法是为记录制作建构者，我们下一节就会谈到。第二种作法则是使用受管理的记录(managed record)，这是 Delphi 10.4 里面的新功能，本章后段我会再介绍。


### 记录与建构者(Constructors)

我们先从一般的建构者开始。记录也支持一种特别的方法，称为建构者，我们可以透过它来对记录进行初始化。跟其他方法不同的是，建构者可以建立一个新的变量实体(但仍旧可以对已存在的实体进行初始化)。以下示范怎么帮记录新增一个建构者：

```pascal
type
 TMyNewRecord = record
 public
constructor Create (NewString: string);
 function ToString: string; ...
建构者是包含源码的方法:
constructor TMyNewRecord.Create (NewString: string);
begin
 Name := NewString;
 Init (0);
end;
```

这么一来，我们就可以用以下两种写法之一来对记录做初始化了：

```pascal
var
 MyRec, MyRec2: TMyNewRecord;
begin
 MyRec := TMyNewRecord.Create ('Myself'); // class-like
 MyRec2.Create ('Myself'); // direct call
```

请注意，记录的建构者必须有参数：如果我们试着呼叫 Create，就会得到错误讯息：” Parameterless constructors not allowed on record types” (记录型别的建构者不能没有参数)。

!!! note "笔记"
    我们也可以为建构者制作多载或者用不同的名称制作多个建构者。我们在后面的章节中讨论到类别的建构者时会进行介绍。我们接下来会快速介绍一下受管理的记录(managed record)，使用不同的语法，也没有无参数的建构者，跟类别方法 Initialize 不一样。



### 运算符号的新纪元 (Operators	Gain	New	Ground) 

Object Pascal 语言另一个跟记录相关的功能是对运算符号进行多载，这个功能可以让我们对我们定义的数据型别所需的系统标准的运算符号进行多载(例如加、减、乘等等运算)。这个意思就是说，我们可以自己定义一个加法(一个特别的 Add 方法)，然后透过+符号来呼叫它。要定义这样的运算符号，我们可以使用 class operator 这个关键词来实作。

!!! note "笔记"
    透过重复使用已经存在的保留字，编程语言的设计者把这个功能对于旧有的源码冲击降到了 0。这个作法就是把常用的关键词做组合，例如 strict private, class operator, class var 等等。


class 这个名词，在这里是和类别方法(class method)做连结，我们之后会在第12 章介绍这个概念。在这个关键词之后，我们可以宣告运算方法的名字，例如 Add:


```pascal
type
 TPointRecord = record
 public
 class operator Add (a, b: TPointRecord): TPointRecord;
这里的 Add 方法，在我们使用 TPointRecord 这个记录型别的变量时，就可
以用+符号来呼叫了，例如：
var
 A, B, C: TPointRecord;
begin ...
 C := A + B;
```

变量 C 的结果就会是 A 跟 B 这两个记录型别变量相加的结果。有哪些运算符号是可以透过这个方式来重新定义的呢?基本上，整个 Object Pascal 编程语言里面的运算符号都可以，但我们不能定义 Object Pascal 没有定义过的运算符号喔，以下的运算符号都可以重新定义：

+ 型别转换运算符号(Cast Operators): Implicit, Explicit
+ 一致性运算符号(Unary Operators): Positive, Negative, Inc, Dec, LogicalNot, BitwiseNot, Trunc, 以及 Round 
+ 比较运算符号(Comparison Operators): Equal, NotEqual, GreaterThan, ,GraterThanOrEqual, LessThan, 以及 LessThenOrEqual
+ 二进制运算符号(Binary Operators): Add, Subtract, Multiply, Divide, IntDivide, Modulus, ShiftLeft, ShiftRight, LogicalAnd, LogicalOr, LogicalXor, BitwiseAnd, BitwiseOr, 以及 BitwiseXor. 
+ 受管理的纪录运算符号: Initialize, Finalize, Assign(请参阅下一节”运算符号与自定受管理的记录”，该节当中会介绍这三个在 Delphi 10.4新增的运算符号)


在我们实际撰写的源码里面，不用特别呼叫这些方法，我们只需要在源码中写入对应的运算符号即可，只有在定义的时候才需要写出这些特殊方法的名字，记得要在这些特殊方法的宣告前面加上 class operator，以免跟其他方法的名称重复了。例如我们可以在一个记录型别里面重新制作 Add 运算符号，而这个记录型别里面也可以有个方法叫做 Add.

当我们在定义这些运算符号的时候，我们得把所需的参数完整列出，运算符号只会在参数完全符合的时候才被套用。例如要提供两个不同型别的值相加的功能，我们就得在这个新的运算符号宣告里面写清楚，第一个参数是哪一种型别的值，第二个参数是哪种型别的值。实务上，运算符号的定义并不会提供自动切换的功能喔。而且我们必须很精准的定义型别，因为型别自动转换的功能在这里不会启动。很多时候这表示运算符号以多载功能，透过不同型别的参数定义了多种不同版本。

另一个我们需要留意的重要元素，是在用来定义数据转换的两个特殊运算符号：Implicit 跟 Explicit。第一个是用来定义一个隐含的型别转换(或者称为宁静转换)透过这种转换，数据不会有任何遗失(因为只是把内存数据用另一种型别的格式加以解释)。第二个符号(Explicit)则会真的把一个变数转换成另一种型别的变数。这两种运算符号都可以用来处理『转换前』，以及『转换后』的数据型别。

我们要留意到，Implict 跟 Explict 都可以基于函式回传的型别进行多载，这通常不可能发生在多载的方法上。实务上，在型别转换发生时，编译器会知道要回传的型别是什么，因此就会自动先把该做的型别转换给做了。例如，在 OperatorsOver 这个范例项目中，我定义了一个记录跟一些运算符号：

```pascal
type
 TPointRecord = record
 private
 X, Y: Integer;
 public
 procedure SetValue (X1, Y1: Integer);
 class operator Add (A, B: TPointRecord): TPointRecord;
 class operator Explicit (A: TPointRecord): string;
 class operator Implicit (X1: Integer): TPointRecord; 
end; 
```

以下则是这些运算符号方法的实作源码:

```pascal
class operator TPointRecord.Add(A, B: TPointRecord): TPointRecord;
begin
 Result.x := A.X + B.X;
 Result.y := A.Y + B.Y;
end;
class operator TPointRecord.Explicit(A: TPointRecord): string;
begin
 Result := Format('(%d:%d)', [A.X, A.Y]);
end;
class operator TPointRecord.Implicit(X1: Integer): TPointRecord;
begin
 Result.X := X1;
 Result.Y := 10;
end;
```

这样的纪录在使用上就很直觉了，我们可以写出这样的源码：

```pascal
procedure TForm1.Button1Click(Sender: TObject);
var
 A, B, C: TPointRecord;
begin
 A.SetValue(10, 10);
 B := 30;
 C := A + B;
 Show (string(C));
end;
```

第二行的资料指派(B := 30)就是透过 implict 运算符号来达成的，由于在呼叫Show 这个方法的时候，少了一个型别转换，所以我们自己在源码上面写清楚，用 explicit 型别转换处理它。另外也要思考一下，Add 运算符号不会更动传进来的参数，它只会回传一个新的数值。

!!! note "笔记"
    为了配合运算符号只会回传新数值的这个规则，要思考覆写一个新的运算符号，其实难度就更高了。如果一个运算符号建立了一个新的随机对象，那谁要来释放这个对象?

**在背景多载定义的运算符号**

这一小节比较进阶，您可能在第一次阅读本书的时候会想先跳过。

透过鲜为人知的方法，其实是有方法可以透过撰写完整的内部方法名称来呼叫运算方法的(例如 &op_Addition)，在方法前面加上&符号，不要直接写出该运算方法对应的符号。举例来说，我们可以把这个记录的加总方法改写如下(请参照范例项目源码，就可以看到完整的列表):

`C := TPointRecord.&&op_Addition(A, B);`

不过我很少看到有什么情形需要我们这样写的就是了。(定义运算符号的用意，是让我们能够简化运算方法的名称，直接写算式当然比写成一般的函数调用更为直觉，对吧?)

**实作出可交换性(Implementing Commutativity)**

假如我们希望值做一个能把整数数值加到记录当中的功能。我们可以定义以下的运算方法(这些源码也在 OperatorsOver 范例项目里面找到，提供给两种显然不同的纪录型别使用):

```pascal
class operator TPointRecord2.Add(A: TPointRecord2; B: Integer): TPointRecord2;
begin
 Result.x := A.X + B;
 Result.y := A.Y + B;
end;
```

!!! note "笔记"
    之所以要把这个运算符号定义在一个新的型别，而没有在已经定义好的纪录里面加上它，是因为同样的结构已经定义了 Implicit 转换，把一个整数换乘该记录型别了。所以我就不用另外定义一个新的运算符号，就能直接把整数加到记录里面了。这个问题我们会在下一节里面好好说明。

现在，我们就可以把一个浮点数合法的加入到记录里面了：

```pascal
var
 A: TPointRecord2;
begin
 A.SetValue(10, 20);
 A := A + 10;
```

然而如果我们把表达式子反过来写：

`A := 30 + A;`

编译器就会回报错误:

`[dcc32 Error] E2015 Operator not applicable to this operand type`

就像我们刚刚介绍过的，在实务上，运算符号定义后，是不会自动具备可交换性这个特质的，我们得自己重复制作，或者制作这个运算符号的另一种多载版本：

```pascal
class operator TPointRecord2.Add(B: Integer; A: TPointRecord2): TPointRecord2;
begin
 Result := A + B; // 提供可交换性
end;
```

**隐 含 转换与型别介绍 (Implicit Cast and Type Promotions)**

注意！这个重要：在呼叫运算符号时的解析，跟以往呼叫方法时的规则是完全不同的。当型别自动介绍发生时，是有可能发生单一一个表达式结束时，因为存在不同参数的多载，而导致函数调用产生混淆的情形的。这也是为何我们要更费心在 Implicit 运算符号的使用上。

以下面的表达式来思考前一个范例：

```pascal
A := 50;
C := A + 30;
C := 50 + 30;
C := 50 + TPointRecord(30);
```

这些表达式都没有问题。在第一个式子中，转型会在指派动作之后发生。第二个式子，编译器会把 30 转换成适当的记录型别。第三个式子，explicit 型别转换会强迫把第一个数值用 Implicit 转型。然后加法才能在这些记录中执行。换句话说，第二个参数的结果跟另外两个都不一样，我们来看看这个延伸版本的的源码执行结果中的 X 跟 Y 值吧：

```pascal
// Output
(80:20)
(80:10)
(80:20)
// Expanded statements
C := A + TPointRecord(30);
// that is: (50:10) + (30:10)
C := TPointRecord (50 + 30);
// that is 80 converted into (80:10)
C := TPointRecord(50) + TpointRecord(30);
// that is: (50:10) + (30:10)
```


### 运算符号与自定受管理的记录

在 Delphi 当中，提供了一组特别的运算符号，让我们可以用来定义受管理的纪录(Managed record)。开始介绍之前，我们先回顾一下记录在内存初始化的规则，以及一般的记录与受管理记录之间的差别。

在 Delphi 的纪录里面，可以包含任何型别的数据字段。记录里面如果只包含了一般型别(并非受管理的)型别字段，像是数值或者其他列举型态的数据，编译器就没有什么要额外处理的，就是在建立与释放记录时，处理内存的取用与释放。(请记得 Delphi 为记录布局内存时，并不会把内存的内容用 0 预先填入喔，但配置数组跟新对象实体的内存时就会先填入 0)。

如果记录当中含有由编译器管理的型别(例如字符串、接口)，编译器则需要在初始化(initialization)与终止时(finalization)的源码当中额外注入程序来进行管理。举例来说，字符串型别是需要进行计数参考的，所以如果记录其他数据超过了起始时字符串配置的长度范围，则记录内的字符串就需要减少计数参考的值，这会导致需要把字符串使用的记忆空间释放掉。因此，当我们使用本节里面介绍到的源码，例如受管理的纪录，则编译器在这些源码的前后自动加上 try-finally 区块来确保即使在出现例外情形时，数据仍然不受影响。这个作法已经维持很长一段时间，受管理的记录已经是 Delphi 语言的一部分了。

从 Delphi 10.4 开始，记录型别支持自定的初始化与终止程序，自定的程序会凌驾在编译器默认对受管理记录的处理作业。我们可以宣告一个包含自定初始化与终止程序的记录型别，当中可能包含有我们需要的各种资料型别，此时我们可以自行撰写对应这些数据的初始化与终止源码。这样的记录会被认定为『自定受管理的纪录』。

开发人员可以把传统的纪录改写成自定的受管理记录，只需要加入以下列出的运算符号(一或多个都可以):


+ 运算符号 Initialize 会在记忆空间被配置完成后触发，我们可以在当中写入对记录字段数据的初始程序。
+ 运算符号 Finalize 会在记忆空间被释放之前触发，我们可以在这当中进行需要的资料清理。
+ 运算符号 Assign 会在记录的数据需要被复制到另一个记录或者相同型别变量的时候触发，我们可以把记录当中的数据复制到另一个记录，如果我们所定义的记录有需要做一些客制处理的话。

!!! note "笔记"
    在受管理的记录终止程序被执行的时候，即使是在例外状况中(编译器会自动产生 try-finally 区块)，通常都会使用额外的方法来保护资源分配或实现清除数据的程序。我们会在第九章『透过受管理的纪录还原光标』那一小节里面来看个范例。

**带有初始化与终⽌程序的记录**

我们开始从以下这段简单的程序片段来介绍初始化与终止程序，:

```pascal
type
TMyRecord = record
 Value: Integer;
 class operator Initialize (out Dest: TMyRecord);
 class operator Finalize (var Dest: TMyRecord);
 end;
```

我们需要为这两个类别运算符号写出实作的源码，在以下范例中，我们在这两个函式中记录当时的值。这个范例(是 ManagedRecords_101 范例程序的一部分)中，我会为 Value 字段进行初始化，并记录的数据也包含当中的内存地址，好让我们能逐一检视程序中每个记录所使用的内存位置是否一致：

```pascal
class operator TMyRecord.Initialze (out Dest: TMyRecord);
begin
 Dest.Value := 10;
 Log(‘Created’ + IntToHec(Integer(Pointer(@Dest))));
end;
class operator TMyRecord.Finalize (var Dest: TMyRecord);
begin
 Log(‘Destoryed’ + IntToHex(Integer(Pointer(@Dest))));
end;
```

这个新的建构机制跟传统方式的不同处，在于新的建构机制会自动被触发。例如我们写了以下这段源码，编译器会在该记录需要被初始化与被终止时自动建立 try-finally 区块来管理这个记录型别：

```pascal
procedure LocalVarTest;
var
 My1: TMyRecord;
begin
 Log(My1.Value.ToString);
end;
```

在 Log 里面我们会看到以下的结果:

```
Created 0019F2A8
10
Destroyed 0019F2A8
```

即使我们用行内变量的方式来写:

```pascal
begin
 var T: TMyRecord;
 Log(T.Value.ToString);
```

在 Log 里面也会看到相同顺序的数据，只是内存位置可能不同了。

**指派(Assign)运算符号**

一般来说 := (指派)这个运算符号会把范例当中所有的数据进行复制。在受管理的纪录中(例如字符串)的指派与复制程序，也会由编译器进行适当处理。当我们在记录中宣告了自定的数据字段，以及自定的初始化源码，我们可能得改变一下预设的作法。因此在自定的受管理记录中，我们也可以自定指派(assign)运算符号。这个新的源码，会在源码中出现 := 的时候被触发，只是定义的时候关键词是用 Assign:


`class operator Assign (var Dest: TMyRecord; const [ref] Src: TMyRecord);`

运算符号源码的定义必须遵守很精准的规范，包含: 第一个参数必须是引用参数 (前面加上 var)，第二个参数则是常数参数，但必须也要用传址方式传递，所以必须用[ref]关键词或者 var 来达成。如果没这么写，编译器就会提出以下的错误讯息喔:

```
[dcc32 Error] E2617 First parameter of Assign operator must be a var parameter o the container type
[dcc32 Hint] H2618 Second parameter of Assign operator must be a const [ref] or var parameter of the 
container type.
```

以下是一个可以触发 Assign 运算符号作用的简单范例，

```pascal
var
 My1, My2: TMyRecord;
begin
 My.Value := 22;
 My2 := My1;
```

以上这个程序会建立以下的 Log(在 Log 当中也包含了记录的序号):

```
Created 5 0019F2A0
Created 6 0019F298
5 copied to 6
Destroyed 6 0019F298
Destroyed 5 0019F2A0
```

请注意，在记录被释放的时候，序号的顺序跟建立的时候正好是颠倒过来的，也就是最后建立的记录会最先被释放掉。

**把受管理的纪录当成参数**

受管理的纪录跟一般记录不同，也可以作为函式的参数或者回传值的型别。以下是几种不同情境的源码宣告：

```
procedure ParByValue (Rec: TMyRecord);
procedure ParByConstVallue (const Rec: TMyRecord);
procedure ParByRef (var RecL TMyRecord);
procedure ParByConstRef (const [ref] Rec: TMyReord);
function ParRetured: TMyRecord;
```

我们接下来就不一一检视每个函式的 log 了(有兴趣的读者可以执行范例程序 ManagedRecords_101 范例)，我们直接汇整相关的信息给大家:

+ ParByValue 会建立一个记录，并呼叫指派运算符号(如果有指派参数的话)把数据复制到新建的纪录，并在离开函式的时候把暂存用的纪录释放掉。
+ ParByConstValue 不会复制数据，也不会呼叫指派的程序。
+ ParByRef 不会复制数据，也不会呼叫指派的程序。
+ ParByConstRef 不会复制数据，也不会呼叫指派的程序。
+ ParReturned 会透过 Initialize 运算符号建立新的记录，并在回传时呼叫Assign 程序把新建的记录回传，源码会像是 my1 := ParReturned，并且在回传后离开程序的时候删除暂存用的纪录。

**例外处理与受管理的纪录**

当程序执行时抛出例外事件，通常记录会被清除掉，即使没有特地写出try-finally 区块加以处理，这跟对象的处理原则不太一样。这是从基础上就不同，而且这是受管理纪录确实有用的关键特性。

```pascal
procedure ExceptionTest;
begin
 var A: TMRE;
 var B: TMRE;
 raise Exception.Create(‘Error Message);
end;
```

在这个程序里，会呼叫两次建构函式跟两次解构函式。再强调一次，这是从
基础上就不同的，而且是受管理记录的关键特性。

**受管理记录的数组**

如果我们定义了一个静态的受管理记录数组，这些记录会在宣告的时候就先被呼叫 Initialize 运算符号进行初始化:

```pascal
var
A1: array [1..5] of TMyRecord; // 初始化时, 会从此处呼叫
begin
 Log (‘ArrOfRec’);
```

这些记录会在离开函式的时候被释放。而如果我们宣告动态的受管理记录数组，初始化的程序将会在该数组的空间被定义时被呼叫(使用 SetLength):

```pascal
var
A2: array of TMyRecord;
begin
 Log (‘ArrOfDyn’);
 SetLength(A2, 5); // 在此处呼叫
```

## 变动型别(Variants) 

为了要完整支持 Windows 的 OLE 跟 COM 技术，Object Pascal 在原生数据型别当中就有所谓的松散型别概念，这个型别就是 Variant。即使这个名称可能唤起你对变动记录(我们稍早介绍过)的印象，而且在实作层面上跟开放数组参数有点类似，Variant 是完全不同的功能，实作上也是用特殊的方法来完成的(Windows 开发世界中不常用的语言)。

在这一节里，我不会真的去参照 OLE 跟这个数据型别参照的其他情境(像data set 介绍时要提及字段存取一样)。我只想从一般观点来讨论这个数据型别。

我会回头来看动态型别，RTTI(RunTim Type Information)并参照第 16 章，在那个章节里面，我也会提到一个相关的型别(但是是型别安全，而且执行速度快很多的喔)，称为 TValue。


### 变动型别没有型别(Variants	Have	no	Type)

一般来说，我们可以用 Variant 变量来储存任何型别的数据，并且进行数字运算、型别转换。在 Variant 的使用上，自动型别转换会打破 Object Pascal所遵循的型别安全的通则，而实现出动态型别的概念，这个概念在其他语言中有被介绍过，例如 SmallTalk 跟 Objective-C，在一些脚本语言里面也提供了这样的功能，像是 JavaScript, PHP, Python 跟 Ruby.


变动型别会在运行时间进行型别判别跟运算。编译器不会警告我们在源码里面可能有什么错误，因为它只能做一些延伸测试。整体来看，我们可以把使用了变动型别的源码视为直译源码，因为也只有直译器的源码才会在运行时间才能检查数据的正确性。实务上，这也直接冲击到执行的速度。

现在，我要提出警语，让大家尽量避免使用 Variant 这个型别，我们来看一下 Variant 能做什么。基本上，当我们宣告了一个 Variant 型别的变量:

```pascal
var
 V: Variant;
```

我们就可以把很多不同型别的数据指派给它了：

```pascal
V := 10;
V := 'Hello, World';
V := 45.55;
```

我们一有了 variant 数值之后，就可以把它复制到任何兼容或不兼容的数据型别去了。如果我们把一个数值指派到不兼容的数据型别变量去，编译器并不会在编译的时候指出错误，而会在运行时间进行可接受的型别转换。如果找不到可接受的型别转换，就会抛出一个运行时错误的讯息。技术上来看，Variant 会把型别信息随着数据做储存，允许一些可容许的运行时间型别转换，但会会牺牲速度，且比较不安全。

我们看一下以下的源码(这是 VariantTest 范例项目的一部分)，这是上面源码的一些延伸：

```pascal
var
 V: Variant;
 S: string;
begin
 V := 10;
 S := V;
 V := V + S;
 Show (V);
 V := 'Hello, World';
 V := V + S; Show (V);
 V := 45.55;
 V := V + S;
 Show (V);
```

有趣吧?以下是输出结果(不意外):

```
20
Hello, World10
55.55
```

除了把储存有字符串的 variant 变量指派给 S 变量，我们也可以把储存有整数、浮点数的 variant 变量指派给 S 变量试试看。再折磨它一下，我们可以用 variant 来计算数值，例如 V := V + S; 这个算式会以 variant 里面储存的数据格式来试着直译多种计算的方法。在以上的源码里面，同一行算式可能对整数、浮点数进行加总，也可能是做字符串连接。

在算式里面放了 variant 是有风险的。如果该字符串里面是储存数字，那么运算就 ok, 但如果不是，就会跑出运行时错误了。如果你不是要特别引人注意这个情形，就不要使用 Variant 这个型别。还是使用标准的 Object Pascal数据型别，以及型别检查的规则吧。


### 深入探讨变动型别(Variants	in	Depth) 

深入了解 Varaint 也是很有意思的，我们再多加一些技术信息吧。Variant 是怎么运作的，我们又能怎么更深入控制一些?RTL(运行时间函式库)包含了变动记录型别:TVarData, 这个型别对内存的控制跟 Variant 一样。我们可以用它来存取 Variant 数据的实际型别。TvarData 结构包含了 Variant 的型别，用VType、一些保留字段、以及实际值来标示。要记得 null 值的概念，我们可以使用 NULL 来指派给特定值(不是 nil)。

!!! note "笔记"
    如果需要更详细的研究 TVarData 这个型别的定义，请参考 RTL 的原始码，在 System 单元文件中可以找到。它的定义跟一般简单的数据结构定义很不一样。我建议具备了足够经验之后再去看关于变动型别的定义比较好。

VType 这个字段的内容会随着我们在 OLE 变量里面所储存数据的型别而有不同。通常 OLE 变量的型别会被称为 OLE 型别或变动型别(variant types)，以下列出所有可用的变动型别：

```
varAny varByte varDate
varEmpty varInteger varOleStr
varSingle varTypeMask varUString
varArray varByRef varDispatch
varError varLongWord varRecord
varSmallint varUInt64 varVariant
varBoolean varCurrency varDouble
varInt64 varNull varShortInt
varString varUnknown varWord
```

以上的型别名称都很直觉，几乎都从字面上就可以知道它的用途。

有很多函式可以用来处理 variant，我们可以用来制作特定的型别转换，或者用来询问一个 variant 变量的真正数据型别(例如 VarType 函式)。这些型别转换跟指派的函式通常都会自动被使用，当我们撰写了使用到 variant 变量的表达式时就会自动使用到。其他支持 variant 的源码，实际上是使用了 variant数组，再次重申，这个结构几乎只有 Windows 用在 OLE 整合的时候才会使用，其余平台、情形几乎不会有用到的机会。




### 变异型别很慢(Variants	Are	Slow) 

使用了 Variant 型别的源码会很慢，不只是当我们在做数据型别转换的时候，即使是我们做很简单的两个数字相加也一样。它的速度几乎跟直译器的程序一样慢。为了比较使用 variant 跟使用一般整数的执行速度，我们用相同的算法来实验，我们从 VariantTest 范例项目的第二个按钮程序来看。

这个程序会跑一个循环，计时、然后更新进度列的状态。以下是两个相似循环中的第一个，以 Int64 跟 Variant 来比较：

```pascal
const MaxNo = 10_000_000; // 10 million
var
 Time1, Time2: TDateTime;
 N1, N2: Variant;
begin
 Time1 := Now;
 N1 := 0;
 N2 := 0;
 while N1 < MaxNo do
 begin
 N2 := N2 + N1;
 Inc (N1);
 end;
 
 // We must use the result
 Time2 := Now;
 Show (N2);
 Show ('Variants: ' + FormatDateTime ( 'ss.zzz', Time2-Time1) + ' seconds');
```

计时的源码值得看一下，因为未来我们可以用这个方法来做任何可能的效能测试。我们可以看到源码里面用 Now 函式来取得当时的时间值，然后用FormatDateTime 函式来显示时间的经过，可以用 ss 来显示经过了几秒，或者用 zzz 来显示经过了几个 ms.在这个范例里面，速度的差异非常显著，即使不特别去计算也能注意到:

```
49999995000000 Variants: 01.169 seconds
49999995000000 Integers: 00.026 second
```

上面的数字是我在 Windows 虚拟机上面执行的结果，variant 的结果比直接用整数慢了 50 倍。当然，在每一台计算机上执行的结果都会不一样，但差别不会太大，用越快的机器来跑，这个倍数说不定会增加的更为显著。在我的 Android 手机上面，执行结果如下(花的时间都更长，这是一定的，手机的运算能力本来就不如桌机):

```
49999995000000 Variants: 07.717 seconds
49999995000000 Integers: 00.157 second
```

在我的手机上，速度比 Windows 慢了 6 倍，事实上执行花了 7 秒多，这样的运行时间一定会让使用者很有感觉。但用整数实作的源码执行起来虽比桌机运行时间多 7 倍，但连 0.2 秒都不到，使用者仍旧很难意识到这个等待的时间


## 指标的两三事(What	About	Pointers)

在 Object Pascal 里的另一个基础数据型别就是指针。有一些面向对象语言已经把这个强大却有些危险的程序结构给藏起来了，不过 Object Pascal 仍旧让程序人员在需要的时候使用它(不过已经不如以前那么常用到了)。

但什么是指标呢? 这个名词又是哪来的? 跟其他大多数的数据型别不同，指针不储存实际的数据，它只储存变量在内存里面的地址，透过指针，我们可以找到变量的实际使用内存空间，进而得到里面的数据。

!!! note "笔记"
    在本书中，这部份属于进阶的章节，在此介绍指标是因为它是 Object Pascal 语言的一部分，而且是所有程序人员都需要知道的核心知识的一部分。虽然它并不是基础的主题，如果您是刚接触 Object Pascal 的话，您可以先跳过这个章节，未来再回来复习即可。如果您过去接触的编程语言都是没有指标的类型，这个短短的章节对您来说读起来也可能很有趣。

指针的定义并不是透过特定的关键词，它是透过特别的符号(ˆ)来宣告的。举个例子，我们可以定义一个指针，指向整数变量：

```pascal
type
 TPointerToInt = ^Integer;
```

我们定义好指针变量之后，就可以把另一个同型别的变量的地址指派进去了，只要透过@符号即可：

```pascal
var
 P: ^Integer;
 X: Integer;
begin
 X := 10;
 P := @X;
 // change the value of X using the pointer
 P^ := 20;
 Show ('X: ' + X.ToString);
 Show ('P^: ' + P^.ToString);
 Show ('P: ' + Integer(P).ToHexString (8));
```

以上的源码是 PointerTest 范例项目的一部分。假设指针 P 指向了变量 X，我们就可以用 Pˆ取得 X 的数据，可以读取也可以变更里面的内容。我们也可以独立显示 P 的内容，P 的内容就是变量 X 在内存里面的地址，我们可以把指针转型为数值(透过特殊型别 UIntPtr，请参考下面的提示)，就可以看到地址了。上面的范例程序不显示整数，而是以 16 进位来显示，这在内存的寻址里面比较常见，以下是程序的输出结果(指针的内容会随着编译与执行的结果有所不同)：

```
X: 20
P^: 20
P: 0018FC18
```
!!! note "笔记"
    要对指标的内容做整数转型，只有在 32 位的平台，并限制在 2GB 之内的地址才会正确，如果我们需要在更大的内存地址当中进行，则我们需要使用 Cardinal 型别。对 64 位平台而言，比较好的作法是使用 NativeUInt 这个型别。然而这是型别的别名，特别用来处理指标的，这型别叫做 UIntPtr，在处理指标的时候，最能够明确的让 Delphi 的编译器知道要做什么。我来整理一下，当我们宣告了指针变量 P:

+ 直接使用指标(P), 我们可以取得 P 所指向的内存地址。
+ 使用指标指向(Pˆ), 我们可以取得 P 指向的内存内容。

指针不只可以指向已经配置好的内存地址，它也可以动态指向特定的内存区块，例如我们可以用 New 程序来配置一块新的内存空间，此时就可以用指针储存刚配置好的这块空间的地址。而当不需要再使用的时候，就可以用Dispose 程序来释放它(行动平台则使用 DisposeOf)。

!!! note "笔记"
    内存管理跟 Heap 作业的细节，我们会在第 13 章里面加以介绍。简单的说，Heap 是一大块由操作系统配置给应用程序随机取用/释放的内存空间。除了New 跟 Dispose 之外，我们也可以用 GetMem 跟 FreeMem 来取用额外的内存空间，这些作法都需要开发人员提供要配置的内存大小(编译器在使用New 跟 Dispose 的情境下，会自动配置所指定的空间)。在编译阶段还无法确定需要多大空间的时候，GetMem 跟 FreeMem 则会比较方便。

以下程序片段是用来示范如何使用随机配置内存：

```pascal
var
 P: ^Integer;
begin
 // Initialization
 New (P);
 // Operations
 P^ := 20;
 Show (P^.ToString);
 // Termination
 Dispose (P);
```

如果在使用后没有把内存释放掉，我们的程序最后就会把可用的内存用尽，然后挂掉。没有把配置的内存释放掉的错误，通常称为内存泄漏(Memory leak)。


!!!  note "笔记"
    要让上面的范例程序安全一点，我们可以用 try-finally 区块，这个主题我们会在第九章进行介绍。

如果一个指针变量没有值，我们可以指派 nil 给它。我们可以先检查指标的内容是否为 nil，如果不是 nil，我们才能够去读取其指向的内存空间内容。Object Pascal 提供了一个名为 Assigned 的函式，让我们可以方便进行这样的测试。

这样的测试很常用，因为存取未被配置的内存空间内容，会导致内存违规存取而使程序错误(不同操作系统对内存违规存取的处理各有不同的作法，Windows 会跳出一个错误窗口，iOS 跟 Android 则是直接关闭该程序)：

```pascal
var
 P: ^Integer;
begin
 P := nil;
 Show (P^.ToString);
```

我们可以执行 PointerTest 范例项目来看看发生这个错误的反应，Windows的错误窗口会显示如下的信息：

`Access violation at address 0080B14E in module 'PointersTest.exe'. Read of address 00000000.`

为了让存取指标更为安全，我们可以加入检查，看看指标内容是否为 nil:

```pascal
 if P <> nil then
 Show (P^.ToString);
```

另外，在 Object Pascal 里面提供的 Assigned 也可以用来检查这种情形:

```pascal
if Assigned (P) then
 writeln (P^.ToString);
```
!!! note "笔记"
    Assigned 倒不是一个真的函式，因为这个关键词会让编译器产生适当的检查源码。Assigned 也可以用在检查程序型别变量(或者方法参考)是否有被指派，不用真的执行看看该程序或方法是否存在。

Object Pascal 也定义了一个名为 Pointer 的数据型别，这个型别可以指向未定义型别的指针(就像 C 语言里面的 void*)如果我们使用了未定义型别的指标，我们就得用 GetMem，不能用 New 来配置内存空间。因为用 New 来配置，系统会以 New 所要配置的数据型别自动计算大小来配置，但为定义型别的指针无法自动由编译器判别需要多少空间。而我们使用 GetMem 来配置空间时，可以指定需要配置的内存空间大小。

事实上，在 Object Pascal 里面不常需要使用指标，但指标是这个编程语言里面一个有趣的进阶功能。能够提供这个功能，就能让我们实作出一些可以直接呼叫操作系统层级，高效率的 API 跟函式了。无论如何，了解指标对进阶程序设计以及完全了解 Delphi 的对象模型是很重要的(在实作层面中，就是透过指针来实现的，一般也会称为参考)。

_____________________________________________________________________
!!! note "笔记"
    当某个变量内容储存的一个指向第二个变量的指针，而第二个变量已经脱离其生命周期范围(例如被动态释放了)，该指针所指向的数据可能是未被使用的内存空间，或者是已经被用来储存其他数据了。这可能会让侦错程序变得很难啊。 




## 档案型别,	 还有谁有提供?(File	Types,	Anyone?)


本章最后的一节，我们来介绍 Object Pascal 数据型别建构的过程，就是档案(file)型别。档案型别是用来表示实体磁盘档案，这也是原始 Pascal 语言里面就具备的功能，相较起来，目前已经很少有旧的或现代的编程语言会把档案的概念作为基本的数据型别了。Object Pascal 语言也提供了 file 关键词，用来代表档案型别，就像 array 或 record 一样。我们可以用 file 来定义一个新的型别，然后用这个型别来宣告新的变量:

```pascal
type
 IntFile = file of Integers;
var
 IntFile1: IntFile;
```

我们也可以直接用 file 这个关键词，不用指定该档案的内容型别，直接定义一个档案。当然我们也可以使用 TextFile 型别，这个型别定义在 RTL 里面的 System 单元，使用来宣告使用 ASCII 字符的档案(或者更精确一点，是定义 byte 组成的档案)。

最近这几年来，直接使用档案已经越来越不常见了，不过这个功能还是存在的。在 RTL 里面已经提供了很多种可以用来管理二进制跟文本文件的类别(例如，支持 Unicode 的文本文件)。

Delphi 应用程序一般来说都会使用 RTL 的 stream 类别(TStream 以及衍生的相关类别)来处理许多跟档案相关的读写动作。Stream 用来表示虚拟档案，可以对应到实体档案、内存区块、网络信道，以及任何其他连续的 byte 组合。

我们还是可以看到许多旧时代的档案管理函式，那些是提供给命令字符模式(DOS 命令字符)的程序开发之用，我们可以使用 write, writeln, read 等相关函式来对特定型态的档案进行读写的动作，这些都是使用标准输入、标准输出加以提供的(C 跟 C++也对输入输出有类似的支持，其他的编程语言也提供了类似的服务)。
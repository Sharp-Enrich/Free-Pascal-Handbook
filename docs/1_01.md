这个章节会从一些可以用来建立一个 Object Pascal 应用程序的程序片段开始，会涵盖到一些标准的程序写法，程序批注、介绍关键词与完整程序的架构。我会开始写一些简单的程序，试着用透过说明这些源码来介绍并带出接下来几个章节的关键概念。

## 我们开始来看源码吧

这个章节涵盖了ObjectPascal语言的基础，但也会花我们几个章节的篇幅来带领读者们理解整个应用程序作业的一些细节。所以，我们先来快速的看两个入门的程序吧(它们的架构会有所不同)，我们不会看的太仔细。目前我只想介绍一下我会用来建立范例程序的架构，接着我们才能介绍其他不同的部分。所以，我希望读者能够尽快开始把书里提到的练习用相关信息取回，从最开始的练习范例开始看，会是个好主意。

!!! note "笔记"
    如果您是 Object Pascal 这个语言的初学者，需要逐步操作的指引来协助您使用本书的范例程序，或者让您可以自己开始动手写程序的话，请参阅本书的附录 C.

Object Pascal 一开始就被设计成在透过 IDE 环境中可以实时上手，经由这个语言与 IDE 的坚强组合，Object Pascal 提供了对程序人员最友善的快速开发工具与语言，同时也是执行速度上对机器友善的编程语言。

在 IDE 里面，您可以设计用户接口、协助您撰写源码，执行写好的程序，还有更多的辅助功能。在本书中，就像我会介绍 Object Pascal 这个编程语言，我也会跟您分享我使用 IDE 的方法。

### 第⼀个⽂本模式的应用程序

在一开始，我要透过一个文本模式应用程序，只简单的显示 Hello, Word 这样一个字符串，来介绍 Pascal 程序语法的一些重要的部分。文本模式的应用程序，换句话说就是没有窗口画面的应用程序，执行时会以终端机窗口显示文字，接受用户透过键盘输入，也只以终端机窗口显示结果。文本模式的应用程序在行动平台上面不常派上用场，但还是会用在 Windows 系统上(最近几年微软花了一些功夫改进 cmd.exe, PowerShell 以及终端机应用)，另外，文本模式应用程序在 Linux 上面也还是很常用到的。

我暂时不会对以下这些源码做太多说明，这也是本书前几章的用途，以下
是 HelloConsole 这个程序项目的源码内容：

```pascal title="HelloConsole.pas"
program HelloConsole;
{$APPTYPE CONSOLE}
var
strMessage: string;
begin
strMessage := 'Hello, World';
writeln (strMessage);
// 以下这个指令，是用来等待使用者输入，直到使用者按下 Enter 键为止
readln;
end.
```

!!! note "笔记"
    在一开始的介绍中，我们已经介绍过，本书所有完整的源码都可以在 GitHub的档案库里面下载。这些范例的详细介绍则会在本书里面进行，在前文中，我已经提到项目名称(在本范例里面叫做 HelloConsole)，项目名称也会用来当做文件夹的名称，该文件夹里面还有许多跟这个项目相关的档案，由于我会把一个章节的范例放在同一个文件夹里面，所以上面这个项目的文件夹名称会是 01/HelloConsole

您可以在范例程序第一行看到程序的名字，程序名之后会包含一些指示词(directives)：编译器的设定值(会以$这个符号开头，并且用大括号整个包起来)、变量宣告的区块（一个字符串变量，命名为 strMessage），以及被 begin跟 end 所包起来的三行源码跟一行说明用的批注。

这三行源码会把一段文字复制到一个字符串变量里面去，调用一个系统函数来把这个字符串变量里面的内容输出在文本模式窗口里面，并且调用另
一个系统函数，等待用户输入（在这个范例中，只是用来等待使用者按下Enter 键）。我们接下来就可以自行定义我们需要的函数，不过 Object Pascal已经帮我们附上了数百个常用的函数了。

再强调一下，我们很快就会开始介绍这些程序内容，在一开始的章节，我们只是给您一个简单的印象，让您大概知道 Pascal 完整的程序大概长什么样子而已，当然您也可以直接打开、执行这个程序，程序执行的画面，会像图 1.1 的 DOS 窗口一样，窗口的内容文字如下：

```text
Hello, World
```
### 第一个图形界面程序

现代的应用程序，都已经不像上面这个范例，长得像很传统的文本模式窗口，通常会有许多可视化的元素（在Object Pascal里面我们称之为控制组件）显示在窗口画面中。在本书中，我们大部分的范例都会是用FireMonkey组件库(现在简称为FMX了)来制作的图形接口程序（即使大多数案例我都会把它简化到只显示简单的文字）。

!!! note "笔记"
    在 Delphi 里面，视觉组件库已经区分成两个不同的类别了：一个是 VCL (专属 Windows 平台上面使用)，以及 FireMonkey（支持多种不同的平台、装置，包含桌面应用程序跟行动装置都支持）。要把这些范例改为 VCL 版本也都非常容易。


要了解一个图形接口程序结构的细节，您必须把本书大多数的篇幅都读过，例如一个form是一个特定类别的对象实体，它包含了许多方法、事件处理程序，以及属性。刚刚这句话所提到的每个部分，在本书中都会介绍到。但要建立一个应用程序，您不需要先成为专家，您只需要透过选单上面的选项，就能轻松的建立一个新的桌面应用程序或行动装置应用程序了。我在本书前面几个章节要介绍的，都会是以FireMonkey的范例为基础（两种IDE都支持），简单的介绍如何透过form的选单跟鼠标点击操作来完成这些动作。一开始，请您先建立任何一种form（桌面或行动应用程序均可，通常我会建立一个Multi-device的空白应用程序项目，这个项目在Windows环境也可以执行的），然后放一个button组件在上头，以及一个多行的文字组件(或者Memo也可以)来显示输出的结果。图1.2就是让您看一下在IDE里面，预设情形下，这个行动应用程序的form会在开发环境里面长什么样子。选择用安卓的样式预览(您可以看到图1.2里面右上角有个下拉选单)，然后新增一个按钮控件到这个form里面。

图 1.2: HelloVisual 范例在 IDE 环境中显示的画面：

您如果想要制作一个类似的应用程序，只需要先建立一个空白的行动应用程序，然后在空白的form上面加入一个button组件即可。现在，我们来加入源码吧。这也是目前我们要接着介绍的，请用鼠标左键双击form画面上的按钮，您就会看到以下的源码在画面上显示出来(也可能是很类似的其他源码)。

```pascal
procedure TForm1.Button1Click (Sender: Tobject) begin
end;
```

即使您都还不知道类别的方法是什么(就是上面这段程序的Button1Click啦)，你也已经可以在上面的源码的begin跟end之间加入一些源码了，这些源码就会在项目执行时，当我们用鼠标左键点选按钮的时候被执行到。

我们的第一个图形接口程序，会有一些源码跟第一个文本模式程序完全相同，只是在图形接口程序里面，我们调用了不同函数库里面的不同函数，在这个范例程序中，我们调用的是ShowMessage。这个范例的源码，您可以在名为HelloVisual的文件夹里面找到，您可以试着直接编译它，就可以发现执行编译的动作真的是非常的简单：

```pascal
procedure TForm1.Button1Click (Sender: Tobject)
var
  strMessage: string;
begin
  strMessage := 'Hello, World';
  ShowMessage (strMessage);
end;
```

请留意到 strMessage 这个字符串变量的宣告，是写在 begin 这个保留字之前，而真正执行的源码则是写在它之后，再说一次，如果对于任何部分觉得不太清楚，别担心，所有程序都会随着您读到越后面，而有更详细的说明。

!!! note "笔记"
    您可以在名为 01 的目录中找到本章所有范例的原始码，为了容易辨认，在这个范例的文件夹里面有一个名称跟项目档很相似的档案，我把这个文件名的前面加上了”Form”，以利区分，这也是我在本书当中用来为档案命名的标准规则，项目的结构将会在本章的后面篇幅介绍

在图1.3里面，您可以看到这个简单程序的Windows上面透过启用FMXMobilePreview 模式后执行的结果，但您也可以把这个范例程序拿到Android或者iOS，macOS上面执行，结果也会相同的(但这需要先在IDE里面做一些额外的设定才能正常运作喔)。

!!! note "笔记"
    FireMonkey Mobile Preview 模式可以让 Windows 应用程序看起来有点像是行动装置 App, 在本书中的大多数范例中，我都启用了这个模式。要启用这个模式，只需要在项目原始码当中的 MobilePreview 单元档案里面加入一个use 的指令即可。

现在我们已经介绍怎么撰写、测试一个范例程序了，让我们回头仔细看一下细节，一如我们在本章开始的时候我提到的顺序。我们要介绍的第一件事，就是如何阅读程序，各个不同部分的源码要如何撰写、以及我们刚建立这个项目是怎么组成的。（这个项目会包含有PAS档案跟DPR档案）

图 1.3: HelloVisual 范例只有一个简单的按钮执行的画面：

## 语法和源码样式

在我们开始介绍Object Pascal程序指令之前，我们要先来看一些Object Pascal源码的样式，我在这里想要点出的问题是：在程序语法之外（我们还没开始介绍），我们要怎么来撰写源码呢？这个问题并没有固定的标准答案，每个人都有自己习惯的写法，不同的习惯写法就会让源码看起来有不同的样式。然而，还是有一些固定的规范必须先介绍给大家知道，例如批注、大小写、空格符，以及多年以前曾经被称为美观打印的排列样式（这里指的美观当然是让人来阅读，跟计算机没有关系），而这个名词现在也已经很少听到人提起了。

通常源码样式是为了让人在阅读源码的时候可以更简洁、更快速的了解源码，这些样式跟格式就是您可以决定的一些源码的排列方法，好让程序看起来更整齐。而要让源码看起来整齐，就必须要坚持相同的源码样式，不管您选择了哪一种样式，记得要在整个项目的所有档案当中都用同样的源码样式，不然反而会让源码看起来更难懂。

!!! note "笔记"
    IDE(Integrated Development Environment，整合开发环境，可以简称为开发环境)已经支持自动格式化源码的功能（可以选择针对单一档案或者整个项目），您可以按下快捷键 Ctrl+D 要求 IDE 对目前的档案进行源码样式重新格式化，这个格式化的功能可以让我们自己对 40 几个源码样式的细节做设定。(请从 Options 选单当中找到这个设定画面)，您也可以把这西设定汇出，让同一团队的其他开发人员共享这些设定值，这样可以让整个团队的程序样式更为一致。但是，自动格式化的功能对于最新加入的部份编程语言功能并没有完全支持喔。

### 程序批注
虽然源码通常已经很容易被读懂，但如果加上一些批注的话，其他人就更容易看的懂（如果过了一段时间之后，我们又回头看一些自己也的程序的话，有批注也更容易看的懂）为什么当时这段程序要这样写，以及当时写这段程序的前提是什么。

传统的Pascal程序批注，是以两个大括号、或者小括号带星号来标注某段文字为批注的，而近期版本的Object Pascal编程语言则是把C++的批注语法，也就是用两个斜线来标注其后的文字为批注，所以，以下的三种写法，都是目前的Pascal语言可以辨识的批注写法：

```pascal
// 从左边出现了两个斜线以后，到本行的末端都会被视为批注
{ 这里面的跨行文字都是批注 }
(* 这是另一种
多行文字批注的写法 *)
```

第一种批注的写法在目前流行的编程语言里面几乎都通用，但它并不是Pascal语言里面一开始就支持的，这语法是从C/C++语言借来的，C/C++语言也使用/* 批注文字 */ 来标注多行文字，这已经在C#, Objective-C, Java 跟JavaScript 里面都通用了。

第二种写法比第三种更普及，这个写法在欧洲最常见，因为大多数欧洲语系的键盘并没有小括号(或者小括号并不容易输入，需要多键组合才打的出来)。换句话说，最古老的语法有点过时了。

单行批注的语法很有用，常用来写短短的批注，或者把特定一行源码先暂时标注掉，这个语法也渐渐的成为在Object Pascal最常被使用的批注语法。

!!! note "笔记"
    在 IDE 的编辑器里面，您可以按下 Ctrl+/这组快捷键，来把单一一行源码，或者选择多行源码进行批注或者解除批注，这组快捷键在英文键盘里面可以直接使用，但如果是其他语系的键盘或输入法，就要先确定一下/这个符号的位置，实际的按键，可以从编辑器的功能选单(按鼠标右键就会显示了)来清楚的看到。

我们介绍了三种不同语法的批注文字，这些语法可以帮助我们把单行或者多行的源码先变成批注文字。如果您希望把源码或程序档案里面的部份文字变成批注，则您可以套用前述三种语法的不同排列来达成批注文字当中还有其他批注文字这种设定，但多行批注如果要包含其他批注的话，两个批注文字的语法不能用同一种喔：

```pascal
{ code.
    {comment, 这段批注底下的其他文字会不被当成批注喔}
code. }
```

上面这段源码会被编译器当成错误语法，因为第一个大括号在第二行遇到了结束的大括号，因此第三行已经不会再被视为批注文字，所以编译器就会判定语法有错，我们可以把它改写如下:

```pascal
{ code.
    // this comment is OK
code. }
```

这样的写法，由于两种批注语法不互相冲突，所以我们如果要把整段文字或源码的批注状态取消，就只要把前后两个大括号拿掉就行了，第二行还是可以保持批注文字的状态。

!!! note "笔记"
    在大括号之后如果出现一个钱字号$，就不再代表是批注，而是编译器的设定代码，例如在我们介绍的第一个范例程序当中，源码里面有一行写着{$APPTYPE CONSOLE}。编译器设定代码会让编译器去执行特定的一些动作，我们在本章后段加以介绍。
    
    其实，编译器设定代码说到底也算是批注，例如{$X+ 这是一个批注}这样写也不会造成语法错误，这种写法同时扮演两个角色，不过大多数的程序人员都还是会把编译器跟批注给分开来写就是了。

### 批注和 XML ⽂件

批注当中有一个特别的种类，对其他编程语言也是通用的规则，这种特别的批注出现时，编译器会有特别的处理方法。这些特别的批注，会直接被 IDE建立额外的文件到 IDE 协助功能中，编译器也会依此建立XML说明文件。

!!! note "笔记"
    在 IDE 当中，协助功能会自动显示关于识别符号的相关信息(包含该识别符号的型别，以及它是在哪里被宣告的)。透过 XML 文件批注，我们可以对特定的识别符号写一些需要注意的信息，或者关于它的细节，而这些说明文件是可以直接写在原始码里面的喔

XML说明文件可以透过设别的批注符号`///`或者 `{!` 来启用。在这些批注中，我们可以用一般文字或者特定的XML卷标(用卷标更好)来对要加入批注的源码或者识别符号指派特定的信息，例如该识别符号所需的参数、回传值等等。以下我们用一般文字来做个简单的例子:

```pascal
Public
  /// 这是一个自定方法
  procedure CustomMethod;
```

如果我们启用了XML文件产生功能，上面的源码会被编译器转译成底下的格式:

```pascal
<procedure name=”CustomMethod” visibility=”public”>
  <devnotes>
    这是一个自定方法
  </devnotes>
</procedure>
```

而这些信息在我们使用IDE的时候，当鼠标光标移动到该识别符号(CustomMethod)的时候，就会显示出来，如图1.4所示：

图 1.4: Delphi IDE 的帮助功能显示出以 /// 批注符号加入的 XML 说明信息：


如果我们在批注当中依照指引的建议，加入了 summary 区块，就会直接显示IDE的帮助窗口:

```pascal
Public
  /// <summary> 这是一个自定方法 </summary>
  procedure CustomMethod;
```

这么做的优点，是还有许多其他的XML标签，可以让我们用来说明参数、回传值以及其他更细节的信息，相关的卷标说明，请参考这个网址:

```url
http://docwiiki.embarcadero.com/RADStudio/en/XML_Documentation_Comments
```

### 识别符号(Symbolic Identifiers)

一个程序是由许多个不同的识别符号所构成的，我们会用这些识别符号来为不同的程序区段命名（例如数据型别、变量、函数、对象、类别等等）即使我们可以几乎可以使用我们想用的任何一个识别符号，仍然需要遵守一些规则：

+ 识别符号不能包含空格符（空格符会用以区分不同的识别符号）
+ 识别符号可以包含英文字母与数字，包含字符与所有Unicode的文字，所以我们已经完全可以用任何一种语言的文字（当然用中文也行）来做为识别符号的名称了。(有些时候也不建议这么做，例如IDE里面的工具部分，有可能并不完全支持)
+ 在传统的ASCII符号之外，识别符号只能包含底线(_)，其他的ASCII符号则不可以用在识别符号上，不可以使用的符号，包含有+, -, *, /, = 以及所有标点符号跟括号、特殊字符(像是@ # $ % ˆ & \ | )，我们只能用Unicode的字符，例如 ☼ ♪ 或 ∞ 都可以。
+ 识别符号必须用底线或字符来开头，不可以用数字开头（所以数字当然可以当成识别符号的一部分，只是不能当成第一个字）我们在这里提到的数字是指0-9的阿拉伯数字，至于Unicode里面的其他语言数字，例如国字的一或壹，甚至是全型的０或１则都没有问题

以下是很常见的一些识别符号命名方法，我把他们列在名为IdentifiersTest的范例程序中：

```pascal
MyValue
Value1
My_Value
_Value
Val123
_
```

以下则是一些合法的Unicode识别符号

```pascal
Cantù (拉丁文)
结 (简体中文)
画像 (日文汉字)
☼ (Unicode 里面的太阳符号)
```

接下来我们也介绍一些不合法的识别符号：

```pascal
123 (数字开头)
 1Value (数字开头)
 My Value (内含空格符)
 My-Value (内含特殊符号)
 My%Value (内含特殊符号)
```

!!! tip "提示"
    如果您在程序执行状态中想要检查识别符号是否合法(需要这样做的情境很少发生，除非您撰写的是帮助其他开发者的工具)，在运行时间函数库(Runtime Library)当中有提供这样的一个函数，名为 IsValidIdent。

### 大小写视为相同与使用大写字母

跟许多其他的编程语言不同，许多以C语言为基础的编程语言(像C++, Java, C#, 跟 JavaScript)都是把英文字母大小写视为相异，英文称为Case-Sensitive，Object Pascal是把英文字母大小写视为相同的，英文称为Case-Insensitive。

因此，对Object Pascal的编译器来说，Myname, MyName, myname, myName, 以及MYNAME这五个大小写各有不同的字符串，编译器会把他们全部当做完全一样的字符串。在我个人的观点中，把英文字母大小写视为相同，绝对是正面的功能，因为这样一来，因为拼字错误或者打字一时打错而造成语法错误的机会，会比其他语言发生的机会来的低。

如果我们把Unicode当成识别符号的情况也采计进来，事情就会变得更为复杂了，当我们把大小写视为相同时，只有一个字母大小写相异的关键词就会被视为完全相同，因此也就可以避免在语意上完全相同而只有大小写拼法不同的情形发生了。

```pascal
cantu: Integer;
Cantu: Integer; // 错误: 因为与前一个名称重复
cantù: Integer; // 正确: 这是完全不同的名称了
```

!!! warning "警示"
    在 Object Pascal 的大小写视为相同的规则中，只有一个情形例外，就是组件函数库套件(component package)的 Register 函数，这个函数一定必须写成第一个字母大写的 Register, 因为必须兼容于 C++。

    当然，当我们在引入由其他语言制作的函数库时，也必须随着该函数库制作时所使用的字符大小写，才能正确的调用、使用这些函数库。

在字母大小写的规则当中还是有一些问题的，所以我们首先要意识到不同大小写的识别符号实际上是完全相同的，所以一定要避免在不同的地方使用相同的识别符号，其次，我们也要适当的使用大写字母，让我们的源码更容易被阅读。

编译器并没有强制我们要在项目当中使用持续的规则，但使用持续的规则真的是个好习惯。通常大家会很习惯把第一个字母大写，当我们要用连续几个英文字作为识别符号的命名时，通常会让每个有意义的英文字的第一个字母大写，例如：

```pascal
MyLongIdentifier
MyVeryLongAndAlmostStupidIdentifier
```

这样的习惯通常被称为Pascal-casing, 相对于Java以及其他以C语言语法为基础的编程语言所使用的Camel-casing：第一个英文字的首个字母小写，其他的英文前缀个字母均大写：

```pascal
myLongIdentifier
```

实际上，目前也越来越常在Object Pascal的程序里面看到Camel-casing的规则了，目前仅剩Class宣告、参数宣告以及其他全局变量的范畴内还会使用Pascal-casing，在本书中，还是会尽量在所有的识别符号中都使用Pascal-casing的规则的。


### 使用空格符

空格符、tab跟换行符号在源码里面，几乎是完全被编译器所忽略掉的。这三个字符对于编译器来说都被当成空格符。空格符只用来让源码在阅读上更为舒服，在编译作业上完全没有作用。

跟传统的BASIC不同，Object Pascal允许我们把一个程序叙述句（statement）用很多行的源码来表达。允许用多行源码来表达一个程序叙述句的缺点，是我们自己必须记得在叙述句的最后加上一个分号，让编译器知道这是一个程序叙述句的完结点。Object Pascal的多行叙述句的唯一限制，是不能把字符串用多行来表示。

以下这几段程序虽然看起来奇怪，但他们都描述了同一件事情：

```pascal
a := b + 10;
a := b
+ 10;
a :=
// 在源码当中夹一行批注, 也是可以的
b + 10;
```

再次强调，在源码里面使用空格符跟换行符号并没有一定的规则，但有几个常用的写法：

+ 编辑器画面通常在每行达到80个字符之后，就会切行，如果你的源码超过了这个长度，就会被推到下一行去，这是为了让你的源码看起来更容易阅读，因为这样就不用横向卷动，在比较小的屏幕上也能够很快的把源码阅读完毕。原本每行80个字符的用意，只是让源码打印出来的时候比较好看，而近年来也很少看到源码打印的需求
了。

+ 当函数或程序有多个复杂的参数时，我们通常会让每个参数用单独一行来表示。

+ 我们也可在批注前后留下一行空白行，这样可以让我们的程序读起来更清楚易懂。

+ 记得在调用函数的时候，在每个参数之间加入一个空白，甚至是在不需要参数时，也在括号当中留一个空格符，我也会在表达式里面，让每个运算符号前后多放一个空白，看起来好读多了。


### 源码内缩

关于空格符使用上的最后一个建议，是跟典型的Pascal语言格式相关的议题，原本是为了让打印出来的源码比较美观，但目前已经都统整为源码内缩来呈现了。

!!! tip "提示"
    源码内缩的规则通常是依照个人习惯的主观想法，我不想挑起『用 Tab 或空格符哪个比较好』的战争。我在这里介绍的只是 Object Pascal 世界里面”最常用”或者”标准”的源码格式。在 Pascal 世界的历史中，比较常被称为pretty-printing，这个词目前已经不常见了。

这个规则非常简单：每当我们需要写一段复合的程序叙述句，就把整段源码内缩两个字符（不是tab字符，tab字符是C语言的开发人员常用的），如果这段源码当中还有其他复合的程序叙述，则该段源码再多内缩两个字符，依此类推：

```pascal
if ... then
  statement;
if ... then
begin
  statement1;
  statement2;
end;
if ... then
begin
  if ... then
    statement1;
    statement2;
end;
```

重申一次，不同的程序人员在这个常用的规则上会有自己惯用的作法，有些程序人员会把begin到end之间的源码内缩，而有些程序人员则会把begin这个关键词放在前一段源码的最后（C语言大多都是这样做，译者也是习惯如此），这是因为个人习惯而有些许不同而已。

相似的规则也常用在变量列表跟数据型别的定义上，就是在下面这段范例源码当中 type 跟 var 保留字后面的源码：

```pascal
type
  Letters = ('A', 'B', 'C');
  AnotherType = ...
var
  Name: string;
  I: Integer;
```

!!! tip "提示"
    在上面的源码中，您可能会觉得奇怪，为何 string 跟 Integer 这两个不同的型别要用在起始字符一个大写一个小写。在原始的 Object Pascal 格式指引中有提到『型别，例如 Integer 属于识别符号(identifier)时，第一个字符建议大写，但用保留字(reserved word)例如 string 宣告变量时，建议全部小写。』

在以往的作法，常常会在type宣告新的型别名称时，让所有的等号都放在同一个位置对齐，以及让变量宣告时的冒号都对齐起来，但现在已经很少见了，上述的源码如果用以往的规则来编排，就会变成：

```pascal
type
  Letters = ('A', 'B', 'C');
  AnotherType = ...
var
  Name : string;
  I : Integer;
```

内缩的排列也常用在跨行的程序叙述句上面，通常第二行以后的源码，就会被内缩，而函数的参数如果长过一行，也会被用内缩的方式来显示：

```pascal
MessageDlg ('This is a message',
  mtInformation, [mbOk], 0);
```

### 强化语法标示

为了让Object Pascal的程序更容易被阅读与编写，IDE的编辑器具备了一个名为强化语法标示的功能。根据我们所缮打的源码语法跟关键词，这些源码会被以不同的颜色跟字体加以标注。默认设定中，关键词会以粗体显示、字符串跟批注会以不同的颜色显示（而且通常会是斜体）等等规则。

保留字、批注跟字符串这三个类型的程序元素绝对是这个功能中对程序人员帮助最大的，透过这个功能，我们可以一眼看出源码是不是拼错字了？字符串是不是少打了一个引号？以及跨行的批注有没有把前后批注的标示符号正确的标示上去。

您可以很容易的透过Editor Colors这个设定来设定您自己喜欢的语法标示设定，如果您的开发工作只有自己需要看这些源码，则您可以直接设定，如果您需要跟其他程序开发人员一起工作，则请您还是先使用标准的颜色布景吧，我自己也发现一旦习惯了特定的布景颜色以后，一下看到其他颜色跟样式的画面的确很容易楞住一下，不知所措。


### 错误检知和源码检知

IDE编辑器有许多功能可以协助我们写出正确的源码，最直觉的应该就是错误检知这个功能了，当我们输入了错误的语法时，编辑器画面上就会立刻在第一个发生错误那一行标上一串红色的书名号，让我们知道编译器无法辨识该段源码，目前已经连文本编辑器跟文书软件也都有相同的功能了。

!!! note "笔记"
    在您第一次试着撰写 Object Pascal 程序的时候，请务必记得也要先把适当的 unit 引入，这样可以避免您的程序档案最上方被标注许多的错误，正确的引入其他的 unit, 可以解决掉不少错误标示。这个议题已经在 Delphi 10.4 当中透过新的语言服务器协议基础(LSD based, Language Server Protocol based)被明确的强调了。

其他功能，例如源码自动完成，会协助您显示当时我们输入的可能程序描述句，它会列出许多符合我们输入的函数名称或者属性名称，我们只要用下拉选单选择我们适用的function即可。又或者是一个函数的参数，也会被以下拉式选单的方式呈现。又或者我们可以按着Ctrl按键，用鼠标左键点选某一个源码里面的文字，就可以直接跳到该变量/型别被宣告的地方了。接下来我们就不再赘述关于IDE编辑器的功能了。我们还是把主要篇幅用来介绍Object Pascal语言本身吧。

## 编程语⾔的关键词

这里所指的关键词，就是由编程语言特别保留下来的识别符号。这些符号都是在编程语言里面已经预先赋予了功能，所以我们在整个程序的任何部分都不能拿来当成我们自己写的程序的符号（例如变量名、Class名等）。而基本上，指示词（directives）跟关键词是有所不同的:关键词是不能拿来当做变量、类别名称等标识符的，但指示词只要不被放在{$}这个符号组合中，就没有影响，所以指示词可以有其他的用途，但实务上，建议还是不要拿任何关键词（包含指示词）来做为标识符比较好。

如果您写了以下这样的源码（property这个字是关键词喔）：

```pascal
var
 property: string
```

编译器就会给您这样的错误讯息：

```text
E2029 Identifier expected but 'PROPERTY' found
```

警告您使用了关键词作为标识符，这是不被允许的。通常当您误用到关键词的时候，您会在编辑器或者编译器的时候得到错误讯息，当然用到不同的关键词会有不同的错误讯息出现。当编译器发现到关键词出现了，而觉得这个关键词出现的位置不对，就会依照错误关键词出现的地点回报错误。

在这里，我不打算把完整的关键词列表列出来，仅列出我们在写程序的时候比较常用到的关键词，并把他们依照功能分组列出，即使如此，要完整的涵盖到这些关键词仍旧需要用掉好几个章节来说明。您可以参考官方参考文件，网址是:
http://docwiki.embarcadero.com/RADStudio/en/Fundamental_Syntactic_Elements_(Delphi)#Reserved_Words

!!! note "笔记"
    请注意，部分关键词会在不同的地方出现，在这里我谨列出最常见的部分，有些关键词可能会被列到两次。原因之一，是经过了这么多年以后，编译器的团队希望不要再导入新的关键词，以免旧有的程序反而失效了，所以他们把其中一些关键词再度回锅了。

那么，我们就开始关键词的旅程吧，这些关键词有一些可能在您过去写程序时或者在前面的章节当中有见过，他们就是构成整个应用程序项目的骨干：

|关键词|含义|
|-------|-------|
|program |标明应用程序项目的名称|
|library |标明函数库专案的名称|
|package |标明套件函数库专案的名称|
|unit |标明单元文件的名称，单元文件也就是源码的原始档|
|uses |指示当前这个单元文件会参考到哪些单元档案|
|interface |单元文件的区段，用来进行宣告|
|implementation |单元文件的区段，用来放置实作的源码|
|initialization |当程序启动时，要先被执行的源码区段|
|finalization |当程序结束前，最后要被执行的源码区段|
|begin |宣告一个源码区块的开始|
|end |宣告一个源码区块的结束|

另一组关键词则是跟一些基础数据型别的宣告与变量相关的，兹列出如下:

|关键词|含义|
|-------|-------|
|type |标明开始进入数据类型声明区段|
|var |标明开始进入变量宣告区段|
|const |标明开始进入常数宣告区段|
|set |定义一个集合变量|
|string |定义一个字符串变量，或者自定的字符串型别|
|array |定义一个数组型别|
|record |定义一个复合数据型别|
|integer |定义一个整数变量|
|Real,single,double |定义一个浮点数型态的变量|
|file|定义一个档案变量|
|record|定义一个复合数据类别

!!! note "笔记"
    在后面的章节中，我还会介绍更多 Object Pascal 的资料型别。

第三组关键词则是介绍 Object Pascal 编程语言的基础叙述句，例如条件判断式跟循环，也包含了函数(function)跟程序(Procedure):

|关键词|含义|
|-------|-------|
|if |标明一个条件判断式|
|then |将条件判断式与符合条件时执行的源码分隔的符号|
|else |标明条件判断式中，不符条件时要执行的源码|
|case |标明一个多重选项的条件判断式|
|of |把多重选项判断式的条件与各个选项分隔的符号|
|for |标明一个固定次数的循环开始|
|to |标明 for 循环将变量递增计算时的最终数值|
|downto |标明 for 循环将变量递减计算时的最终数值|
|in |标明在列举循环当中，用来表示要被列举的组合变量|
|while |标明一个条件化的循环开始|
|do |把 while 循环的条件式与要执行的源码做分隔的符号
|repeat |标明一个具终止条件的循环开始|
|until |标明repeat循环的终止条件|
|with |标明要针对特定的数据结构进行处理|
|function |标明一个会回传执行结果的子程序（名为函数）|
|procedure |标明一个不会回传执行结果的子程序（名为程序）|
|inline |要求编译器对函数或程序进行优化|
|overload |允许同名的函数或程序被重复使用（称为多载）|


以下则是跟类别、对象相关的关键词：

|关键词|含义|
|-------|-------|
|class |标明一个新的类别型别|
|object |用来标明一个就的类别型别（目前已不再使用）|
|abstract |标明一个抽象类，表示该类别还没有完全被定义|
|sealed |标明一个已封锁类别，该类别不能再被继承|
|interface |标明一个接口型别（这个关键词也在第一组当中出现过）|
|constructor |一个类别或对象的初始方法|
|destructor |一个类别或对象的清除方法|
|virtual |一个虚拟方法，在衍生类别中需要被实作出来|
|override |在衍生类别中，实作虚拟方法的关键词|
|inherited |直接调用、引用父类别的方法|
|private |宣告类别中不能被外界存取的属性、事件或方法|
|protected |宣告类别中有条件供外界存取的属性、事件或方法|
|public |宣告类别或记录中可以完全被外界存取的属性、事件或方法|
|published |宣告类别中特别为了用户建立的属性、事件或方法|
|strict |比private跟protected限制更为严格的类别区段|
|property |被对应到变量或方法的一个符号，称之为类别的属性|
|read |属性的数据源|
|write |属性的变更方法|
|nil| 表示空对象，在许多有指针类型的语言当中也都有乡对应的特别符号，在C里面称为NULL|

还有一小群跟例外处理(我们在第11章里面会介绍)有关的关键词：

|关键词|含义|
|-------|-------|
|try |标明例外处理区块开始|
|finally |表示不管例外发生与否，都要被执行的区块|
|except |表示当例外发生时，要被执行的源码区块|
|raise |用来触发一个例外事件|

另外还有一小群关键词是用来作为运算用的，我们会在本章稍后的篇幅『算式与运算符』的部份介绍到（有一些进阶的运算符则会在后面的章节介绍）：

||||
|-------|-------|-------|
|as |and| div|
|is |in |mod|
|not|or |shl|
|shr|xor||

最后，我们列出一些比较不常用的关键词，包含一些不建议使用的旧的关键词。我们快速的看一下这些关键词的意涵，在后面的章节我们也会尽可能介绍：

|关键词|含义|
|-------|-------|
|default| 意指一个属性的默认值|
|dynamic |宣告虚拟方法的另一个被实现的源码|
|export |传统用来输出的关键词，已经被下一个关键词取代了|
|exports |在 DLL 项目中，列出要输入让其他程序使用的函数|
|external |指向我们要绑定的外部DLL中的函数名称|
|file |用来定义传统的 file 型别，这个型别近年来已经很少用到了|
|forward |表示一个函数预先宣告，实际的宣告在后面的源码才会完整出现|
|goto |让源码跳到程序中另一个标注的位置继续执行，强烈建议绝对不要使用这个功能。|
|index |用在当需要引入或者输出函数时，标明当中有索引的属性(现在已经很少用了)|
|label |定义一个特别的程序位置，让goto指令能直接跳到此一位置继续执行，强烈建议绝对不要使用这个功能|。
|message| 虚拟函数的替代关键词，和不同平台的讯息相关|
|Name |用以对应外部函数|
|nodefault |表示该属性没有默认值|
|on |用来触发例外状况|
|out |var关键词的替代字，是用来表示一个引用参数(call by reference)，但没有被进行过初始化|
|packed |改变记录(record)或者数据结构在内存中的排列|
|reintroduce| 允许重复使用一个虚拟函数的名称|
|requires |在制作套件时，用来宣告所需要的其他套件名称|

请注意，近几年来Object Pascal的关键词已经很少有新增的了，因为任何新增的关键词都有可能会使得已存在的源码在使用新版的编译器进行编译时，导致旧有的程序发生编译错误，因为谁也不敢保证程序人员一定不会用到什么英文字。Object Pascal最近新增的功能都不需要透过关键词来达成，例如泛型（generics）与匿名方法（anonymous methods）。

## 程序结构

您可能曾经把所有的源码写在同一个档案里面，就像本章的第一个简单的文本模式应用程序一样。而当我们越常开发图形接口程序，就越有机会在项目档之外使用到第二个原始码档案。这『第二个档案』就被称为单元文件，通常它的扩展名会是PAS（Pascal 原始档的意思），项目档的扩展名则会用DPR(Delphi项目档的意思)，这两种档案都会内含有Object Pascal的原始码。Object Pascal透过了单元文件或者程序模块的使用提供了延伸性。事实上，单元文件就提供了模块化以及数据封装的功能，即使没有使用到对象，实际上已经也被注记为命名空间 (namespace)了。Object Pascal的应用程序通常都是由好几个单元文件所建立的，包含用来储存画面与数据模块的单元文件。事实上，当我们加入一个可视化的画面窗体到项目里面，IDE就会帮我们加入一个单元文件，这个单元文件正是对应所加入的可视化画面的源码。

单元文件无需定义画面窗体，两者之间会自动被关联起来，两者之间的类别、属性、方法、事件处理程序，都已经被自动连结好，无需我们额外做什么处理了。如果您要加入一个新的空白单元文件到项目里面，这个空白单元文件只需要几个简单的关键词来宣告几个必要的区段即可，如下所示：

```pascal
unit Unit1;
interface
implementation
end.
```

单元文件的结构极其简单，就像上面的范例一样：

+ 首先，单元文件要有一个整个项目不能重复的名字为之命名，同时也当作主档名（所以上面这个例子存档时，档名就会是Unit1.pas）

+ 其次，单元文件一定要有一个interface区段，用来宣告让其他单元文件可以使用、存取的资料。

+ 第三，单元文件要有implementation区段，用来实作这个单元文件里面真正的源码，这里的源码也可以比interface区段所宣告得来的更多，只是在interface区段没有宣告的，就只有同一个单元文件的其他源码可以使用，不管是方法或属性都一样。


### 单元与程序名称

如同我提过的，单元的名称必须跟单元文件的文件名一致，程序名也一样，要为单元重新命名的话，我们应该使用Project Manager里面的重新命名功能，此时更名前后的单元使用在项目中都会保持同步，档案也会维持只有一份改名后的档案 (使用IDE里面的另存新文件功能，会在磁盘里面存在新旧两个单元档案了)。当然您也可以直接从档案总管把档案直接改名，但是如果改名后，您没有到单元文件里面把第一行的单元名称也一起做修改的话，在编译器的时候，就会看到一个错误发生（或者只在加载项目的时候，IDE就会告诉你有错误了），以下的讯息就是当我们只改了档名，却没有同步修改单元名称时会发生的错误：

`[DCC Error] E1038 Unit identifier 'Unit3' does not match file name`

这表示单元名称也必须符合Pascal识别符号规则，以及文件系统的命名规则，例如像我们前面提到过的，不能包含空格符、不能有特殊符号（除了底线）。只要我们使用了符合规范的名称来为单元命名，就会自动被储存为合法的文件名，所以这一点我们不用太过担心。当然凡事都有例外，就是Unicode的符号，有些符号并不是文件系统允许我们拿来作为档名的，就别故意挑战文件系统了。

### 用.来为单元命名

单元名的规则还有一个延伸的规则，就是单元名可以包含. 所以以下列出的单元名称也都是合法的：
 
```pascal
 unit1
 myproject.unit1
 mycompany.myproject.unit1
```
依照这个常见的规则，这些单元需要也被储存为相同的档名，用.包含在檔名之中(例如假设有一个单元名为MyProject.Unit1，这个单元就要存放在MyProject.Unit1.pas档案之中了)

这个延伸规则的由来，是因为单元名称必须是唯一的，而随着Embarcadero跟第三方开发商所提供的单元文件越来越多，单元文件的名称就变复杂了，所以目前随着Delphi开发工具所预载提供的RTL单元以及各种不同功能的单元文件，都可以看到有许多用.来构成单元名称的情形，例如：

|||
|-------|--------|
|System| 代表核心RTL的单元|
|Data |代表数据库存取与相关的单元|
|FMX |代表FireMonkey平台与跨装置组件的单元|
|VCL |代表Windows平台视觉组件库的单元|


!!! note "笔记"
    您经常都会在单元文件的全名里面使用到名称里面有.的单元，或者函数库的单元文件。不过也可以只在程序的参考单元当中使用到整个单元名称的最后部分（这也是为了让旧版的程序能够兼容新版的编译器），您只需要设定项目选项中的对应项目即可，这个设定选项的名称是”Unit scopenames”，它是一个以分号做项目区隔的列表。不过请注意，使用这个功能相对的会让编译的速度比使用完整单元名称的时候变慢许多。


### 更多关于单元文件的结构

除了 interface 跟 implementation 这两个区段之外，每个单元还可以有initialization 跟 finalization 这两个非必要的区段。Initialization 是用来处理该单元被执行时最开始的源码，而 finalization 则是用来处理该单元在程序结束时要处理的源码。

!!! note "笔记"
    您也可以在类别的建构方法(constructor)当中加入 initialization 源码，Object Pascal 的许多最新功能在第 12 章会介绍到，使用类别的建构方法可以帮助链接程序移除非必要的源码，这也是为什么建议大家使用类别的建构方法跟解构方法(destructor)，而比较不建议使用 initialization 跟 finalization 区段的原因。在过去的历史中，initialization 区段还是需要依靠 begin 这个关键词来进行宣告的，begin 的类似用法仍然是项目源码的标准。

换句话说，单元的结构，包含了所有可能的区段与一些简单的元素，应该长得像下面这个范例源码：

```pascal
unit UnitName;
interface
// 其他我们在本单元会引入的单元名称，在 interface 这个区段中宣告
uses
 UnitA, UnitB, UnitC;
// 要公告周知的型别定义
type
 NewType = TypeDefinition;
// 要公告周知的常数
const
 Zero = 0;
// 全局变量
var
 Total: Integer;
// 要公告周知的函数与程序
procedure MyProc;
implementation
// 其他在 implementation 区段我们会引入的单元名称
uses
 UnitD, UnitE;
// 不对其它单元文件告知的全局变量
var
 PartialTotal: Integer;
// 所有被公告的函数都必须在此被实作
procedure MyProc; begin
// ... MyProc 这个程序的源码
end;
initialization
// 非必要的 initialization 区段的源码
finalization
// 非必要的 finalization 区段源码
end.
```

一个单元的 interface 区段存在的意义，是为了告知其它单元，这个单元包含什么，能为其它单元或项目提供什么。而 implementation 区段则包含了所有其它单元都无法得知的源码。这也是Object Pascal之所以可以提供信息封装，而不需要靠类别或对象就能达成该功能的原因。

我们可以发现，单元的 interface 区段可以宣告不少型别各异的元素，包含程序、函数、全局变量，以及数据型别。数据型别当然是最常出现在这个程序区段中的。IDE环境会自动放一段新的类别宣告，当我们建立一个新的可视化画面窗体，宣告窗体定义并不是Object Pascal当中包含单元这个功能的唯一理由。我们也可以在单元当中只有源码，只有函数与程序（就像传统 Pascal 程序的作法），甚至在单元里面有新的类别，但不用参考其它的窗体的或者可视化组件。

### Uses条文

Uses条文位于interface区段的开头部分，是用来标示我们在该单元中需要参考的其它单元名称。是标明我们在这个单元当中，为了定义数据型别时，需要参考的其它单元，而参考的程序也限于那些单元的数据型别，例如我们在画面窗体当中定义的组件。

第二个uses条文是出现在implementation区段的开头，是标明我们只在源码实作阶段需要参考的单元文件。当您只需要参考其它单元的源码，例如子程序、方法，我们就得在implementation区段当中的uses来标明这些单元的名称，这个作法可以减少对档案的依赖度并减少编译所耗费的时间。在uses条文中被标明要参考的单元文件，都必须位于项目目录当中，或者IDE环境的搜寻路径当中，这样编译才不会出问题。


!!! tip "提示"
    我们可以在项目设定里面设定搜寻路径(Search Path)。系统在编译作业中也会参考 Library Path 里面的单元文件，这个设定是 IDE 的全局设定。

C++的程序人员们请注意，uses叙述跟C++的include叙述句并不对等，uses叙述句的效应只会把预先编译的单元的interface部分引入。Implementation区段的源码会在该单元实际被编译器处理的时候才被考虑，被引入的单元文件，可以以原始码的格式(PAS檔)或者编译过的二进制文件(DCU文件)的形式存在前述的目录或路径中。

虽然在Object Pascal当中并不常用到，但Object Pascal的编译器设定当中也有一个类似C/C++ include的编译器设定，名为$INCLUDE。然而跟内嵌在原始码不同，这些特别的引入档会被部分需要共享编译器设定的函数库或者在许多单元文件要共享其它设定的时候才被用到的，而且通常会使用INC这个特别的扩展名，这个编译器设定会在本章的最后介绍

!!! warning "警告"
    请注意，Object Pascal 的二进制编译文件(DCU)只会在使用相同版本的编译器与系统函数库时兼容。用旧版的编译器编译的二进制文件，通常无法与后来版本的编译器兼容，这一点不可不察。在同一个版本的更新套件一定会维持兼容性。换句话说，在 10.3.1 版里面的档案一定会跟 10.3.x 的所有版本兼容，举例来说，但就未必会跟 10.2 或 10.4 版的程序兼容了。在 Delphi 11 里面对版本的作法有了改变，在 11.x 的任何改版都会保持跟 11 的兼容性，但 12 版可能就会无法兼容。



### 单元与界限

在Object Pascal当中，单元正是数据封装与源码界限的关键，在这个规范下，单元能提供的源码界限甚至比类别中private或public关键词能提供的还更重要。一个标识符(例如变量、程序、函数或数据型别)的界限，是表示这个标识符能够被其它源码存取的范围，所以也被称为该标识符的可视范围。基本规则就是只有在该标识符的界限中，它才是有意义的，因此只有在这个单元当中的程序、函数才能使用这个标识符，我们无法在标识符的界限之外使用它。

!!! note "笔记"
    请注意，Object Pascal 跟 C、C++都不一样，Object Pascal 在一般源码区块里面不允许变量、常数的宣告。当我们已经进入了 begin-end 的源码区块范围之后，在这里面就不能够再宣告任何变量了

通常一个标识符只有在它被定义之后才能使用。但在Object Pascal当中，也有方法在一个标识符被完整定义之前先进行宣告，但我们在完整考虑了定义与宣告的规则后，应该可以发现其实他还是遵循着Object Pascal的基本规范的。

假设把整个程序的源码写在单一一个档案里面是有意义的，那么，这个规则会怎么修正好让我们在使用多个单元文件的时候能够遵循呢？简单的说，当我们透过uses条文把其它单元引入的时候，在被引入的单元中，interface区块所宣告的所有标识符也在新的单元文件里面变成可以被存取的了。

反之，如果在interface区段宣告了一个标识符（可能是型别、函数、类别、变量等等），所有引用现在建立的这个单元的其它所有源码也都可以看到这个刚宣告的标识符了。但如果是在implementation区段中宣告这个标识符的话，则这个标识符就只能在自己这个单元文件中被看见，其余引用这个单元的源码都无法看见了，我们可以把它理解成区域标识符，就像局部变量那样。

### 把单元文件当成命名空间来使用

我们已经看过了uses叙述句，它是让单元文件能够看见其它引入的单元文件相关标识符的标准技术。这时您可以存取这个单元中的所有定义，但有时在两个单元文件里面可能宣告了相同的标识符，例如您可能有两个类别，或者两个子程序使用了完全相同的名字。

在这种情形下，我们可以简单的把单元名称前置在这个被重复使用的标识符之前。举个例子来说，您可以引入在Calc这个单元当中名为ComputeTotal的程序，这时我们可以把它写成Calc.ComputeTotal，IDE不常要求我们一定要这么写，但当我们在两个不同单元中有相同的标识符时，这样写可以避免重复，以及让编译器不会误解。

然而如果您曾经深入看过系统或第三方组件的程序，您应该会发现许多函数跟类别的名称重复，最常见的例子就是在不同平台的可视化组件中，常常有相同命名的组件，当您深入看到TForm或TControl的源码时，里面有很多类别或函数会依据您所引入的单元来决定要执行哪一个函数。

如果使用了相同名称的两个单元，正好都被您的单元文件引入了，最后被引入的那个单元会抢到该名称的使用权，编译器也就会把该名称直接对应到最后被引入的单元文件的标识符去，如果您无法避免这种情形的话，请一定在重复标识符名称的前面加入该单元文件的完整名字，这样编译器就不会弄错了。

!!! note "笔记"
    Delphi 开发人员因为有名为 interposer classes 的技术，而享有让两个类别使用相同名称的方便性，关于这个技术，本书后面的章节会加以介绍。

### 程序档案


我们在前面的篇幅已经看过了，Delphi的应用程序文件会包含两种源码档案：一个是会出现多次的单元文件，而另外一个是只会出现一次的程序文件，或者我们也可以叫它项目档。单元文件可以看成是第二层的档案，所有单元文件都会被扮演主要阶层角色的项目档所引入。

理论上这是对的，在实务上，项目档通常是自动产生出来的档案，而且有其被局限的角色。项目文件只用来启动这个应用程序、通常会建立、执行主要的画面窗体（如果应用程序是可视化应用程序时）。项目档的内容也可以手动编辑，但是当我们修改项目设定的时候，这个档案的内容就会被自动修改（就跟应用程序当中的其它对象跟画面窗体一样）

项目文件的结构通常比其他单元档案来的简单，以下就是一个简单的项目档，这个内容会是由IDE帮我们自动产生：

```pascal
program Project1;
uses
 FMX.Forms,
 Unit1 in ‘Unit1.PAS’ {Form1};
begin
 Application.Initialize;
 Application.CreateForm (TForm1, Form1);
 Application.Run;
end.
```

从上面的源码我们可以看到，它只有一个简单的uses区段，以及透过begin-end标明的应用程序主要源码，这个程序的uses叙述句非常重要，因为它们会被用来进行编译、链接成应用程序执行文件。

!!! tip "提示"
    在项目文件里面的单元列表对应了在 IDE 当中项目管理员画面的单元列表，当我们在 IDE 里面加入一个单元到这个项目里面的时候，这个单元的名称也会自动被加入到这个项目档的 uses 区段里面。当然，如果我们从 IDE 里面删除了一个单元文件，项目文件的 uses 区段也会立即有反应。反之如果我们直接编辑项目档，从里面直接删除某个 uses 里面的单元文件，在 IDE 里面的设定画面也会同时立即有反应。



## 编译器设定

程序结构里面另一个特殊的部分（跟其他实际的源码相比），就是编译器设定了，我们稍早曾经提到过，这些特殊的指令是给编译器用的，会以以下的格式撰写：
`{$X+}`

有些编译器设定只是一个简单的字符，就像上面这个例子，用加号或减号来表示该设定是有效或者无效，大多数的设定会有一个长一点或者能够被判读的写法，使用ON与OFF来表示有效或者无效，而部分设定值则只有较长的写法，没有像上例这种简写。

编译器设定通常不是直接把源码编译成二进制，而是告诉编译器，这个设定值出现之后，要把编译器当中的部分设定进行调整以后再行编译之后的源码，大多数的时候，我们可以透过修改IDE当诸的项目设定值来调整这些设定，即使有些情况下，我们只需要对一个单元或一部分的源码进行编译器设定值的调整。

在后续的篇幅中，只要提到相关的编程语言功能，我也会介绍一下相关的编译器设定，在这个章节中，我只稍微介绍一些跟程序流程相关的编译器设定，例如条件化定义(Conditional Defines)与引入(includes)。

### 条件化定义(Conditional	Defines)

条件化定义让我们可以告诉编译器使用哪一部分的源码，或者忽略它。通常我们会在定义标识符或者引入单元的时候用到这个功能。在Delphi中有两种类型的条件化定义语法，传统的$IFDEF, $IFNDEF与新型较有弹性的语法 $IF

这些条件化定义可以透过定义的识别符号或者在 $IF 的写法中用常数值的定义来区分。定义的识别符号可能是系统预先定义的(像是编译器或是平台定义的识别符号)，也可能是定义在特定项目当中的设定选项，或者在源码当中以其他编译器定义值($DEFINE)宣告的。

传统的 $IFDEF 跟 $IFNDEF 写法格式如下:

```pascal
{$DEFINE TEST} ...
{$IFDEF TEST}
// 这部份的源码会被编译
{$ENDIF}
{$IFNDEF TEST}
// 这部份的源码不会被编译
{$ENDIF}
```

我们可以加上$ELSE把一个条件的两种情形做出区隔。

刚刚提到的，使用$IF这个语法是比较有弹性的作法，这个新的语法可以让我们使用到在源码当中的变量或者判断式(举例来说，检查编译器的版本是否高于特定值)。$IF的语法必须以 $IFEND 结尾：

```pascal
{$IF (ProgramVersion > 2.0) }
 … // 如果条件成立，这段程序会被执行
{$ELSE}
 … // 如果条件不成立，则执行这个程序区块
{$IFEND}
```

如果有多个条件的话，也可以加入 $ELSEIF 语法。

### 编译器版本(Compiler	Versions)

每个版本的Delphi编译器都有一个特别的定义值，我们可以依此进行判断，检查我们的程序是否能使用特定版本的编译器。这有赖我们使用了后面介绍的一些功能，但希望在编译时先检查一下编译器是否能够处理这些功能的源码。

如果我们需要最近几版的Delphi来处理特定的源码，我们可以在$IFDEF后面判断以下的版本代号：

Delphi 2007 VER180
Delphi XE VER220
Delphi XE2 VER230
Delphi XE4 VER250
Delphi XE5 VER260
Delphi XE6 VER270
Delphi XE7 VER280
Delphi XE8 VER290
Delphi 10 Seattle VER 300
Delphi 10.1 Berlin VER 310
Delphi 10.2 Tokyo VER 320
Delphi 10.3 Rio VER 330
Delphi 10.4 Sydney VER 340
Delphi 11 Alexandria VER 350

后面的数字是该版的编译器版本代号（例如26就是Delphi XE5），这个号码并不会只局限在Delphi，可以回推到第一版由Borland所推出的Turbo Pascal编译器(请参考附录A)。

我们也可以在$IF判断式里面使用这些内部的代号常数，这样我们就可以直接用>=来判断编译器是否符合特定版本的需求，版本的常数名称是CompilerVersion，在Delphi XE5里面，这个常数是一个浮点数，数值是26.0，所以范例如下：

```pascal
{$IF CompilerVersion >= 26}}
 // 需要 Delphi XE5 或更新的版本编译器才能编译的源码
{$IFEND}
```

举一反三，我们也可以使用一些系统常数，例如用来判断是哪个操作系统平台，万一我们需要使用到该平台特定的程序功能：

Windows系统（32或64位都一样） MSWINDOWS
Mac OS X MACOS
iOS IOS
Android Android
Linux LINUX

以下是简单的程序片段，使用了上述的操作系统定义，它们是HelloPlatform范例的部份程序：

```pascal
{$IFDEF IOS}
 ShowMessage ('Running on iOS');
{$ENDIF}
{$IFDEF ANDROID}
 ShowMessage ('Running on Android');
{$ENDIF}
```

### 引入檔 (Include	Files)

我在此想介绍的另一个编译器设定指令，是$INCLUDE这个指令，我们在前面介绍uses的时候已经提到过了，这个指令让我们可以参照、引入特定程序档案中的一部分源码，通常这个用法会被用来在不同的档案中引入相同的源码，例如某段源码定义了一些编译器设定，而我们在使用一个单元时，只需要引入一部分的源码，当我们引入一个档案时，该档案所引入的所有单元都会一起被编译（这就是为什么我们应该避免在引入档里面加入新的识别符号的原因）

换句话说，我们应该不要在引入文件里面加入任何程序相关的元素与定义（这跟C语言的例子正好相反），相关的程序元素与定义都应该在单元文件里面来处理，所以我们到底该如何使用引入档呢？好的例子是在引入档里面写入一些我们希望在大多数的单元文件中都要用到的编译器设定，或者特殊的额外定义。

大型函数库通常会使用引入档来达成前述的目的，例如FireDAC函数库，这是已经成为系统默认函数库之一的用来处理数据库相关的函数库，另一个例子则是系统的运行时间函数库(RunTime Library, 又简写成RTL)也在各个操作系统中使用了独立的引入文件，而在编译器中会随着我们所选择的作业平台单独套用该平台的设定。
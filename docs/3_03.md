基本上，强型别的编译器，静态型别语言，例如 Pascal，在执行时期提供的可用型别信息很少，甚至没有。所有关于数据型别的信息只有在编译过程中可以被看的到。

Object Pascal 的第一版就打破了这个传统，它提供了属性与其他类别成员的执行时期信息，只需透过一个特别的区段宣告关键词:published。这个类别功能只要在编译器时有加上{$M+}这个编译设定即可，它同时也是 VCL 的DFM 档案串流化机制的基础(FireMonkey 函数库的 FMX 档案也是使用此一机制)，在窗体与其他可视化组件的设计环境也是使用此一机制。

在 Delphi 第一版推出的时候，这功能算是整个程序设计工具业界最创新的想法，后来许多程序开发工具也都用了各种不同的方法提供这个功能，并把这个功能加以延伸。

首先，在型别系统中有延伸功能来为方法进行注记跟检测(此功能仅有Object Pascal 语言提供)，以及在 COM 面动态进行调用。在 Object Pascal里面这功能仍然以 dispatch ID 进行支持，在方法中使用变异变量(Variant)以及其他跟 COM 相关的功能。最后，在 Object Pascal 里面对 COM 的支持已经由编程语言内建的动态时期型别信息来外延支持了，但这已经超过本书作为介绍编程语言功能的书该涵盖的范围了。

后来系统管理环境的出现，像是 Java 跟.NET，提出了一个很有延伸形式的执行时期型别信息(Run Time Type Information，以后简称 RTTI)，透过由编译器把详细的 RTTI 跟执行模块进行绑定，程序中就可以对这些模块检测与使用了。这有让内部源码跟模块的大小增加的副作用，但它也透过新的程序模块，以及结合动态编程语言的一些弹性到固定结构、增加强型别速度的优点。

不管你喜欢与否(在该功能被加入的时候，的确引发了激烈的争论)，Object Pascal 已经慢慢朝向相同的方向前进，并且提供 RTTI 的延伸功能，使这个方向的发展越发明显了。正如我们看到的，我们可以选择不用 RTTI，但如果我们使用 RTTI，则可以在应用程序中整合更多的功能进去。


这个主题并不简单，所以我们会一步一步介绍。

+ 首先我们会先介绍新的延伸 RTTI，这功能已经内建在编译器，我们可以透过使用 RTTI 单元文件来使用里面的新功能与类别。
+ 其次，我们应该也要留意到新的 TValue 结构跟动态调用的技术。
+ 第三，我会介绍自定标注，这个功能在.NET 上也有提供，并且可以让我们可以延伸由编译器产生的 RTTI 信息。

我们会在本章的最后部分来探讨在延伸的 RTTI 背后的理由，以及看一些使用 RTTI 使用的实际案例。


## 延伸的 RTTI

Object Pascal 编译器默认就会建立许多延伸的 RTTI 信息。执行时期信息包含所有型别、包含类别与所有其他使用者定义的型别，都会像是系统提供的核心数据型别一样提供相同层级的数据，并包含到私有区、保护区、公开区、发布区的所有元素。这需要深入到任何一个对象的所有内部结构。


### 第一个范例

在我们开始看到编译器产生的信息以及几种不同存取这些信息的技术之前，我们先直接跳去看结论，并看一下使用 RTTI 可以达到什么功能吧。具体的例子并不多，而且可能是以旧版的 RTTI 写成的，但这些例子可以让您理解我所要介绍的想法(也要考虑到并不是所有的 Object Pascal 开发人员都使用传统的 RTTI 来开发)。

假设我们有一个窗体上头放了一个按钮，就像 RttiIntro 范例项目。我们可以用以下这段源码来读取控制组件的 Text 属性:

```pascal
uses Rtti;
procedure TFormRttiIntro.btnInfoClick(Sender: TObject);
var
 Context: TRttiContext;
begin
 Show (Context.
 GetType(TButton).
 GetProperty(Text).
 GetValue(Sender).ToString);
end;
```

这段源码使用了 TRttiContext 记录来参考 TButton 型别的信息，从这个型别的信息到 RTTI 关于属性的数据，以及这个属性的数据被用来参考到属性的内容值，它被转型成为了一个字符串。

如果您好奇这是怎么运作的，请继续读下去。在这里我的重点是，这种方法现在不只可以用来动态的存取属性，也可以读取数据字段的内容，包含私有区的字段。

我们还可以改变一个属性的值，就像 RttiIntro 范例项目中第二个按钮的动作一样：

```pascal
procedure TFormRttiIntro.btnChangeClick(Sender: TObject);
var
 context: TRttiContext;
 AProp: TRttiProperty;
begin
 AProp := Context.GetType(TButton).GetProperty(‘Text');
 AProp.SetValue(btnChange, StringOfChar ( '*', random (10) + 1));
end;
```

这段源码以随机长度的＊符号来取代 Text 的内容。跟以上的源码的不同点是它用了暂存的局部变量来参考属性的 RTTI 信息。现在，您该对于我们要介绍的想法有些轮廓了，我们先从检查由编译器建立的延伸 RTTI 信息开始。


### 编译器产生的信息

我们不用特别作什么，编译器就会把这些额外信息加入到我们的执行档(不论它的形式为何: 应用程序、函数库、套件等)。就开启一个项目，然后编译它。编译器默认就会为所有数据字段(包含私有区的字段)以及公开区、发布区的所有方法与属性建立延伸 RTTI。您可能会觉得惊讶，RTTI 居然也涵盖到私有区，但这是由于动态处理的需求，像是二进制对象的串行化以及对在 heap 内存区的对象进行追踪。

我们可以用以下列表的设定值来控制延伸 RTTI 的建立:X 轴代表成员的种类，Y 轴代表不同访问权限区。以下的列表是系统默认值:


||数据字段|方法|属性|
|----|----|----|----|
|私有区| X|||
|保护区| X|||
|公开区| X| X |X|
|发布区| X| X |X|

技术上来说，这四个访问权限设定是使用以下宣告在 System 单元文件的集合型别来进行对应的:

```pascal
type
 TVisibilityClasses = set of (vcPrivate,
 vcProtected, vcPublic, vcPublished);
```

系统中提供了一些预先定义好的常数值，可以和预设的 RTTI 内容对应，这些访问权限的可视范围是跟 TObject 的可视设定关连，所有的类别也都继承了这些相同的权限：

```pascal
const
 DefaultMethodRttiVisibility = [vcPublic, vcPublished];
 DefaultFieldRttiVisibility = [vcPrivate..vcPublished];
 DefaultPropertyRttiVisibility = [vcPublic, vcPublished];
```

编译器是否要建立这些信息，可以用一个新的编译器设定来处理：$RTTI，这当中包含了一个状态，用来指示特定型别或它的衍生类别(明确指示或是继承)，并以三个特定的关键词来标明方法、数据字段或者属性的可视状态。在 System 单元文件中的默认值是:

```pascal
{$RTTI INHERIT
 METHODS(DefaultMethodRttiVisibility)
 FIELDS(DefaultFieldRttiVisibility)
 PROPERTIES(DefaultPropertyRttiVisibility)}
```

要完整的关闭为所有类别的成员建立延伸 RTTI 的话，我们可以使用以下的设定:


`{$RTTI EXPLICIT METHODS([]) FIELDS([]) PROPERTIES([])}`

!!! note "笔记"
    我们无法在单元文件的宣告之前设定 RTTI 的设定值，就跟其他编译器设定值一样，因为这些设定值的定义是在 System 单元文件里面宣告的。如果我们在单元文件最前面(uses 区段之前)就写好编译器设定值的话，就会出现内部错误，这看起来不太直觉。总之，就把它放在单元的指令之后吧。


使用这个设定的时候，要记得它只会被套用在我们自己写的源码，而且不可能完全移除，因为用于 RTL 跟其他函数库的类别的 RTTI 信息已经被编译到对应的 DCU 档案跟套件档案里面了。

同时也要记得，$RTTI 设定对于为已发布的型别所建立的传统 RTTI 的建立不会有任何影响：它还是会建立，跟是否设定$RTTI 无关。

!!! note "笔记"
    RTTI 处理类别，是透过 RTTI 单元文件，我们稍后的章节会加以介绍，它是透过挂载在传统 RTTI 跟它的 PTypeInfo 结构来达成的。

我们可以透过这个设定值来停止为我们自定的类别建立延伸 RTTI。相对的，我们也可以增加 RTTI 要建立的范围，包含私有区、保护区的方法跟属性，只要有需求的话(虽然建立这些信息不一定都有实质用处)。

把延伸 RTTI 加到执行档，最明显的影响就是执行档的档案变大了(大的档案在进行散布的时候绝对算是一个缺点，因为额外的加载时间跟所使用的内存对于程序执行来说并不很相关)。如果我们决定不在源码里面使用 RTTI的话，可以把 RTTI 从我们的源码当中的单元文件移除，重新编译后，就可以看出两者之间的差距了(如果我们决定不要使用 RTTI 这个技术的话)。RTTI 是个很强大的技术，从本章的介绍中就可以感觉的到，或者在大多数的状况下，它也值得多用一些额外的空间。

### 强型别与弱型别连结

我们还有什么方法可以让执行档的 Size 变小一点吗? 有的，虽然影响不大，但绝对值得我们注意。

当我们可以从执行档案里面取得 RTTI 信息，要注意到编译器加进去的信息，有时候链接程序会这些信息给移除掉。预设情形下，没有被编译到执行档的类别跟方法就不会建立延伸 RTTI(因为在此一情形下，这些信息建了也没用)，因为也无法取得基础的 RTTI。

另一种情况下，如果我们想要让所有的延伸 RTTI 都被建立，并可以被使用，我们就需要把这些几乎没有用到的类别跟方法进行连结。

我们可以使用两个编译器设定值来控制与执行文件链接的信息。第一个是$WeakLinkRTTI 设定值，它在文件里面有完整的叙述。设定这个值，在程序里面没有被使用到的型别以及该型别所属的 RTTI 都会被从执行档当中移除。

或者我们也可以强制把所有型别，以及这些型别的延伸 RTTI 透过$StrongLinkTypes 这个编译器设定值包进执行档里面。对很多程序来说，这个效果可是很戏剧化的，不过执行档的大小也大概会多出一倍来。


## RTTI 单元⽂件

如果为所有型别建立延伸 RTTI 是 Object Pascal 镜射功能的第一根柱子，第二根柱子是能够用简单、高阶的方式来浏览这些型别的能力(多亏了System.Rtti 单元文件)，第三根柱子我们待会会介绍，就是对于自定标注的支持，我们一个个来看吧。

传统的 Object Pascal 程序可以(现在还是可以喔)使用 TypeInfo 单元文件里面的函数来存取类别『发布区』的执行时期型别信息。这个单元文件定义了一些低阶的数据结构跟函数(都是以指针跟记录为基础)，并定义了一些高阶的子程序来简化程序的运作。

不同的是，Rtti 单元文件则让使用延伸 RTTI 变得很容易，当中提供了一整组的类别，包含了适当的方法跟属性。要存取不同的对象，进入点都是TRttiContext 记录结构，当中有四个方法用来搜寻可用的型别:

```pascal
function GetType (ATypeInfo: Pointer): TRttiType; overload;
function GetType (AClass: TClass): TRttiType; overload;
function GetTypes: TArray<TRttiType>;
function FindType (const AQualifiedName: string): TRttiType;
```

正如我们可以看到的，我们可以传递一个类别，以一个从型别所取得的PTypeInfo 指标，一个完整的名称(包含从该类别被宣告的单元文件开始到型别的完整名称，像是”System.TObject”)，或者取得型别的完整列表，被定义成一个 RTTI 型别的数组，或者更精确的说，是定义成 TArray<TRttiType>。我在以下的列表当中也有使用到最后的函数，是 TypesList 范例项目的版本简化:

```pascal
procedure TFormTypesList.btnTypesListClick(Sender: TObject);
var
 AContext: TRttiContext;
 TheTypes: TArray<TRttiType>;

 AType: TRttiType;
begin
 TheTypes := AContext.GetTypes;
 for AType in TheTypes do
 if AType.IsInstance then
 Show(AType.QualifiedName);
end;
```

GetTypes 方法回传了数据型别的完整列表，但程序会过滤掉内容，只留下型别所表示的相关类别而已。在这个单元文件里面大概有十几个类别所表示的型别。

_____________________________________________________________________
!!! note "笔记"
    RTTI 单元文件是把类别型别当成”实体”或者”实体型别”(就像在TRttiInstanceType 里面)。这听起来有点容易混淆，就像我们平常把实际的对象称为实体一样。

在型别列表里面的独立对象是属于从 TRttiType 衍生而来的一些类别。我们可以特别来看一下 TRttiInstanceType 类别型别，把上面的源码重写成以下的程序片段:

```pascal
for AType in TheTypes do
 if AType is TRttiInstanceType then
 Show(AType.QualifiedName);
```

这个范例的源码有些复杂，它会先建立一个字符串列表，把里面的元素进行排序，然后建立一个 ListView 组件，使用 BeginUpdate 跟 EndUpdate 来进行优化(并且会用一个 try finally 区块把这些源码包起来，确定最后的动作一定会被执行到)：

```pascal
var
 AContext: TRttiContext;
 TheTypes: TArray<TRttiType>;
 SList: TStringList;
 AType: TRttiType;
 STypeName: string;
begin
 ListView1.ClearItems;
 SList := TStringList.Create;
 try
 TheTypes := AContext.GetTypes;
 for AType in TheTypes do
 if AType.IsInstance then
 SList.Add(AType.QualifiedName);
 SList.Sort;
 ListView1.BeginUpdate;
 try
 for STypeName in SList do
 (ListView1.Items.Add).Text := STypeName;
 finally
 ListView1.EndUpdate;
 end;
 finally
 SList.Free;
 end;
end;
```

这段源码会建立一个数以百计的数据型别列表，实际的数字要看编译器的版本跟其使用的平台了，我们可以看一下图 16.1。当中从 RTTI 单元文件列出了影像列表型别，我们会在下一节里面加以介绍。

图 16.1: TypeList 范例项目的执行结果


### 在 Rtti 单元文件里面的 RTTI 类别

在以下的列表中，我们可以看到类别继承关系的完整图表，这些类别都是从 TRttiObject 衍生出来的，它们都定义在 Rtti 单元文件里面：

```pascal
TRttiObject //Abstract
 TRttiNamedObject
 TRttiType
 TRttiStructuredType // Abstract
 TRttiRecordType
 TRttiInstanceType
 TRttiInterfaceType
 TRttiOrdinalType
 TRttiEnumerationType
 TRttiInt64Type
 TRttiInvokableType
 TRttiMethodType
 TRttiProcedureType
 TRttiClassRefType
 TRttiEnumerationType
 TRttiSetType
 TRttiStringType
 TRttiAnsiStringType
 TRttiFloatType
 TRttiArrayType
 TRttiDynamicArrayType
 TRttiPointerType
 TRttiMember
 TRttiField
 TRttiProperty
 TRttiInstanceProperty
 TRttiIndexedProperty
 TRttiMethod
 TRttiParameter
 TRttiPackage
 TRttiManagedField
```

这 些 类 别 当中的 每 一个都 提 供 了 该 型 别 的 专 属 信 息 。 例 如 ， 只 有TRttiInterfaceType 提供了可以存取 GUID 的接口。

!!! note "笔记"
    在 Rtti 单元文件的第一次实作中，并没有 RTTI 对象可以存取被索引过的属性(像 TStringList 类别的 Strings[]那样)。这是后来的版本才加上去的，现在仍旧可以使用，也让运行时间型别信息得以真正的完整。


### RTTI 对象的生命周期管理以及 TRttiContext 记录

如果看过了刚刚列出的 BtnTypesListClick 方法的原始码，里头有些地方看起来应该是相当严重的错误。GetTypes 调用的函数回传了一个型别的数组，但那段程序并没有把内部的对象是放掉。原因是 TRttiContext 记录结构变成了所有被建立出来的 RTTI 对象的拥有者。当这个记录被释放(亦即程序执行脱离了该函数)，一个内部接口会明确的调用它自己的解构函数来是放掉被建立出来的所有 RTTI 对象。

TRttiContext 记录事实上扮演了两个角色。一方面它控制了 RTTI 对象的生命周期(我们刚刚介绍过)，另一方面它也对 RTTI 信息进行快取，因为每次对 RTTI 信息进行搜寻时所需要的重建程序是很昂贵的。这也是为什么我们会想要把 TRttiContext 记录的参考的生命周期做一个延伸，好让我们在存取RTTI 信息的时候可以不用重新建立它们(重申一下，这些步骤是很花时间的)。

内部作业里，TRttiContext 记录使用了 TRttiPool 型别的一个全局缓冲区，它使用了临界区(Critical section, 这个名词我很习惯直接用英文，所以用这个翻译字眼不知道恰不恰当)来保证多线程的作业安全。

!!! note "笔记"
    在 RTTI 的缓冲机制里面也会发生多线程同时存取的意外，相关的信息就直接被写在 Rtti 单元文件里面的批注文字。

所以，精确的说，RTTI 缓冲区是让所有的 TRttiContext 记录所共享的，因此被保留着的 RTTI 对象会一直被维持着，直到所有内存里面的TRttiContext 记录都被释放掉为止。让我引用一下该单元文件里面的批注:

```pascal
{... working with RTTI objects without at least one context being alive is an error. Keeping at least one 
context alive should keep the Pool variable valid}
```

{译文: 想要不透过至少一个 context 来让 RTTI 运作，是会出错的。保持最少一个 context 存在可以让 Pool变量能够被正常使用}

总而言之，我们必须避免在释放了 RTTI 内容之后还快取住，或是继续使用RTTI 对象。以下是会导致内存违规存取的简单范例源码(它也是节录自TypesList 范例项目):

```pascal
function GetThisType (AClass: TClass): TRttiType;
var
 AContext: TRttiContext;
begin
 Result := AContext.GetType(aClass);
end;
procedure TFormTypesList.Button1Click(Sender: TObject);
var
 AType: TRttiType;
begin
 AType := GetThisType (TForm);
 Show (AType.QualifiedName);
end;
```

简单的做个整理，RTTI 对象是由内容所管理的，我们没办法让它随时保持可以使用的状态。这个内容是一个记录，所以会自动被编译器释放掉。我们可以看到一些源码是像这样来使用 TRttiContext 的:

```pascal
AContext := TRttiContext.Create;
try
 // use the context
finally
 AContext.Free;
end;
```

虚构的建构函数跟虚构的解构函数会设定内部的接口，这些内部接口则会管理实际在背景使用到的数据结构，并把它设定成 nil 来清除这些缓冲区。然而，这个动作会对于区域型别，像是记录自动执行，这个动作不用特别处理，除非我们用了指标来参照这些记录。

### 显示类别信息

我们在运行时间中最想要进行检查的相关型别，当然是结构化的型别，例如接口或记录。聚焦在这些实例上，我们可以参照这些类别之间的关系，透过以下可以用在实例型别上的 BaseType 信息。

存取型别当然是一个很有趣的开始，但相对的也是具备认识这些型别的内容的能力中相对比较新的，包含它们的成员。当我们点击这些型别中的任何一个(我们在范例中使用了 TPopup 组件类别)，程序就会显示一连串的属性、方法，以及该型别的数据字段，我们透过三个分页加以呈现，请见图16.2。

图 16.2: 在TypesList 范例项目中所显示的详细型别信息


第二个窗体的单元文件，可以用以延伸成为一个用在其他应用程序中通用的的型别浏览器，当中有一个名为 ShowTypeInformation 的方法，可以浏览特定型别当中的每一个属性、方法，以及数据字段，浏览的方式则是把它们加入到三个独立的列表，各自以不同的可视权限作为每个列表显示的内容(pri 会显示私有区，pro 会显示保护区，pub 则会显示公开区，pbl 则是显示发布区，这个显示的判别是写在 VisibilityToken 函数里面):

```pascal
procedure TFormTypeInfo.ShowTypeDetails(Typename: string);
var
 AContext: TRttiContext;
 AType: TRttiType;
 AProperty: TRttiProperty;
 AMethod: TRttiMethod;
 AField: TRttiField;
begin
 AType := aContext.FindType(typename);
 if not Assigned(AType) then
 Exit;
 LabelType.Text := AType.QualifiedName;
 for AProperty in Atype.GetProperties do
 FormTypeInfo.LVProperties.Items.Add.Text := AProperty.Name +
 ': ' + AProperty.PropertyType.Name + ' ' +
 VisibilityToken (AProperty.Visibility);
 for AMethod in Atype.GetMethods do
 LVMethods.Items.Add.Text := AMethod.Name + ' ' +
 VisibilityToken (AMethod.Visibility);
 for AField in AType.GetFields do
 LVFields.Items.Add.Text := AField.Name + ': ' +
 AField.FieldType.Name + ' ' +
 VisibilityToken (AField.Visibility);
end;
```

我们可以继续解析这些属性所属的型别，来找出更深入的信息，取得该方法的参数列表，并检测回传型别等等。这个范例并不是要建立出完整的RTTI 浏览器，只是要让我们知道，我们可以透过 RTTI 的功能获得哪些信息。


### 套件中的 RTTI

除了我们可以用来存取某个型别或者一系列型别的方法，TRttiContext 记录也提供了另外一个很有趣的方法”GetPackages”，这个方法可以回传目前应用程序有使用到的运行时间套件列表。如果我们在一个没有使用任何运行时间套件应用程序里面调用这个方法，回传值的内容就只会有目前的执行档而已。但如果我们在一个使用了许多运行时间套件的应用程序里面调用它，回传值的内容就会是这些套件的清单。从这个信息，我们就可以深入到每个套件里可以使用的型别。请留意到这个案例中，型别的清单可能会非常冗长，因为 RTL 跟视觉组件函数库当中没有被使用到的型别并不会被链接程序自动排除。

如果我们使用了运行时间套件，我们也可以取得每个套件当中所有型别的清单(也包含执行文件自己)，我们可以使用以下的源码:

```pascal
var
 AContext: TRttiContext;
 APackage: TRttiPackage;
 AType: TRttiType;
begin
 for APackage in AContext.GetPackages do
 begin
 ListBox1.Items.Add('PACKAGE ' + APackage.Name);
  for AType in APackage.GetTypes do
 if AType.IsInstance then
 begin
 ListBox1.Items.Add(' - ' + AType.QualifiedName);
 end;
 end;
```
!!! note "笔记"
    Object Pascal 的套件可以用来为开发环境加入视觉组件，就像我们在 11 章里面介绍过的。然而，套件也可以只在运行时间使用，把主要的执行档跟几个运行时间套件一起散发，不用把所有的源码组合成一个单一的执行档案。如果您对 Windows 开发还算熟悉，可以把套件想象成是 DLL 档案的角色(这些套件在技术上的确也是 DLL 档案)，或者我们也可以把它想成是.NET 的二进制文件。不过套件在 Windows 上面扮演了重要的角色，但在行动平台上却是不支持的(也是跟操作系统对应用程序的散发限制有关，例如 iOS 就不允许应用程序进行动态链接)。


### TValue 结构

新的延伸 RTTI 不只让我们可以对程序内部结构进行浏览，还提供了特定的信 息 ， 包含属 性 和 数 据 字 段 值 。 在 TypInfo 单 元 文 件 提 供 了 名 为GetPropValue 的函数可以存取一般的属性，并以当中的值存取其对应的变异型别，新的 Rtti 单元文件则使用了不同的结构来处理这一类没有特别定义型别的元素，这个结构称为 TValue 记录。

这个记录几乎可以储存 Object Pascal 里面所有的数据型别，并且可以追踪它的原始数据表示方式，它的作法则是同时记录数据与其数据型别。因此我们就可以对该变量指定的型别进行读写。如果我们把整数写进 TValue，我们读出的就只能是整数型别了，如果写进去的是字符串的话，读出来的也就会是字符串。(在 XE6 之后，FireMonkey 里面的 TGrid 就已经使用TValue 来设定每个 Cell 的内容，所以不像以往有分成 TStringGrid 等不同型别，TGrid 就涵盖了所有型别的 Grid)。

但 TValue 不能提供不同型别之间的格式转换，因此就算 TValue 有提供AsString 与 AsInteger 方法，我们也只能在 TValue 的内容的确是字符串时使用 AsString，而在 TValue 内容的确是整数的时候才能使用 AsInteger。举例来说，在以下的案例里，我们可以使用 AsInteger 方法，如果我们调用IsOrdinal 方法的话，回传值就会是 True:

```pascal
var
 V1: TValue;
begin
 V1 := 100;
 if V1.IsOrdinal then
 Log (IntToStr (V1.AsInteger));
```

然而，我们不能使用 AsString 方法，强制使用的话，会导致一个 invalid typecast 例外:

```pascal
var
 V1: TValue;
begin
 V1 := 100;
 Log (V1.AsString);
```

不过，如果我们需要使用字符串来表示 TValue 的内容，则可以用 ToString方法，这个方法里面有一个 case 判别逻辑，可以把大多数数据型别的内容转换成字符串：

```pascal
var
 V1: TValue;
begin
 V1 := 100;
 Log (V1.ToString);
```

我们可以阅读以下 Barry Kelly 所写的这段文字，增进对 RTTI 的了解，Barry是前 Embarcadero 研发人员，他的工作主要就是 RTTI：

> TValue 是个型别，可以用来存取以 RTTI 为基础的方法，并且读写相关的数据字段与属性。

> 这个型别跟变异型别(Variant)类似，但其工作原理更偏向 Object Pascal 的型别系统。举例来说，实体可以被直接储存，像是集合(set)、类别参考等等。它也是更具局限性的型别，并且不会(例如)在背景进行字符串对数字的转换。

现在我们对 TValue 的角色应该有更深一层的理解了，让我们来看一下TValue 记录的实际能耐吧。它具备一组高阶的方法，可以指派、解析出实际的内容，也包含一组低阶的以指标为基础的方法。我们接下来会集中篇幅在高阶方法上。

在指派内容时，TValue 定义了许多个 Implict 运算方法，让我们可以直接在源码里面把特定的值指派给 TValue 型别的变数：

```pascal
class operator Implicit(const Value: string): TValue;
class operator Implicit(Value: Integer): TValue;
class operator Implicit(Value: Extended): TValue;
class operator Implicit(Value: Int64): TValue;
class operator Implicit(Value: TObject): TValue;
class operator Implicit(Value: TClass): TValue;
class operator Implicit(Value: Boolean): TValue;
```

这些运算方法所做的，就只是调用泛型类别方法 From 而已:

`class function From<T>(const Value: T): TValue; static;`

当我们调用这些类别函数的时候，我们需要确定数据型别，并传递一个该型别的数据过去，像是以下的源码，会透过上述的这些类别方法，把整数值 100 进行指派:

`V1 := TValue.From<Integer>(100);`

这是一系列的统一技术，用来把所有型别的数据搬移到 TValue 型别的变数里去。一旦资料被指派完成，我们就可以用以下的几个方法来检测该数据的实际型别了:

```pascal
property Kind: TTypeKind read GetTypeKind;
function IsObject: Boolean;
function IsClass: Boolean;
function IsOrdinal: Boolean;
function IsType<T>: Boolean; overload;
function IsArray: Boolean;
```

请注意这里面的 IsType 泛型方法，几乎可以用在任何数据型别上。对于解析出来的数据，也有对应的方法，但我们只能对 TValue 里面储存的数据使用型别兼容的方法，因为当中并不会有任何转换的动作发生：

```pascal
function AsObject: TObject;
function AsClass: TClass;
function AsOrdinal: Int64;
function AsType<T>: T;
function AsInteger: Integer;
function AsBoolean: Boolean;
function AsExtended: Extended;
function AsInt64: Int64;
function AsInterface: IInterface;
function AsString: string;
function AsVariant: Variant;
function AsCurrency: Currency;
```

这些方法大多会同时有 Try 的版本，会在执行时，如果发现型别不兼容时回传 False，而不会触发例外事件。当中也有一些限制转换的方法，最相关的是泛型函数 Cast 与 ToString 函数，我已经在范例中使用过它们了:

```pascal
function Cast<T>: TValue; overload;
function ToString: string;
```

### 以 TValue 读取一个属性

TValue 的重要性，来自于这个结构会在存取属性或数据字段时，使用延伸的 RTTI 与 Rtti 单元文件。作为使用 TValue 的实际范例，我们可以用这个记录型别来存取 TButton 对象发布区的属性与私有区的数据字段，请参考以下的代码段(节录自 RttiAccess 范例项目):

```pascal
var
 Context: TRttiContext;
 AType: TRttiType;
 AProperty: TRttiProperty;
 AValue: TValue;
 AField: TRttiField;
begin
 AType := Context.GetType(TButton);
 AProperty := AType.GetProperty('Text');
 AValue := AProperty.GetValue(Sender);
 Show (AValue.AsString);
 AField := AType.GetField('FDesignInfo');
 AValue := AField.GetValue(Sender);
 Show (AValue.AsInteger.ToString);
end;
```

### 调用方法

新的延伸 RTTI 并不只让我们存取值与数据字段，它也让我们对于调用方法有了更简化的方式。在这个例子中，我们必须为该方法的每个参数都定义一个 TValue 元素。我们在调用这样的方法时，有个全局的函数叫做 Invoke的可以使用:

```pascal
function Invoke(CodeAddress: Pointer; const Args: TArray<TValue>;
 CallingConvention: TCallConv; AResultType: PTypeInfo): TValue;
```

作为更好的替代方案，在 TRttiMethod 类别中就定义了一个简化版的 Invoke多载版本：

`function Invoke(Instance: TObject; const Args: array of TValue): TValue; overload;`

我们在以下的范例中，提供了两个方式来调用使用简化版的方法(一个回传一个值，第二个则要求一个参数)，这些源码都是从 RttiAccess 范例项目里面节录出来的:

```pascal
var
 Context: TRttiContext;
 AType: TRttiType;
 AMethod: TRttiMethod;
 TheValues: array of TValue;
 AValue: TValue;
begin
 AType := Context.GetType(TButton);
 AMethod := AType.GetMethod('ToString');
 TheValues := [];
 AValue := AMethod.Invoke(Sender, TheValues);
 Show(AValue.AsString);
 AType := Context.GetType(TForm1);
 AMethod := AType.GetMethod('Show');
 SetLength (TheValues, 1);
TheValues[0] := AValue;
 AMethod.Invoke(self, TheValues);
end;
```

## 使用标注 (Using	Attributes)

本章的第一个部分，是让我们能够对 Object Pascal 编译器建立的延伸 RTTI能够有比较多的掌握，并透过介绍新的 Rtti 单元文件，能多认识 Rtti 的存取能力。第二部分，我们终于要来介绍整个架构的关键之一:定义自定标注，以及透过特定方法来延伸编译器所建立的 RTTI 的可能性。我们接下来会从比较抽象的观点来看这个技术，然后说明这个技术对 Object Pascal 的重要性与其原因，而且我们会透过实例来看。

### 标注是什么？

标注，用 Object Pascal 或 C#的术语来说叫标注，用 Java 的习惯来看叫批注，是我们可以在源代码里面加入的说明或指示，我们可以把它加入到型别、数据字段、方法、或者属性(Property)，编译器会把它跟产出的执行二进制源码包在一起。这是通常用方括号进行的指示:

```pascal
type
 [MyAttribute]
 TMyClass = class
 ...
```

在开发环境中以工具读取这些信息，或者在最后的应用程序从运行时间中读取这些信息，程序可以依照找到的信息来变更其规则。

通常标注不是用来改变类别或对象的实际核心功能，而是让这些类别能够在参与运作时能够有延伸特定功能的机制。把一个类别宣告为可串行化(serializable)，并不会影响到类别的任何功能，但会让串行化功能的源码得知这个类别需要被串行化处理，以及该如何处理(在这个例子里面，我们需要透过标注来提供更多信息，或者在类别的数据字段或属性中建立更进一步的标注)。

这完全就是受限版的 RTTI 一开始被 Object Pascal 内部使用的方式。被标示为发布区的属性(Property)，可以被显示在开发工具的对象查看器当中，也可以被串行化写成一个 DFM 档案，同时也可以在运行时间被存取。标注(Attribute)开启了这个机制，使它更有弹性、也更为强大。目前使用上很复杂，也很容易就误用，就像其他目前也很强大的编程语言功能一样。这个功能的存在，并不意味着要放弃原本我们已经理解的面向对象程序设计的优点，而是期望能从这些新的想法中跟原来的技术达到互补的效果。

举例来说，『员工』这个类别仍旧是从原有的架构上，一定还是从个人的类别中所衍生出来的，『员工』这个对象还是会对该对象需要提供一个标识符的字段，但我们可以”标注”这个『员工』类别需要跟数据库的特定数据表进行对应，或者跟特定的运行时间窗体进行对应。所以我们可以透过继承(是特定类别)、拥有关系(属于)，以及标注(标示为)作为三种独立的机制，我们可以在设计应用程序的时候，这三种机制都可以是需求来用上。

当我们看过 Object Pascal 里面由编译器功能支持的自定标注，并看了几个案例以后，我刚介绍过的抽象想法应该就会变得比较容易懂了，至少这是我的希望。


### 标注类别与标注宣告

我们要如何定义一个新的标注类别(或者标注分类)呢?我们必须从 System单元文件里面的一个新类别: TCustomAttribute 类别来衍生出新的类别：

```pascal
type
 SimpleAttribute = class(TCustomAttribute)
 end;
```

我们为标注类别取的名字会变成在源码里面使用的标识符，我们可以选择把标注加在后面作为延伸。所以如果我们为类别命名为 SimpleAttribute，我们可以在源码里面用 Simple 或者 SimpleAttribute 来使用这个类别。因此Object Pascal 里面不成文的规定，为每个类别都以 T 开头来命名的这个规定 ， 通 常 在使用 标 注 的 时 候 ，就不使用了，主 要 的 例 外 会 是System.TCustomAttriute。

```pascal
type
 [Simple]
 TMyClass = class(TObject)
 public
 [Simple]
 procedure One;
```

在上例中，我使用了 Simple 这个标注加在整个类别跟一个方法上面。除了名字，标注也支持一个或一个以上的参数。传递给标注的参数必须跟该标注类别的建构函数声明相同，如果该标注类别有建构函数的话:

```pascal
type
 ValueAttribute = class(TCustomAttribute)
 private
 FValue: Integer;
 public
 constructor Create(N: Integer);
 property Value: Integer read FValue;
 end;
```

以下是把标注应用在一个参数的做法:

```pascal
type
 [Value(22)]
 TMyClass = class(TObject)
 public
 [Value(0)]
 procedure Two;
```

要被传递给该类别的标注的值，必须是一个常数或表达式，因为常数或表达式的内容在编译阶段就可以被解译出来了。这也是只有少数的数据型别:有序内容、字符串、集合，以及类别参考可以使用的原因。从正面来看，我们可以用不同的参数来建立多种覆写版本的建构函数。注意一下，我们可以把许多个标注只在同一个标识符上面，就像在 RttiAtrrib 范例项目里面所做的，我们整理一下在这一节里面的代码段:

```pascal
type
 [Simple][Value(22)]
 TMyClass = class(TObject)
 public
 [Simple]
 procedure One;
 [Value(0)]
 procedure Two;
 end;
```

要是我们试着使用一个还没有定义的标注呢(可能是因为在 uses 区段使用了别的单元文件所致)，我们就会得到下面这个错误讯息了:

```pascal
[DCC Warning] RttiAttribMainForm.pas(44): W1025
 Unsupported language feature: 'custom attribute'
```

事实上这个讯息只是说该标注会被忽略掉，所以我们得要留意到类似的警告讯息里面，就像我们在其他情况下处理警告讯息一样，或者要更注意到是不是有”Unsupported language feature”这样的警告讯息出现，因为这个讯息已经跟错误没有两样了(我们可以在项目设定的画面中，Hint and Warning设定页来调整要把这个情形看待成错误或是警告讯息):

```pascal
[DCC Error] RttiAttribMainForm.pas(38):
 E1025 Unsupported language feature: 'custom attribute
```

最后，跟其他类似的概念的实作方式做个比较，在标注的使用上目前机会没有方法可以限制使用的范围，像是在宣告区段，标注可以用在型别上，但不能用在方法上。然而在编辑器上面，标注在使用更名重购(rename refactoring)的功能上几乎是完全可以使用，没有任何限制的。我们不只可以更改标注类别的名字，系统还会自动在该标注被使用在完整的名字，以及没有使用最终完整标注的地方帮我们补正。

!!! note "笔记"
    标注的重购，最初是由 Malcolm Groves 在他的部落格上所提出的: http://www.malcolmgroves.com/blog/?p=554。

### 浏览标注

现在如果没有方法可以找到哪些标注是有被定义过的，这些源码看起来就完全没有用了，而且可能因为这些标注，在对象当中注入不同的规则或行为。我们先来介绍第一部分吧。在 Rtti 单元中的类别，让我们可以厘清哪些标识符有相关的标注。

以下的源码是从 RttiAttrib 范例项目中节录出来的，可以显示出跟目前的类别有关连的标注清单：

```pascal
procedure TMyClass.One;
var
 Context: TRttiContext;
 Attributes: TArray<TCustomAttribute>;
 Attrib: TCustomAttribute;
begin
 Attributes := context.GetType(ClassType).GetAttributes;
 for Attrib in Attributes do
 Form39.Log(Attrib.ClassName);
```

执行这个程序，输出结果如下：

```
SimpleAttribute
ValueAttribute
```

我们可以在源码的 for-in 循环里面做些修改，来解析出特定的标注型别：

```pascal
if attrib is ValueAttribute then
 Form39.Show (' -' + IntToStr(ValueAttribute(attrib).Value));
```

要怎么得到透过特定的标注取得方法，或任何标注来取得?我们无法直接过滤方法，但可以一一取得这些方法，检查其标注，然后看看是不是我们要找的方法。为了协助这个作业，我已经写了这样的一个函数来检查每个方法是不是支持特定的标注：

```pascal
type
 TCustomAttributeClass = class of TCustomAttribute;
function HasAttribute (AMethod: TRttiMethod;
 AttribClass: TCustomAttributeClass): Boolean;
var
 Attributes: TArray<TCustomAttribute>;
 Attrib: TCustomAttribute;
begin
 Result := False;
 Attributes := aMethod.GetAttributes;
 for Attrib in attributes do
 if attrib.InheritsFrom (attribClass) then
 Exit (True);
end;
```

HasAttribute 这个函数会被 RttiAttrib 程序用来检查特定的标注:

```pascal
var
 Context: TRttiContext;
 AType: TRttiType;
 AMethod: TRttiMethod;
begin
 AType := Context.GetType(TMyClass);
 for AMethod in AType.GetMethods do
 if HasAttribute (AMethod, SimpleAttribute) then
 Show (AMethod.name);
 for AMethod in AType.GetMethods do
 if HasAttribute (AMethod, TCustomAttribute) then
 Show (AMethod.name);
```

这效果是列出特定标注的方法：

```
Methods marked with [Simple] attribute
One
Methods marked with any attribute
One
Two
```

我们一般所做的并不是简单的描述标注，而是对特定的标注类别加上一些独立的行为，跟它原本的源码不同。举个实例，我们可以在上面的源码里面注入特定行为: 目标是调用有特定标注类别的所有方法，先考虑它们都是不需要参数的方法:

```pascal
procedure TForm39.BtnInvokeIfZeroClick(Sender: TObject);
var
 Context: TRttiContext;
 AType: TRttiType;
 AMethod: TRttiMethod;
 ATarget: TMyClass;
 ZeroParams: array of TValue;
begin
 ATarget := TMyClass.Create;
 try
 AType := Context.GetType(ATarget.ClassType);
 for AMethod in AType.GetMethods do
 if HasAttribute (AMethod, SimpleAttribute) then
 AMethod.Invoke(ATarget, zeroParams);
 finally
 ATarget.Free;
 end;
end;
```

这个程序片段所做的动作包含了建立一个对象、抓出该对象的型别，检测特定的标注，最后调用每个有标注为 Simple 的方法。这跟从类别继承、实作接口、或者写一些特定的源码来行使这个要求都不同，要取得新的动作，我们只需要以特定的标注来为一个或多个方法进行加注。这并不式说这个例子使得标注的使用异常明显: 我们可以在本章的最后参照一些常见的使用标注的模式，和一些实际的个案研究。


## 虚拟⽅法拦截器

!!! warning "提示"
    这一节介绍的是 Object Pascal 当中非常高阶的功能，如果您目前才刚开始学习 Delphi 语言，您可能会想要先跳过它。这一节是为了对 Delphi 已经很专精的读者而写的。

有另一个相关的功能在延伸 RTTI 被加入 Object Pascal 之后也被加入了，这个功能是对一个现存的类别可以透过虚拟方法来加以拦截的能力，只要对现存的对象建立一个代理类别。换句话说，我们可以选一个已经存在的对象，然后修改它的虚拟方法(可以一次只修改其中一个，或一次把全部都处理掉)。

我们要怎么完成这一点?在标准的 Object Pascal 应用程序中，我们应该没办法使用这个功能。如果我们需要让一个对象拥有不同的行为，就只能先衍生一个子类别，然后在子类别里面修改源码来达成。而在函数库里面则是完全不同的，因为函数库必须用很通用的方式来撰写，对对象的了解不多，函数库可以操作，并且尽可能的降低对对象的负担。这就是在 Object Pascal里面加入虚拟方法拦截器的情境。

!!! note "笔记"
    我们可以从一则部落格的发文看到对于虚拟方法拦截器(这部份我是比较欠缺的): http://blog.barrkel.com/2010/09/virtual-method-interception.html。

在我们聚焦在可能的情境之前，我们先讨论技术本身吧。假设我们有一个已经存在的类别，它带有至少一个虚拟方法，像下面的例子这样:

```pascal
type
 TPerson = class
 ...
 public
 property Name: string read FName write SetName;
 property BirthDate: TDate read FBirthDate write SetBirthDate;
 function Age: Integer; virtual; function ToString: string; override;
 end;
function TPerson.Age: Integer;
begin
 Result := YearsBetween (Date, FBirthDate);
end;
function TPerson.ToString: string;
begin
 Result := FName + ' is ' + IntToStr (Age) + ' years old';
end;
```


假设我们在这个类别里有一个叫 FPerson1 的对象。现在，我们可以做的就是建立一个TVirtualMethodInterceptor对象(它是定义在Rtti单元文件里面的一个新类别)把它跟我们想要制作的新类别(TPerson)绑定起来，成为一个子类别的对象，把 FPerson1 对象的固定类别变成动态类别:

```pascal
var
 FVmi: TVirtualMethodInterceptor;
begin
 FVmi := TVirtualMethodInterceptor.Create(TPerson);
 FVmi.Proxify(FPerson1);
```

一旦我们有了 FVmi 对象，我们就可以用匿名方法，来为它安装处理程序到特定的事件上(onBefore, onAfter, 以及 onException)。这些匿名方法会在任何虚拟方法被调用前、被调用之后，以及万一在任何虚拟方法触发了意外的时候被驱动。以下是这三个匿名方法的特征：

```pascal
TInterceptBeforeNotify = reference to procedure( Instance: TObject; Method: TRttiMethod;
 const Args: TArray<TValue>; out DoInvoke: Boolean; out Result: TValue);
TInterceptAfterNotify = reference to procedure( Instance: TObject; Method: TRttiMethod;
 const Args: TArray<TValue>; var Result: TValue);
TInterceptExceptionNotify = reference to procedure( Instance: TObject; Method: TRttiMethod;
 const Args: TArray<TValue>; out RaiseException: Boolean; TheException: Exception;
 out Result: TValue);
```

在每个事件中，我们可以取得该对象，该方法的参考，参数，以及回传值(有时也可能没有回传值)。在 OnBefore 事件中，我们可以设定 DoInvoke 参数让标准的执行动作失效。在 OnExcept 事件中，我们可以取得意外事件的详细信息。

在 InterceptBaseClass 范例中，范例中使用了上面的 TPerson 类别，我拦截了类别的虚拟方法，加入了以下的纪录源码:

```pascal
procedure TFormIntercept.BtnInterceptClick(Sender: TObject);
begin
 FVmi := TVirtualMethodInterceptor.Create(TPerson);
 FVmi.OnBefore := procedure(Instance: TObject; Method: TRttiMethod;
  const Args: TArray<TValue>; out DoInvoke: Boolean;
 out Result: TValue)
 begin
 Show('Before calling ' + Method.Name);
 end;
 FVmi.OnAfter := procedure(Instance: TObject; Method: TRttiMethod;
 const Args: TArray<TValue>; var Result: TValue)
 begin
 Show('After calling ' + Method.Name);
 end;
 FVmi.Proxify(FPerson1);
end;
```

注意到，FVmi 对象需要被维持到 FPerson1 对象被使用结束为止，不然我们就会使用一个动态类别，而该类别已经不能用了，最后我们就会调用到一个已经被释放掉的匿名方法。在范例中，我把它存放在一个窗体的数据字段中，就跟对象会参考到的数据(FPerson1)一样。


这个程序会透过调用它的方法以及检测基础类别的名称来使用对象:

```pascal
Show ('Age: ' + IntToStr (FPerson1.Age));
Show ('Person: ' + FPerson1.ToString);
Show ('Class: ' + FPerson1.ClassName);
Show ('Base Class: ' + FPerson1.ClassParent.ClassName);
```

在我们安装拦截器之前，输出结果是:

```
Age: 26
Person: Mark is 26 years old
Class: TPerson
Base Class: TObject
```

安装了拦截器之后，输出结果变成了:

```
Before calling Age
After calling Age
Age: 26
Before calling ToString
Before calling Age
After calling Age
After calling ToString
Person: Mark is 26 years old
Class: TPerson
Base Class: TPerson
```

请注意这个类别跟基础类别的名称完全一样，但事实上却是完全不同的两个类别，它是用虚拟方法拦截器所制作的动态类别。

纵使并没有官方的作法可以把目标对象的类别恢复成原始的类别，该类别本身仍旧可以透过虚拟方法拦截器对象运作，也仍旧是该对象的基础类别。当然我们也可以硬把正确的类别参考硬塞给该对象(初始时是四个 Bytes)的类别数据:

`PPointer(Person1)^ := FVmi.OriginalClass;`

举个更难的例子，我们已经修改了 OnBefore 的源码，所以在这个案例中，如果我们调用了 Age，它会回传特定的值，而把原来类别源码中的动作给忽略掉:

```pascal
FVmi.OnBefore := procedure(Instance: TObject; Method: TRttiMethod;
 const Args: TArray<TValue>; out DoInvoke: Boolean;
 out Result: TValue)
 begin
 Show ('Before calling ' + Method.Name);
 if Method.Name = 'Age' then
 begin
 Result := 33;
 DoInvoke := False;
 end;
 end;
```

输出结果跟原始版本的结果不同(请记得 Age 的调用跟相关的 OnAfter 事件都被忽略掉了):

```
Before calling Age
Age: 33
Before calling ToString
Before calling Age
After calling ToString
Person: Mark is 33 years old
Class: TPerson
Base Class: TPerson
```

现在我们已经看过了虚拟方法拦截器的技术细节，我们可以继续厘清在什么情境下我们会想用这个功能了。

再次重申，基本上在标准的应用程序中，我们没有理由使用这个功能。但在大多数开发进阶的函数库，且需要为了测试或处理对象的时候，会需要实作自定的行为。

举例来说，这个功能就可以拿来作为单元测试函数库的基础，不过它只能用在虚拟方法上面。我们也可以把这个功能和自定的标注一起使用，就可以用来实作一个源码样式，像是面向导向程序一样(Aspect Oriented Programming)。

## RTTI	 个案研究

现在我们已经介绍过了 RTTI 的基础，以及标注的使用，现在我们可以来看一些使用这些技术的实际案例，好证明这些技术是有用的。在许多情境中，更有弹性的 RTTI 以及能够使用自定标注都是相关连的，但是我们没有足够的篇幅一一列出这些情形。所以我们会用两个简单但经典的案例让大家一步步熟悉这样的开发方法。

第一个范例程序，会展现使用标注来识别在类别中特定的信息。具体来说，我们希望可以解析一个对象，该对象的类别是属于类别架构中的一员，并且拥有说明与独特的代号，这个代号可用来参照到该对象。这可以用来处理几种情形，像是描述储存在集合组件(可能是泛型集合对象或是传统的集合对象)当中的对象。

第二个范例则是串流的范例，特别是把对象串流到 XML 档案中。我会以使用发布区的 RTTI 作为古典的目标开始介绍，接着介绍新的延伸 RTTI，最后示范如何使用标注来自定源码，并让它变得更有弹性。


### 在 ID 跟描述上使用标注

如果我们想要有一些方法可以让许多对象共享，最传统的作法就是定义一个具备虚拟方法的类别，然后用这个类别作为基础类别来衍生几个不同的对象，并覆写这些虚拟方法。这个方法不错，但是在类别上还是有不少限制，这些限制也会由于类别结构而产生，因为我们让这些对象拥有同一个基础类别了。

完全不同的风格(当然有优点也有缺点)是使用标注来为特定的类别、方法货属性进行标示。这个作法比较有弹性，而且并没有使用到接口，而是基于一个相对比较慢，且容易出错的执行时期信息搜寻，和编译时期的解决方法完全不同。这表示我们不崇尚这种以接口作为更高目标的程序风格，而只是作为一个可能值得评估，以及在某些情形下使用的话可能会很有趣的作法。

**描述标注类别(The Description Attribute Class)**

为了这个范例，我已经定义了会被应用到的标注，作为可以被搜寻的元素。我们可以使用三个不同的标注，但应该要避免污染命名空间的标注。以下是标注类别的定义：

```pascal
type
 TDescriptionAttrKind = (dakClass, dakDescription, dakId);
 DescriptionAttribute = class (TCustomAttribute)
 private
 FDak: TDescriptionAttrKind;
 public
 constructor Create (ADak: TDescriptionAttrKind = dakClass);
 property Kind: TDescriptionAttrKind read FDak;
 end;
```

注意到，建构函数的使用透过他的唯一一个默认值的结构，让我们使用不带参数的标注。

**简单的类别**

接下来，我写了两个使用标注的简单类别。每个类别都用标注来标示，并且有两个方法以相同的标注，但不同的自定方式来标示。

第一个(TPerson)拥有对应到 GetName 函数的描述，并且使用了它的TObject.GetHashCode 方法来提供了一个临时代号，把该方法重新宣告来套用这个标注(这个方法的源码我们简单的称之为继承版本):

```pascal
type
 [Description]
 TPerson = class
 private
 FBirthDate: TDate;
 FName: string;
 FCountry: string;
  procedure SetBirthDate(const Value: TDate);
 procedure SetCountry(const Value: string);
 procedure SetName(const Value: string);
 public
 [Description (dakDescription)]
 function GetName: string;
 [Description (dakID)]
 function GetStringCode: Integer;
 published
 property Name: string read GetName write SetName;
 property BirthDate: TDate
 read FBirthDate write SetBirthDate;
 property Country: string read FCountry write SetCountry;
 end;
```

第二个类别(TCompany)相对的更简单，因为它有自己的代号跟描述:

```pascal
type
 [Description]
 TCompany = class
 private
 FName: string;
 FCountry: string;
 FID: string;
 procedure SetName(const Value: string);
 procedure SetID(const Value: string);
 public
 [Description (dakDescription)]
 function GetName: string;
 [Description (dakID)]
 function GetID: string;
 published
 property Name: string read GetName write SetName;
 property Country: string read FCountry write FCountry;
 property ID: string read FID write SetID;
 end;
```

虽然这两个类别有点相似，但他们在类别架构上、一般接口、或是任何面向都是完全不相干的。它们只共享了相同名字的标注而已。


**简单的专案与浏览标注**

标注的分享是用来显示被加入一个列表中的对象的相关信息，这个列表宣告在程序的主窗体里面:

`FObjectsList: TObjectList<TObject>;`

这个列表会在程序启动时被建立，并进行初始化:

```pascal
procedure TFormDescrAttr.FormCreate(Sender: TObject);
var
 APerson: TPerson;
 ACompany: TCompany;
begin
 FObjectsList := TObjectList<TObject>.Create;
 // add a person
 APerson := TPerson.Create;
 APerson.Name := 'Wiley';
 APerson.Country := 'Desert';
 APerson.BirthDate := Date - 1000;
 FObjectsList.Add(APerson);
 // add a company
 ACompany := TCompany.Create;
 ACompany.Name := 'ACME Inc.';
 ACompany.ID := IntToStr (GetTickCount);
 ACompany.Country := 'Worldwide';
 FObjectsList.Add(aCompany);
 // add an unrelated object
 FObjectsList.Add(TStringList.Create);
```

要显示跟这个对象相关的信息(通常是有被命名的代号跟描述，如果有定义的话)，在程序中使用了透过 RTTI 功能进行的标注寻找功能。首先，使用了助手函数来判断该类别是否有被以特定的标注进行标示：

```pascal
function TypeHasDescription (aType: TRttiType): Boolean;
var
 Attrib: TCustomAttribute;
begin
 for Attrib in AType.GetAttributes do
  begin
 if (Attrib is DescriptionAttribute) then
 Exit (True);
 end;
 Result := False;
end;
```

!!! note "笔记"
    在这个案例里面，我们需要检查完整的类别名称，DescriptionAttribute，则不只检查『描述』内容，它是当编译器透过方括号来辨识短名称时，我们要套用标注时可以使用的标识符。

如果这个案例符合条件，程序就会取得每个方法里面的每个标注，透过巢式循环，检查该标注是不是我们正在寻找的:

 ```pascal
if TypeHasDescription (AType) then
begin
 for AMethod in AType.GetMethods do
 for Attrib in AMethod.GetAttributes do
 if Attrib is DescriptionAttribute then
 ...
```

在循环的核心中，有被标注的方法会被调用来读取作为回传值的两个暂时字符串(稍后会被显示在用户接口上):

```pascal
if Attrib is DescriptionAttribute then
 case DescriptionAttribute(Attrib).Kind of
 dakClass: ; // ignore
 dakDescription:
 strDescr := AMethod.Invoke(anObject, []).ToString;
 dakId:
 strID := AMethod.Invoke(anObject, []).ToString;
```

这个程序错在不该检查标注是否重复了(因为如果多个方法被标示了同一个标注的话，我们可能会建立一个例外事件)。把前面提到的范例程序整理一下，以下是完整的 UpdateList 方法:

```pascal
procedure TFormDescrAttr.UpdateList;
var
 AnObject: TObject;
 Context: TRttiContext;
 AType: TRttiType;
 ATtrib: TCustomAttribute;
 AMethod: TRttiMethod;
 StrDescr, StrID: string;
begin
 for AnObject in FObjectsList do
 begin
 AType := Context.GetType(AnObject.ClassInfo);
 if TypeHasDescription (AType) then
 begin
 for AMethod in AType.GetMethods do
 for Attrib in AMethod.GetAttributes do
 if Attrib is DescriptionAttribute then
 case DescriptionAttribute(Attrib).Kind of
 dakClass: ; // ignore
 dakDescription: // should check if duplicate attribute
 StrDescr := AMethod.Invoke(
 AnObject, []).ToString;
 dakId:
 StrID := AMethod.Invoke(
 AnObject, []).ToString;
 end;
 // done looking for attributes
 // should check if we found anything
 with ListView1.Items.Add do begin
 Text := STypeName;
 Detail := StrDescr;
 end;
 end;
 end;
// else ignore the object, could raise an exception
end;
```

如果这个程序产生了不太有趣的输出结果，那么执行的方法一定会是相关的，因为我把一些类别批注掉了，其中这些类别的两个方法又使用了同一个标注，且已经让这些类别可以用外部的算法来进行处理。

换句话说，这些类别并不需要特定的基础类别，不用实作接口，也不用任何类别架构中提供任何内部源码，只需要这些类别在宣告的时候记得使用标注就行了。而管理这些类别的完全责任，则落在了外部的源码身上。


### XML 串流 


有一个有趣且很有用的使用 RTTI 的案例，是为对象建立一个可携的外部呈现，用来把它的状态储存到档案，或者把它透过网络传递给另一个应用程序。传统上，Object Pascal 达到这个目标的作法，是为对象的发布区属性进行串流，同样的作法也用来建立 DFM 档案。选项之一可能是制作自定义的串流框架来处理对象的串行化和还原作业。

现在，RTTI 让我们可以把对象的实际数据进行储存，而不用透过外部接口。这功能更强大了，虽然它也带来了一些额外的复杂度，例如对于内部对象的数据管理。再次强调，这个范例只是为这个技术做一个简单的示范，并没有深入探讨它的含意。

这个范例包含有三个版本，而为了简化它，把它们放在同一个项目进行编译。第一个版本是传统的 Object Pascal 作法，基于发布区的属性，其次则是使用了延伸 RTTI 跟数据字段的版本，第三个则是使用标注来自定数据对照方式。

**当然要有的XML Writer类别**

为了协助建立这样的 XML，我已经以让 XmlPersist 范例以一个延伸版的TTrivialXmlEriter 为基础，这个类别原本是我在撰写 Delphi 2009 Handbook这本书的时候，为了介绍 TTextWriter 类别所做的范例。在这里我就不再对它多做赘述了。我只想说，这个类别可以持续追踪它所开启的 XML 节点(感谢字符串堆栈)，然后依照后进先出的顺序关闭 XML 节点。


!!! note "笔记"
    TTrivialXmlWriter 类别的原始码，可以从 Delphi 2009 Handbook 的范例找到，网址是:http://github.com/MarcoDelphiBooks/Delphi2009Handbook/tree/master/07 /ReaderWriter

我在原始的类别中加入了一些限制格式的源码，以及用来储存对象的三个方法，基于我们在本节里面要介绍的三个不同作法，以下是类别的完整宣告内容:

```pascal
type
 TTrivialXmlWriter = class
 private
  FWriter: TTextWriter;
 FNodes: TStack<string>;
 FOwnsTextWriter: Boolean;
 public
 constructor Create (AWriter: TTextWriter); overload;
 constructor Create (AStream: TStream); overload;
 destructor Destroy; override;
 procedure WriteStartElement (const SName: string);
 procedure WriteEndElement (FIndent: Boolean = False);
 procedure WriteString (const SValue: string);
 procedure WriteObjectPublished (AnObj: TObject);
 procedure WriteObjectRtti (AnObj: TObject);
 procedure WriteObjectAttrib (AnObj: TObject);
 function Indentation: string;
 end;
```

要了解这段源码的意义，WriteStartElement 方法，会使用到 Indentation 方法来为让该行的节点可以留下两个空白，好让整个内部堆栈可以显示的比较容易阅读:

```pascal
procedure TTrivialXmlWriter.WriteStartElement( const SName: string);
begin
 FWriter.Write (Indentation + '<' + SName + '>');
 FNodes.Push (SName);
end;
```

在范例项目中可以找到完整的源码。

**传统以 RTTI 为基础的串流**

在介绍过涵盖了所支持的类别之后，我们从基础开始吧，也就是把一个对象用传统 RTTI 将发布区的属性以 XML 为基础格式进行储存。

WriteObjectPublished 方法的源码相当复杂，需要多一些说明。它是以TypInfo 单元文件为基础，且用了旧版 RTTI 当中的低阶版本的方法来取得特定对象发布区的属性(参数 AnObj)，透过以下的源码:

```pascal
NProps := GetTypeData(AnObj.ClassInfo)^.PropCount;
GetMem(PropList, NProps * SizeOf(Pointer));
GetPropInfos(AnObj.ClassInfo, PropList);
for I := 0 to NProps - 1 do
 ...
```

这段源码的功能，是要求一定数量的属性，配置适当大小的空间给数据结构使用，并把发布区属性的信息填入这些数据结构。如果我们想知道是否可以用低阶源码来做这些事情呢?发出这个问题的同时，我们就知道为什么新版的 RTTI 要被发展出来了：就是为了简化、隐藏旧版 RTTI 的复杂。为了每一个字段，程序会把数字跟字符串型别的属性内容解析出来，如果解析出来的是任何子对象的话，也会进一步解析这个子对象:

```pascal
StrPropName := UTF8ToString (PropList[i].Name);
case PropList[i].PropType^.Kind of
 tkInteger, tkEnumeration, tkString, tkUString, ...:
 begin
 WriteStartElement (StrPropName);
 WriteString (GetPropValue(AnObj, StrPropName));
 WriteEndElement;
 end;
 tkClass:
 begin
 internalObject := GetObjectProp(AnObj, StrPropName);
 // recurse in subclass
 WriteStartElement (StrPropName);
 WriteObjectPublished (internalObject as TPersistent);
 WriteEndElement (True);
 end;
end;
```

这里有点复杂，但为了范例，并让大家对传统方法有个概念，这应该是合理的。

为了示范这个程序的效果，我已经写了两个类别(TCompany 跟 TPerson)，这两个类别是从前一个范例借过来的。然而现在 Company 对象有了一个额外的 Person 型别属性，叫做 Boss。在实际的世界，这可能很复杂，但在这个范例中，这是很合理的假设。以下是这两个类别的发布区属性宣告:

```pascal
type
 TPerson = class (TPersistent)
 ...
published
 property Name: string read FName write FName;
 property Country: string read FCountry write FCountry;
 end;
 TCompany = class (TPersistent)
 ...
 published
 property Name: string read FName write FName;
 property Country: string read FCountry write FCountry;
 property ID: string read FID write FID;
 property Boss: TPerson read FPerson write FPerson;
end;
```

这个程序的主窗体有一个按钮，用来建立并连结这两个类别建立出来的两个对象，并且把它们储存到一个 XML 串流中，稍后我们会让它显示出来。以下是串流化的源码:

```pascal
SS := TStringStream.Create;
XmlWri := TTrivialXmlWriter.Create (SS);
XmlWri.WriteStartElement('Company');
XmlWri.WriteObjectPublished(ACompany);
XmlWri.WriteEndElement;
```

所产生的 XML 内容如下:

```xml
<company>
 <Name>ACME Inc.</Name>
 <Country>Worldwide</Country>
 <ID>29088851</ID>
 <Boss>
 <Name>Wiley</Name>
 <Country>Desert</Country>
 </Boss>
</company>
```

**以延伸版 RTTI 建立的串流数据字段**

透过 Object Pascal 的高阶 RTTI 功能，我可以把旧的源码改写成使用延伸版RTTI 来存取发布区的属性。而我所要做的，是使用它来把对象的内部表示进行储存，也就是私有区的数据字段。我所做的不只是更为核心的事情，而且是使用更为高阶的功能来达成的，WriteObjectRtti 方法完整的源码如下:

```pascal
procedure TTrivialXmlWriter.WriteObjectRtti(AnObj: TObject);
var
 AContext: TRttiContext;
 AType: TRttiType;
 AField: TRttiField;
begin
 AType := AContext.GetType (AnObj.ClassType);
 for AField in AType.GetFields do
 begin
 if AField.FieldType.IsInstance then
 begin
 WriteStartElement (AField.Name);
 WriteObjectRtti (AField.GetValue(AnObj).AsObject);
 WriteEndElement (True);
 end
 else
 begin
 WriteStartElement (AField.Name);
 WriteString (AField.GetValue(AnObj).ToString);
 WriteEndElement;
 end;
 end;
end;
```

产生的 XML 也很相似，只是相对的比较不清楚，因为数据字段的名称比属性的名称更不清楚：

```xml
<company>
 <FName>ACME Inc.</FName>
 <FCountry>Worldwide</FCountry>
 <FID>29470148</FID>
 <FPerson>
 <FName>Wiley</FName>
 <FCountry>Desert</FCountry>
 </FPerson>
</company>
```

然而另一个更大的不同，是在这个案例中，类别不需要从 TPersistent 类别衍生而来，也不需要有任何特别的限制。

**使用标注来自定串流化**

除了标签名称的问题以外，另外还有一个我还没提过的问题。使用 XML的标签名会是很复杂的标识符，这不是个好主意。同时，在这段源码里面，无法从 XML 串流的数据来排除特定的属性。

!!! note "笔记"
    Object Pascal 的属性串流可以透过 stored 设定来控制，我们可以透过使用TypInfo 单元文件来读取它。再说一次，这个作法并不简单，也不明快，虽然 DFM 串流机制把它运用的相当有效率。

这些是我们可以用标注来加以厘清的问题，但它的缺点是在宣告类别的时候大量使用标注，这种风格我并不喜欢。对于新版的源码，我已经透过一个选用的参数定义了一个标注化的建构函数：

```pascal
type
 XmlAttribute = class (TCustomAttribute)
 private
 FTag: string;
 public
 constructor Create (StrTag: string = '');
 property TagName: string read FTag;
 end;
```

标注化的串流源码则是一个以最后一版，以延伸 RTTI 为基础的演变。唯一的不同是现在的程序会调用 CheckXmlAttr 助手函数来确认该数据字段是否有 xml 标注，以及选用的标签名称加以注释:

```pascal
procedure TTrivialXmlWriter.WriteObjectAttrib(AnObj: TObject);
var
 AContext: TRttiContext;
 AType: TRttiType;
 AField: TRttiField;
 StrTagName: string;
begin
 AType := AContext.GetType (AnObj.ClassType);
 for AField in AType.GetFields do
 begin
  if CheckXmlAttr (AField, StrTagName) then
 begin
 if AField.FieldType.IsInstance then
 begin
 WriteStartElement (StrTagName);
 WriteObjectAttrib (AField.GetValue(AnObj).AsObject);
 WriteEndElement (True);
 end
 else
 begin
 WriteStartElement (StrTagName);
 WriteString (AField.GetValue(AnObj).ToString);
 WriteEndElement;
 end;
 end;
 end;
end;
```

最相关的源码是在 CheckXmlAttr 助手函数里面的:

```pascal
function CheckXmlAttr (aField: TRttiField; var strTag: string): Boolean;
var
 Attrib: TCustomAttribute;
begin
 Result := False;
 for Attrib in AField.GetAttributes do
 if Attrib is XmlAttribute then
 begin
 StrTag := XmlAttribute(attrib).TagName;
 if StrTag = '' then // default value
 StrTag := AField.Name;
 Exit (True);
 end;
end;
```

没有 XML 标注的数据字段会被忽略掉，在 XML 输出的标签是可以自定的。为了示范这一点，程序中有以下的类别(这一次我已经略过了发布区的属性，因为它们没相关):


```pascal
type
 TAttrPerson = class
 private
 [xml ('Name')]
 FName: string;
 [xml]
 FCountry: string;
 ...
 TAttrCompany = class
 private
 [xml ('CompanyName')]
 FName: string;
 [xml ('Country')]
 FCountry: string;
 FID: string; // omitted
 [xml ('TheBoss')]
 FPerson: TAttrPerson;
 ...
```

透过这些宣告，XML 输出值看起来会像以下这些 XML 数据(请注意到卷标名称，ID 是被忽略掉了，而预设的名称则是 FCountry 字段):

```xml
<company>
<CompanyName>ACME Inc.</CompanyName>
<Country>Worldwide</Country>
<TheBoss>
 <Name>Wiley</Name>
 <FCountry>Desert</FCountry>
</TheBoss>
</company>
```

这里的不同是我们可以对哪些字段要被纳入 XML，以及如何在 XML 里面对它们进行命名很有弹性，而在前一版的作法则完全不能随意处理。

虽然这只是个骨架版本的实作，我还是希望读者们有机会能看一下如何一步步的以传统 RTTI 来建立出最后的版本，这会让我们对于几个不同的技术之间如何实作留下印象。

而很重要，必须一定要记住的是，事实上，使用标注并不一定是最好的解决方法。另一方面，很明显的 RTTI 跟标注在任何一种情境中都提供了许多威力跟弹性，我们需要透过这个技术才能在运行时间对结构跟未知的对象进行了解。

### 其他以 RTTI 为基础的函数库


要为这一章做结论，我想指出一个事实，目前有一些函数库，包含内建在Delphi 与第三方的函数库，都已经开始并入延伸 RTTI 了。一个很明显的例子是表达式绑定的机制已经跟背景的可视化绑定逐渐一致。我们可以建立绑定表达式，把它指派给一个表达式(例如 Text 里的一个字符串，可以进行处理，例如字符串连接)，或是让该表达式参考到一个额外对象与其数据字段。

即使我不想太深入这个主题，它是一个很特定的函数库，并且不是 Object Pascal 的一部分，也不是核心系统的一部分，我想用一个简单的列表来让大家有这个概念:

```pascal
var
 BindExpr: TBindingExpression;
 Pers: TPerson;
begin
 Pers := TPerson.Create;
 Pers.Name := 'John';
 Pers.City := 'San Francisco';
 BindExpr := TBindingExpressionDefault.Create;
 BindExpr.Source := 'person.name + " lives is " + person.city');
 BindExpr.Compile([
 TBindingAssociation.Create(Pers, 'person')]);
 Show (BindExpr.Evaluate.GetValue.ToString);
 pers.Free;
 BindExpr.Free;
end;
```

注意到这段程序的优点来自于我们可以在运行时间改变表达式的内容(虽然在上面的范例源码里面，表达式的内容是用一个字符串常数写成的)。表达式的内容可以从一个 Edit 组件让用户输入，或者可以动态的从几个不同的表达式结合而来。它先被指派给 TBindingExpression 对象，接着在运行时间被透过调用 Compile 方法，加以分析、编译(这里所指的是字符串被转换成标识符的格式，不是真的编译成汇编语言的执行码)。然后会在执行时使用 RTTI 来存取 TPerson 对象。

缺点是这个作法会使得表达式的执行明显的比预先编译完成的 Object Pascal 机器码来的慢。换句话说，我们得在效能跟弹性上取得一个平衡。也可以说可视化直接绑定模型的功能提供了功能强大、容易使用的开发者经验。
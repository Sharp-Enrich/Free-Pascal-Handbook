
如果撰写类的主要原因是为了封装，那么使用继承的主要理由就是为了弹性。把两个概念结合之后，我们就可以拥有一个强大的资料类型，我们可以拿来使用，而且以后不用为了改其中的功能而为这个数据类型来建立许多不同版本了，这个概念一开始被称为”开放式封闭概念(open-close principle)”:

> “软件设计的概念(类、模块、函数等)应该要有能延伸的开放性，但对修改则要有封闭性”- Betrand Meyer, 面向对象软件建构, 1988

继承能够把一些源码很紧密的结合起来，也能够让程序人员发挥很强的功能(当然，也会带来更大的责任)。

并不是在这里开启对这个功能的争论，我们在这里要做的，是介绍类型继承是怎么作用的，尤其在 Object Pascal 中，类型继承是怎么作用的。

## 从既存的类型中继承

我们通常需要使用一些不同的功能，这些功能可能是从我们自己之前写过的源码，或者从别人写过的源码里面部分功能提供出来的。例如，我们可能会需要为已经写好的源码加上一些新的方法或者做一些改变。我们当然可以直接改原来的程序原始码，但有时候我们会同时需要这两种版本同时存在，在不同的情形中分别使用到。或者有个类是别人写的(或者我们从函数库里面找到的)我们可能想要保留一个我们自己的独立版本。

传统在学校里面教授过的替代方法，是把原来的类源码留一份下来，直接改一份新的源码，两份并存。这样做也可以，不过也可能创造问题:在重复的源码里面，我们可能也重复了原本的程序错误，当我们修正了其中一份源码的问题，也必须记得把这个修正套用到另外一份源码。如果您想要在源码中加入一个新功能，也必须把相同的程序在每份源码都做一次，这还得看你复制了几份，就得处理几次。就算你第一次写这程序的时候，这种复制多份的作法并没有拖慢你的速度，但未来维护的时候，这绝对是个大灾难。再者，这几个不同版本的类源码最后会变成不同的独立类型，编译器没办法告诉我们哪个版本才是最好的，也没办法告诉我们两个版本之间有哪些雷同之处。

如果我们要加一个新功能，我们可能得在两份源码里面都各做一次(可能得多做很多次也说不定，要看我们最后一共搞了多少个版本出来)。再者，这几个不同版本的类源码最后会变成不同的独立类型，编译器没办法告诉我们哪个版本才是最好的，也没办法告诉我们两个版本之间有哪些雷同之处。

为了解决这些因为类之间相似而导致的问题，Object Pascal 允许我们用既存的类直接定义出一个新的类。这个技术就称为继承(或者次类、或类型衍生)，这个技术也是面向对象设计编程语言的基础元素之一。

要从一个既存的类进行继承，我们只需要在定义类的第一行，指出我们要从哪个既存类衍生出新类即可。这个动作实际上会在我们每次建立一个新窗体的时候由 IDE 自动帮我们做好:

```pascal
type
 TForm1 = class(TForm)
 end;
```

这个简单的宣告表示 TForm1 类会从 TForm 继承所有的方法、数据字段、属性、以及事件。我们可以从 TForm1 的对象来使用 TForm 类的任何一个公开方法。TForm 类依序继承了其上每一代的对象所有的方法，一直回溯到 TObject 类(这是 Object Pascal 里所有类的基础类)。跟 C++, C#, Java 做个比较，用这三个语言来宣告，则会写成:

```c++
class Form1 : TForm
{
...
}
```

作为继承关系的一个简单范例，我们可以用上一章的范例来改写成ViewDate 范例项目，从 TDate 衍生一个新的类，并且把它的函数 GetText改写一下。您可以从 DerivedDates 范例项目的 DATES.pas 档案找到这个源码：

```pascal
type
 TNewDate = class (TDate)
 public
 function GetText: string;
 end;
```

在这个范例里，TNewDate 是从 TDate 衍生而来。简单的说，TDate 是TNewDate 的父代类，基础类或者祖先类。而 TNewDate 则是 TDate的子类、衍生类，或者次类。

为了实作新版的 GetText 函数，我使用了 FormatDateTime 函数，这个函数中使用了预先定义的月份名称(还有其他功能)，以下是 GetText 方法，其中的’dddddd’代表了长日期格式：

```pascal
function TNewDate.GetText: string;
begin
 Result := FormatDateTime (‘dddddd’, FDate);
end;
```

一旦我们定义了新的类，我们就得在 DerivedDates 项目的窗体源码里面使用这个新的数据类型。直接定义一个以 TNewDate 为类型的对象 ADay，然后在 FormCreate 方法里面调用这个类的建构函数：

```pascal
type
 TDateForm = class(TForm)
 ...
 private
 FDay: TNewDate; // updated declaration
 end;
procedure TDateForm.FormCreate(Sender: TObject);
begin
 FDay := TNewDate.Create; // updated line
 DateLabel.text := FDay.GetText;
end;
```

不用任何源码变更，这个新的范例项目就能执行的很顺畅。

新的类 TNewDate 继承了所有 TDate 的方法，可以把日期设定向后延伸跟使用其他功能。换句话说，原来调用这些方法的源码仍旧可以正常运作。事实上，调用新版的 GetText 方法时，我们并不用改变任何源码！Object Pascal 的编译器会自动把调用这个方法跟新版的方法做绑定。所有事件处理程序的源码也都不用改变，虽然在新版的输出文字上，其意义已经跟旧版的事件有些不同(请见图 8.1)：

图 8.1: DerivedDates 程序的执行画面，月份跟日期的名字是依照 Windows的地区与格式设定而显示的

## 常用的基础类

我们已经介绍过，要从一个类衍生新类时，可以这样写：

```pascal
type
 TNewDate = class (TDate)
 ...
 end;
```

但如果我们指定从基础类衍生，写成以下这样的话，会发生什么事呢:

```pascal
type
 TNewDate = class
 ...
 end;
```

在这种情形下，我们的类就会从基础类衍生，也就是 TObject。换句话说，Object Pascal 是单一根源的类架构。在这种架构之下，所有类直接或间接的都是从 TObject 衍生而来的。最常用的方法就是 TObject 的 Create, Free 跟 Destroy 方法，以及我在本书当中其他篇幅里面所用到的方法。关于这个基础类的的完整介绍(可以把它视为在语言跟 RTL 两个层面都具备的基础)，我们会在第 17 章里面介绍。

!!! note "笔记"
    共享基础类的概念，除了 Object Pascal 以外，还有 C#跟 JavaScript 也是这样的架构，在这两个语言里面，基础类称为 Object。C++则是完全不同的架构，C++是支持多重基础类继承的架构。


## 保护区字段与封装

TNewDate 类 GetText 方法的源码只有在跟 TDate 写在同个单元文件里面才会编译。事实上，它会存取父代类的 FDate 私有区字段，如果我们想要在不同单元文件里面制作子类的话，我们要不就得把 FDate 这个字段放在protected(或者 strict protected)区域，或者在父代类里加入一个简单的保护区方法来读取这个私有区的字段。

有些开发人员相信第一种作法是最好的，因为把大多数字段宣告在保护区，可以让类比较有延伸性，要用它来撰写子类也比较容易。然而，这就抵触了数据封装的原意。要在大架构的一群类当中，想把其中基础类的保护区字段做变更，就有如要修改部分全局数据结构一样困难。如果有 10 个衍生类存取这个数据字段，对这个字段做变更，可能意味着有 10 个类都必须要跟着做修改。

换句话说，弹性、延伸性，以及封装，这三个目标通常是有所冲突的。当冲突发生的时候，我们应该试着以封装这个目标为重。如果我们能够做到这一点，而不牺牲弹性，那就更棒。通常这个中间解决方案，可以透过使用虚拟方法来达成，虚拟方法我们会在稍后的”延迟绑定与多型”这一节里面来讨论。如果我们选择不以封装为重，而选择能让次类的撰写比较容易、快速一点，那我们的设计很有可能就没办法依循面向对象的原则了。

也要记住，保护区的字段在存取规则上跟私有区是一样的，所以同一个单元文件里面的其他类也随时可以存取任何一个同单元文件里面类的保护区成员喔。如同前一章我们提过的，我们可以用更强的封装方式，只要使用分区存取关键词 srtrict protected 即可。


### 使用保护区来骇入 (Protected	Hack) 

如果您是 Object Pascal 的入门者，而且要迈入面向对象程序，那么这一节对您来说就会是相对进阶的章节，您或许会想先略过这一节，因为这一节可能会比较容易让您觉得难懂。

我们已经知道单元文件保护区的范围，即使是宣告在同一单元文件的类所属的基础类的保护区成员，也可以被同一单元文件的其他类直接存取，除非我们使用strict protected关键词来加以保护。这种遵守OOP规则的漏洞，就称为『受保护的黑客』。这是能够定义一个衍生类跟其父代类完全相同，但只是为了取得其父代类保护区成员的访问权限。以下是其工作的原理：

我们已经介绍过，一个类的私有区、保护区，是可以被任何跟这个类位于相同单元档案里面的其他类存取的。举例来说，以下这个简单的类(它是 Protection 范例项目的一部分):

```pascal
type
 TTest = class
 protected
 FProtectedData: Integer;
 public
 PublicData: Integer;
 function GetValue: string;
 end;
GetValue 这个方法会简单的回传包含两个整数数值的字符串：
function TTest.GetValue: string;
begin
 Result := Format (‘Public: %d, Protected: %d’, [PublicData, FProtectedData]);
end;
```

一旦我们把这个类放在独立的单元文件里面，我们就没办法从任何其他单元文件来存取它的保护区成员了，例如我们写了以下的源码:

```pascal
procedure TForm1.Button1Click(Sender: TObject);
var
 Obj: TTest;
begin
 Obj := TTest.Create;
 Obj.PublicData := 10;
 Obj.FProtectedData := 20; // won’t compile
 Show (Obj.GetValue);
 Obj.Free;
end;
```

编译器会直接提出以下的错误讯息:未经宣告的识别符号: “FProtectedData”。在此时我们或许会想到没有办法存取宣告在其他单元文件的类的保护区数据。然而，还是有方法可以处理的。想想，如果我们建立了一个显然没有用途的衍生类，像是:

```pascal
type
 TTestAccess = class (TTest);
```

现在，在宣告它的同一个单元文件里面，我们就可以调用 TTestAccess 类的所有保护区方法了。事实上我们可以调用同一单元文件里面所有类的保护区方法。

但是，这样怎么帮助我们使用 TTest 类的对象呢?想象一下，两个共享完全相同内存架构的类，我们可以强迫编译器把一个类的对象当做另一个类的，通常可以透过不安全的类型转换来达成：

```pascal
procedure TForm1.Button2Click(Sender: TObject);
var
 Obj: TTest;
begin
 Obj := TTest.Create;
 Obj.PublicData := 10;
 TTestAccess (Obj).FProtectedData := 20; // compiles!
 Show (Obj.GetValue);
 Obj.Free;
end;
```

这段程序可以编译，运作也正常，就像我们可以看到 Protection 范例项目执行一样。重申一次，原因是 TTestAccess 类自动继承了 TTest 基础类的保护区字段，且因为 TTestAccess 类也在跟想要存取这些数据的源码位于同一个单元文件里面，所以保护区的数据是可以被存取的。

现在，我们来探讨为什么这可以行得通?我得先警告读者，这个可是违反类保护机制的，这个方法可能会让你的程序发生错误(存取不该存取的数据)，且还遵循着 OOP 记录的规则执行着。然而有些时候，透过这个技术是最好的解决方法，就像您可以在阅读函数库的原始码时，发现很多组件的原始程序就是这样做的。

总体来说，这个技术更像是在骇入整个类系统，且不管何时都应该尽量避免，但它可以跟其他任何效果一样，被视为是 Object Pascal 编程语言的规格，且在任何操作系统、任何版本的 Object Pascal 都有效。


## 从继承到多型

如同字面的意义，继承是个好技术，透过它，我们可以避免源码重复，并在许多不同的类之间分享方法。然而，其内涵的力量来自让不同类的对象使用同一规则的能力，像是常被在 OOP 语言里面以”多型”或者”延迟绑定”这两个名词界定的意思。

我们需要先探索一些技术：衍生类之间的类型兼容性，虚拟方法，以及在接下来这一节里面要介绍的。


### 继承与类型兼容性 

如同我们已经看过的一些主题，Object Pascal 是一个强类型的语言，举个实例，这表示我们不能把一个整数类型的值指派给一个布尔类型的变数。至少不能在没有经过明确写出要求类型转换的情形下是如此的。基本规则是，两个数据只有在属于相同类型时，才具有类型兼容性，更精确一点来说，他们所属的数据类型的名称必须完全相同，且定义在同一个单元文件里面才算。

这个规则里有一个重要的例外，就是类类型。如果我们宣告了一个类，姑且说它叫做 TAnimal，然后用它衍生出新的类，就叫 TDog 好了，我们可以把TDog类的对象指派给TAnimal。这是因为Dog是Animal的一种(狗也是一种动物)。从编程语言的角度或许您会觉得讶异，以下调用建构函数的语法都是合法的：

```pascal
var
MyAnimal1, MyAnimal2: TAnimal;
begin
 MyAnimal1 := TAnimal.Create;
 MyAnimal2 := TDog.Create;
```

用更精确的字眼来说，我们可以把子类的对象当做父类的变量来使用。然而反向的使用就不行了，我们不能把父类的对象当成子类的变量来使用，以下就是这个理论的源码体现：

```pascal
MyAnimal := MyDog; // This is OK
MyDog := MyAnimal; // This is an error!!!
```

事实上，我们当然可以说狗是一种动物，但不能说动物一定就是狗吧。这在大多数时候说的通，但不是定律。这相当合逻辑，且编程语言的类型兼容性也遵循这个逻辑。

在我们仔细深入 Object Pascal 关于这个重要功能的意涵之前，请先试着执行Animals1 范例项目，在这个项目里面定义了两个简单的类，TAnimal 跟TDog，TDog 是从 TAnimal 衍生而来的:

```pascal
type
 TAnimal = class
 public
 constructor Create;
 function GetKind: string;
 private
 FKind: string;
 end;
 TDog = class (TAnimal)
 public
 constructor Create;
 end;
 ```

这两个建构函数 Create 都只是简单的设定 FKind 的值，这个值会由 GetKind函数回传。

图 8.2: Animals1范例项目的窗体在开发环境内的样子

这个范例的窗体，请参考图 8.2，有两个单选按钮(放在一个 Panel 上面)，可以选择属于何种类的对象。这个对象储存在私有区，名为 FMyAnimal，属于 TAnimal 类。这个类的实体会在窗体每次建立或重建的时候依照单选按钮的选择被建立且进行初始化(在此我们只显示第二个单选按钮对应的源码)：

```pascal
procedure TFormAnimals.FormCreate(Sender: TObject);
begin
 FMyAnimal := TAnimal.Create;
end;
procedure TFormAnimals.RadioButton2Change(Sender: TObject);
begin
 MyAnimal.Free;
 MyAnimal := TDog.Create;
end;
```

最后，Kind 按钮会调用目前这个 animal 的 GetKind 方法来把结果显示在窗体下方的 Memo 里面：

```pascal
procedure TFormAnimals.BtnKindClick(Sender: TObject);
begin
 Show(FMyAnimal.GetKind);
end;
```

### 延迟绑定与多型

Object Pascal 函数跟程序通常都是静态绑定，或者也称为早期绑定。这表示一个方法在程序撰写时，编译器或链接程序就已经进行解析，且源码会在编译结果的档案中，被置换成该程序调用所要对应到的内存位置。(这内存位置也被称为函数地址)。面向对象编程语言则同时允许另一种绑定，称之为延迟绑定，或者动态绑定。在这种情形下，要被调用的函数或方法的实际地址，得等到运行时间，由用来调用该函数的对象实体的类型来决定。

这个技术的好处也被称之为多型。多型意味着我们可以撰写程序来调用一个方法，当然是得从一个对象变量来发起，但 Delphi 会依照该对象的实际类来决定要使用哪个方法。Delphi 在运行时间确定对象变量的实际类型之前，无法决定要使用哪个函数或方法，就因为前一节我们讨论过的类型兼容性。


!!! note "笔记"
    Object Pascal 的方法预设是使用早期绑定式，跟 C++, C#一样。其中一个原因是因为这样比较有效率。而 Java 则不一样，Java 使用延迟绑定(并提供一些方法让编译器可以使用早期绑定来对方法进行优化)。

假设一个类跟它的子类(就用刚提到的 TAnimal 跟 TDog 做范例吧)，两者都定义了一个方法，这个方法就会是延迟绑定。现在我们可以用一个通用的变量，例如 FMyAnimal 来调用这个方法，在运行时间，这个变量可以是TAnimal 或 TDog 类型。实际上在运行时间会用到哪个类的方法，就得看当时该对象是属于哪个类了。

Animals2 范例项目则延伸了 Animals1 项目来做为这个技术的范例。在新版本中，TAnimal 跟 TDog 类都提供了一个新的方法:Voices，这个方法表示被选中的动物所发出的声音，同时以文字跟声音表示。这个方法在 TAnimal类中以虚拟方式定义(Virtual)，在稍后我们定义 TDog 类时进行覆写(override)，透过 virtual 跟 override 这两个关键词:

```pascal
type
 TAnimal = class
 public
 function Voice: string; virtual;
 TDog = class (TAnimal)
 public
 function Voice: string; override;
```

当然，这两个方法也需要被实作喔，以下是简单的实作源码:

```pascal
function TAnimal.Voice: string;
begin
 Result := 'AnimalVoice';
end;
function TDog.Voice: string;
begin
 Result := 'ArfArf';
end;
```

那我们调用 FMyAnimal.Voice 会有什么反应呢?要看情况而定。如果FMyAnimal 变量目前是储存 TAnimal 类的对象，就会调用 TAnimal.Voice。如果储存的是 TDog 类对象，就会调用 TDog.Voice。这个情形是因为该方法是虚拟的(Virtual)。

对所有 TAnimal 类的任何子类对象来调用 FMyAnimal.Voice 方法都会正常执行，即使该类是在这个方法的源码之后才定义的，或者已经超出了它的可视范围。编译器不会需要一一知道衍生类的族谱，就能让上面的这个函数调用兼容，编译器只需要知道被调用的对象所属类的父代类。换句话说，FMyAnimal.Voice 这个方法可以在所有 TAnimal 的子类兼容。

这就是为什么 OOP 的编程语言在重复使用性这一点很强的关键性科技因素了。我们就算不用知道类架构跟特定类之间的关系，也可以直接写一段使用该类的源码，。换句话说，该架构(或者说该程序)仍然具备可延展性，即使当我们用它写了数千行的源码。当然，有个前提条件，就是这个架构的父代类得要仔细设计。

Animals2 项目示范了这些新类的用法，并提供了类似前一个范例的窗体。以下的源码会在点击按钮的时候被执行，显示输出文字，并播放一些声音出来：

```pascal
begin
Show (FMyAnimal.Voice);
MediaPlayer1.FileName := SoundsFolder + FMyAnimal.Voice + '.wav';
 MediaPlayer1.Play;
end;
```

!!! note "笔记"
    这个项目使用了 MediaPlayer 组件来播放项目内嵌的两个声音档案的其中之一(声音档案是用实际的声音字符串来命名的，这个声音字符串会由Voice 回传)。相对随机的噪音是提供给 TAnimal，而狗叫声则是提供给 TDog来播放的。现在这段源码在 Windows 上面可以很容易执行了，只要声音档放在适当的文件夹里面，但如果在行动装置平台上开发，就需要一些额外的设定，好让这些档案能自动放到对应的文件夹去。

    看一下实际的范例，看发布到行动装置平台时的文件夹是要怎么设定的。

### 覆写(Override)、重新定义(Redefine)、重新介绍(Reintroduce)方法 

如我们刚刚看过的，在衍生类里面要覆写一个延迟绑定的方法，我们得使用 override 这个关键词。请注意这个方法只能用在父代类中，宣告为虚拟(virtual)的方法，但也可以被定义为动态(dynamic)，这个关键词我们稍后会再介绍。否则，如果该方法是静态方法，就无法进行延迟绑定，在子类也不能更改源码了。

!!! note "笔记"
    您可能还记得我们在前一章就使用了这个关键词来覆写 Destroy 这个从TObject 继承而来的预设解构函数。

这个规则很简单: 只要一个方法被定义成静态方法，则这个方法在任何一代的子类里面也都是静态方法，除非我们在某一代子类里面特别去用虚拟的同名方法把它给替代掉。而定义成虚拟方法之后，这个方法在任何一代的子类也都会是延迟绑定的，而且没有任何方法可以改变这一点，因为编译器为延迟绑定的方法建立源码的方式是不同的。

要重新定义一个静态方法，我们只需在子类里面加入同样名称的方法，不管参数是否相同，也无须加入任何关键词。要覆写一个虚拟方法，我们则需要在子类里面用相同名称、相同参数来定义这个方法，并且结尾要加上一个 override 关键词：

```pascal
type
 TMyClass = class
 procedure One; virtual;
 procedure Two; // static method
 end;
 TMySubClass = class (MyClass)
 procedure One; override;
 procedure Two;
 end;
```

被重新定义的方法 Two，就不再使用延迟绑定。所以当我们透过基础类的对象来调用这个方法，就会执行基础类的方法了。(也就是说，如果该变量是指向衍生类的对象，则透过该对象调用 Two 这个方法时，执行的结果跟基础类对象执行的结果将会不同)。

有两种传统的方法可以覆写一个方法。第一是把父代类的方法改写一个新版本，第二则是在已经存在的方法里面加入一些源码。以第二个作法实作时，可以透过使用 inherited 这个关键词来调用父代类的同名方法。举例来说，我们可以这样写：

```pascal
procedure TMySubClass.One;
begin
 // new code
 ...
 // call inherited procedure TMyClass.One
 inherited One;
end;
```

您可能会觉得有点讶异，为什么需要使用 orverride 关键词? 在其他编程语言里，当我们在子类里面重新定义一个虚拟方法时，就已经会自动覆写原来的方法了。然而透过关键词的使用，编译器可以检查在父代类跟子类之间同名方法之间的名称与关系(重新定义方法时，把名称打错是很常见的错误，在其他 OOP 语言里面也一样)，检查看看该方法在父代类是否是虚拟方法，以及其他项目。

!!! note "笔记"
    另一个热门的 OOP 编程语言 C# 也使用相同的 override 关键词。这一点都不令人讶异，因为 C#跟 Object Pascal 的编程语言设计者是同一个人。Anders Hejlsberg 曾经写了不少文章来说明为何 override 这个关键词是设计函数库中 基 础 可 视 化工具的 原 因 ， 您 可以从这 里 读 读 看 : http://www.artima.com/intv/nonvirtual.html 更近期的语言，Apple 的 Swift 语言也是使用 override 关键词让衍生类来修改方法的。

这个关键词的另一个优点，是如果我们在从函数库的类中衍生任何类时定义了静态方法，并不会发生问题，即使函数库已经用了一个新的虚拟方法来取代我们在子类所定义的同名方法。因为我们定义的方法并没有使用override 关键词，所以会被自动认为新的这个方法是一个新的独立方法，并不是被加入到函数库那个方法的新版本。(如果编译器认为是覆写版本的话，父代类这样的程序修改可能会让我们在子类中重新定义的程序无法执行)

支持多载(overloading)为这个功能蓝图添加了一些复杂度，子类当中可以透过 overload 关键词来帮一个方法加入新的版本。如果这个方法的参数跟基础类中同名方法的参数不同，就会很有效率的变成多载方法，如果参数相同，则会直接取代掉基础类的同名方法，以下是个范例：

```pascal
type
 TMyClass = class
 procedure One;
 end;
 TMySubClass = class (TMyClass)
 procedure One (S: string); overload;
 end;
```

请留意，这方法并不需要在基础类中标注为 overload。然而，如果基础类中的这个方法是个虚拟方法，编译器就会提出这样的警告讯息: ‘One’这个方法会把基础类’TMyClass’里面的虚拟类隐藏掉。

为了避免编译器提出这个警告讯息，并提供编译器更精确的指令，让它知道我们想要的结果，我们可以使用 reintroduce 这个关键词：

```pascal
type
 TMyClass = class
 procedure One; virtual;
 end;
 TMySubClass = class (TMyClass)
 procedure One (S: string); reintroduce; overload;
 end;
```

我们可以在 ReintroduceTest 范例项目里面找到这个源码，并用它来做一些进阶的实验。

!!! note "笔记"
    另一个我们常用到 reintroduce 的情形，就是我们想要为组件类新增一个自定的建构函数 Create 之时。因为组件类都已经有从 TComponent 这个基础类继承而来的虚拟建构函数 Create 了。


### 继承和建构函数

一如我们看过的，我们可以用 inherited 这个关键词在子类中调用父代类的同名方法(当然也可以调用不同名称的方法)。对于建构函数也有一样的效果。在其他编程语言中，像是 C++, C#, 或者 Java，调用父代类的建构函数是不用特别指名且会要求我们强制进行的(当我们必须把参数传给父代类的建构函数之时)，而在 Object Pascal 里面，子类并不一定要调用父代类的建构函数。

然而，在大多数情形下，我们主动去调用父代类的建构函数是很重要的。举个例子，以下就是这种情形，在任何一个组件类中，当组件的初始化在TComponent 类层次已经完成：

```pascal
constructor TMyComponent.Create (Owner: TComponent);
begin
 inherited Create (Owner);
 // specific code...
end;
```

这是非常重要的，因为组件的 Create 是虚拟方法。跟所有的类相似，解构函数 Destroy 也是个虚拟方法，我们必须记得透过 inherited 来调用父代类的同名方法。

还剩下一个问题：如果我们正在建立一个类，它只继承了 TObject，在它的建构函数里面，我们还需要调用 TObject 的建构函数 Create 吗?从技术观点来看，是不需要的，假如该建构函数是空的，并没做什么事。然而，从养成好习惯的观点来看，无论如何，永远要记得调用父代类的建构函数。然而如果您对效能有很高的要求，我得承认，这会拖慢速度，虽然影响层面只有小小的几个毫秒(microsecond, 不是 minisecond 耶)。

打屁结束，有几个好理由让我们使用以上两个技术，但特别是对入门者来说，我会建议一定要调用父代类的建构函数，要养成这个好习惯。大家一起来推广安全的程序写法。


### 虚拟与动态方法 

在 Object Pascal 里面，有两个方法可以启动延迟绑定。我们可以把一个方法宣告为虚拟方法，透过 virtual 关键词，或者也可以用我们在前面的篇幅介绍过的，把它宣告成动态方法，透过 dynamic 关键词。这两个关键词的用法都一样，直接把关键词放在方法宣告的最后面，它们的效果也一样。唯一的不同，是编译器在实作延迟绑定时的内部机制不同。

虚拟方法是以虚拟方法列表(Virtual method table，也可以简写为 vtable)来实作的。虚拟方法列表是一个用来储存方法地址的数组。要调用虚拟方法时，编译器会建立一个源码，把程序执行点跳到该对象的第 N 个虚拟方法列表的纪录去。

虚拟方法列表允许方法被快速调用。这个作法主要是把每个子类所有虚拟方法的进入点收集起来，即使该方法并没有在子类里面被覆写也一样。这样一来，虚拟方法列表里面就可以在整个架构中把每个子类的虚拟方法快速的传播(即使对于没有被重新定义的方法也一样)。这方法可能会使用许多的内存，就只为了储存同一个方法的内存进入点地址。

另一方面，调用动态方法则是使用每个方法的唯一代号来进行识别与派发。搜寻特定函数通常是比单次从列表中寻找会花上更多的时间。动态方法的优点，是只会在子类覆写了方法的时候，才会进行方法进入点的传播。对于庞大且多层的对象架构来说，使用动态方法，而不使用虚拟方法，可以省下很可观的内存，但速度上的落后并不严重。

从程序人员的观点来看，这两种技术的差异只在内部的表示法，以及不同的内存与速度而已，排除这几个差异，虚拟方法跟动态方法几乎是完全相同的技术。

现在我们已经说明了这两种模型的差异，让我们强调一下，在许多的案例中，应用程序开发人员大多使用虚拟方法，而非动态方法，这点也是不可不察的。


**在 Windows 系统中的讯息处理程序**

当我们在建立 Windows 应用程序时，有一个特殊要求的方法可以用来处理Windows 系统讯息。为了这个要求，Object Pascal 提供了另一个关键词:message 用来定义讯息处理的方法，这个方法必须是带有一个适当类型的var 参数的程序。Message 这个关键词之后必须跟着一个 Windows 讯息代号，也就是这个程序要处理的讯息代号。例如以下的源码，会让我们处理一个用户自定的讯息，讯息代号是以 Windows 的系统常数:wm_User 来定义的：

```pascal
type
TForm1 = class(TForm)
 ...
 procedure WmUser (var Msg: TMessage); message wm_User;
 end;
 ```

程序的名称跟实际的参数类型我们可以自己决定，只要实际的数据结构跟Windows 讯息的结构相同即可。这个单元文件使用了 Windows API 来引入一些已经位多种 Windows 讯息定义好的记录类型。这个技术对于 Windows应用程序的熟手尤其有用，我们都知道 Windows 讯息跟 API 函数，但这些跟其他操作系统真的无法兼容(像是 iOS, OSX 跟 Android)。

## 把⽅法跟类抽象化

当我们建立一整个架构的类时，通常很难决定用哪个类当成基础类，假如这个类不会实际标示进入点，但只会用来表示一些共享的规则。我们之前介绍过的范例就是一个很好的例子，以 Animal 来做为基础类，让 cat, dog 来做为子类。我们并不期待为这样的类建立对象，只让它用以表示一些特性，因此把它称为抽象类，因为这个类不需要完整的实作源码。抽象类可以拥有抽象方法，这些方法也不用实作源码。


### 抽象方法(Abstract	Methods) 

关键词 abstract 是用来宣告只会在子类当中定义的虚拟方法。透过这个关键词，已经完整定义了方法，这并不是预先宣告。如果我们企图为这个方法提供实质源码，编译器可是会发出警告的。

在 Object Pascal 里面，我们可以为拥有抽象方法的类建立实体。然而当我们试着这样做，编译器还是会发出警告讯息的:”企图为拥有抽象方法的<类名称>建立实体”。如果我们刚好在运行时间调用了一个抽象方法，Delphi会抛出一个运行时间例外。

!!! note "笔记"
    C++, Java 跟其他编程语言则有更多限制，在这些语言中，我们根本不被允许建立抽象类的实体。

您可能会觉得奇怪，为什么我们会想使用抽象方法。原因是使用了多型。如果 TAnimal 类拥有一个名为 Voice 的虚拟抽象方法，每个子类都可以重新定义它。

好处是我们可以透过共通的对象 FMyAnimal 来指向每一个动物类型的对象，然后调用这个方法。如果这个方法没有在 TAnimal 类中出现，这样的调用方法可是不会被编译器允许的，因为编译器会执行静态类型检查。使用共享的 FMyAnimal 对象，我们可以只透过 TAnimal 定义的方法来调用。

我们不能调用子类当中才有提供的方法，父代类必须至少也得宣告过要调用的方法才行-也就是抽象方法的一个种类。下一个范例项目，Animals3，就将示范抽象方法跟抽象调用错误，以下是在新版范例中这个类的定义：

```pascal
type
 TAnimal = class
 public
 constructor Create;
 function GetKind: string;
  function Voice: string; virtual; abstract;
 private
 FKind: string;
 end;
 TDog = class (TAnimal)
 public
 constructor Create;
 function Voice: string; override;
 function Eat: string; virtual;
 end;
 TCat = class (TAnimal)
 public
 constructor Create;
 function Voice: string; override;
 function Eat: string; virtual;
 end;
```

最有趣的部分是 TAnimal 类的定义，它包含了一个虚拟抽象方法: Voice。而每个子类都覆写了这个定义，并加入了一个新的虚拟方法:Eat 也很值得一看。这两个不同的功能是指什么呢?要调用 Voice 函数，我们可以用之前的范例程序中一样简单的写法:

`Show (FMyAnimal.Voice);`

那我们要怎么调用 Eat 方法呢?我们没办法从 TAnimal 类的对象来调用它，这个指令:

`Show (FMyAnimal.Eat);`

会导致编译器发出错误讯息: 无法识别的字段 (Field identifier expected)要解决这个问题，我们可以使用动态且安全的类型转换来 TAnimal 对象当成 TCat 或当成 TDog 对象来对待，但这样的作法相对繁复，而且容易出错：

```pascal
begin
 if MyAnimal is TDog then
 Show (TDog(MyAnimal).Eat)
 else if MyAnimal is TCat then
 Show (TCat(MyAnimal).Eat);
```

这段程序会在稍后的『安全的类型转换指令』那个小节里面介绍。在 TAnimal类里面加入虚拟方法的定义，是解决这个问题的传统方法，所有动物都会有『eat』这个方法，而 abstract 关键词的使用强化了这个选择。上面的源码看起来很杂乱，为了避免这样杂乱的源码出现，正是使用多型这个技术的用意。

最后请注意，当一个类拥有抽象方法时，这个类通常会被当成抽象类对待。我们也可以用 abstract 关键词来把某个类特地标注成抽象类，如果我们觉得有必要的话(当然，抽象类并不一定要拥有抽象方法)。重申一次，在Object Pascal 里面，这个功能不是要阻止我们为该类建立实体，所以这编程语言中，宣告没有用的抽象类是相当罕见的。

### 弥封类(Sealed	Classes)跟最终方法(Final	Methods) 

如同前面介绍过的，Java 预设对于延迟绑定(或说是虚拟方法)有着非常动态的功能。为了这个理由，Java 提出了一个概念，也就是无法再被继承的类(弥封类)，以及我们无法在子类中加以覆写的方法(最终方法，或者称为非虚拟方法)。

我们无法再从弥封类衍生出子类。这对于我们要发布不带原始码的组件时非常需要，或者我们需要发布限制开发人员修改我们组件功能的函数库时，也是非常重要的。这功能的原始设计也是为了提升运行时间的安全性，但这些功能我们在完全编译的编程语言，像 Object Pascal 里面，就不需要。最终方法是我们无法在衍生类中加以覆写的方法。重申一次，这个概念在Java(在 Java 里面所有方法预设都是虚拟方法，最终方法会很明显的得到优化)里面很有帮助，也被引入到 C#里面，因为 C#的虚拟函数需要精确标注，所以相对重要。因此同样的概念也被加入到跟 C#很相似的 Object Pascal 里面来了，但并不常被使用。

以下是弥封类的范例源码，请大家留意其语法：

```pascal
type
 TDeriv1 = class sealed (TBase)
 procedure A; override;
 end;
```

企图从这个类衍生子类的话，编译器会发出错误回报: “无法延伸弥封类 TDeriv1”。以下则是最终方法的语法：

```pascal
type
 TDeriv2 = class (TBase)
 procedure A; override; final;
 end;
```

从这个类衍生子类时，如果企图覆写 A 方法，也会得到编译器的错误回报:”无法覆写最终方法”。


## 安全的类型转换指令

一如稍早的篇幅所介绍的，Object Pascal 的子类类型兼容性规则让我们可以把子类当成父代类来使用，然而不能把父代类直接当成子类来使用。

现在我们假设 TDog 类拥有一个 Eat 方法，这个方法在 TAnimal 类里面并没有出现过。如果 MyAnimal 变量指向了 TDog 类的对象，那我们要怎么调用 Eat 方法呢? 如果我们试着把变量直接转型成另一个类，是会发生错误的。透过指令来进行的强制转型，我们可能会引发一个运行时错误(或者更糟，可能出现不预期的内存重复写入问题)，因为编译器无法判定该对象到底是哪种类型，且我们到底想调用哪个存在的方法。

为了解决这个问题，我们使用了运行时间类型信息(Run-Time Type Information, 简称 RTTI)。因为每个对象在运行时间一定都知道自己的类型，以及它自己的父代类。我们就直接询问对象这项信息，可以透过 is 这个指令，或者使用 TObject 类的一些方法。is 这个运算符号的参数是一个对象跟一个类类型，会回传布尔值：

```pascal
if FMyAnimal is TDog then
 ...
```

这个 is 判别式如果回传 true，就表示 FMyAnimal 对象目前是指向一个 TDog类的对象，或者是从与 TDog 兼容的类衍生出的类型。这代表如果我们检查存在 TAnimal 变量里的对象是 TDog 时，回传值就会是正确的。换句话说，如果回传值是 true，我们就可以安全的把这个对象(MyAnimal)指派给TDog 类型的变数了。

!!! note "笔记"
    is 这个运算符号实际上的实作方式，是由 TObject 的 InheritsFrom 方法所提供的。所以我们可以用在 FMyAnimal 对象上使用同样的判别式，写成FMyAnimal.InheritsFrom(TDog)。直接使用这个方法的原因，是因为这个方法也可以被类参考跟其他用途的类型所使用，且这些类型有可能不支持is 运算符号。

透过这个判断式，我们可以确定在 MyAnimal 里面的对象是 TDog 类的对象了，所以我们可以直接用类型强制转换(通常直接进行转换会有安全疑虑，但我们已经确认了类型是相同的，所以可以这样做)，写成以下的范例源码:

```pascal
if FMyAnimal is TDog then
begin
 MyDog := TDog (FMyAnimal);
 Text := MyDog.Eat;
end;
```

相同的动作也可以直接用另一个跟类型转换相关的运算符号 as 来达成。这个运算符号可以把对象进行转换，但只会在要求转换的对象兼容于想转换成为的类时才转换，否则就会发生运行时间例外而出现错误。As 运算符号的要求的参数是一个对象，以及要转换成为的类，回传的值则是转换成新类型之后的对象。我们可以简单的写成这样的源码：

```pascal
MyDog := FMyAnimal as TDog;
Text := MyDog.Eat;
```

如果我们只想调用 Eat 函数，我们也可以使用一个简单的写法:

`(FMyAnimal as TDog).Eat;`

这个表达式的回传结果，会是一个 TDog 类型的对象，所以您可以透过这个对象来使用 TDog 类的任何方法。在传统的类型转换跟 as 所呈现的类型转换之间的不同，是透过 as 进行类型转换的时候，会先进行该对象的类型兼容性检查，如果要转换的类型跟该对象不兼容，系统就会发出例外警告，这个例外是 EInvalidCast(我们在下一章里面会介绍)。

_____________________________________________________________________
!!! warning "警告"
    对照一下，在 C#里面的 as 表达式在类型不兼容的时候，会传回 nil，如果进行直接强制转型，发生不兼容的时候，则会产生例外事件。所以 C#跟Object Pascal 的 as 表达式在回传值上面刚好是相反的。

为了避免这个例外，请先使用 is 运算符号进行判别，如果类型是兼容的，就可以直接做强制转型(事实上好像没有必要把 is 跟 as 依序使用，因为这么一来相同的类型测试会做两次，所以通常不是使用 is，就是使用 as，很少两个并起来一起用的):

```pascal
if FMyAnimal is TDog then
 TDog(FMyAnimal).Eat;
```

两种类型转换的运算符号在 Object Pascal 里面都很有用，因为我们通常会想要撰写通用的源码，可以套用在不同的组件中，来进行相同类型检查，甚至是不同类型之间的检查。举例来说，当一个组件被当做参数传递到一个处理事件的方法时，会是使用通用的数据类(TObject)来传的。所以我们常常要先把类型转换回该组件的真正类型：

```pascal
procedure TForm1.Button1Click(Sender: TObject);
begin
 if Sender is TButton then
 ...
end;
```

这是一个很常见的技术，我也在很多之后的范例里面都会使用(事件会在第十章里面介绍到)。

这两个类型转换的运算符号，is 跟 as，功能是非常强大的，我们也可能会想要考虑在基本的程序撰写中用到它们。就因为它们真的很强大，所以在使用的时候要记得适当的在特定情形下规范使用的方法。当我们需要引入多个类来解决复杂的问题时，记得先使用多型的技术。只有在特别的情形下，多型才无法被单独使用，此时我们就只能试着透过类型转换运算符号来解决它了。

!!! note "笔记"
    类型转换运算符号在效能上会有明显的负面影响，因为它得把整个类的族谱跑一次，才能确实判别类型转换是否合法。跟我们介绍过的技术对照一下，虚拟方法的调用也需要进行内存搜寻，但相对快的多了。


## 可视化窗体继承

继承这个技术并不只用在函数库的类，或者我们自己写的类，但在整个以 Object Pascal 为中心的 IDE 环境里面，这个技术是无所不在的。一如我们所见的，当我们在 IDE 里面建立一个窗体的时候，我们其实是建立了一个 TForm 类的实体。所以任何可视化应用程序都是建立在继承这个技术之上的。因此我们在写程序的时候，大多是在写一些简单的事件处理程序。然而，对于比较有经验的开发人员来说，还比较不知道的作法，是我们可以从我们已经写好的窗体再衍生出另一个窗体，这个功能通常被称为视觉窗体继承(这也是 Object Pascal 开发环境中相当奇特的一部分)。

这个功能有趣的地方，是你可以直接看到继承的威力，而且可以直接了解他的规则。这既有用又实用吧?也是，这大多时候会跟我们正在建立的应用程序类型有关。如果应用程序里面有多个窗体，其中部分窗体可能很相似(外表很相似、功能也很相似)，这样一来我们就可以把这些相似的窗体做成一个基础窗体，事件处理程序也放在基础窗体里面，然后每个确切的窗体再从这个基础窗体衍生出来制作。另一个类似的情景，是使用可视化窗体继承的技术来为特定客户进行客制窗体，但不复制任何源码(这也是第一时间使用继承这个技术的核心理由)。


我们也可以使用可视化窗体继承来为同一个应用程序在不同操作系统的外观进行客制化跟窗体的元素(例如从手机到平板)，不复制任何源码，或者窗体的定义，只从标准的窗体为客户衍生出一个特定的版本。

请记得，视觉继承的主要优点，是我们可以稍后再修改原始窗体，且自动更新所有的衍生窗体。这是在 OOP 语言里面广为人知，关于继承的优点。但也有一个正面的副作用：多型。您可以为基础窗体加入一个虚拟方法，然后在衍生的窗体之中把它覆写。然后我们可以引入两个窗体，然后调用每个窗体的这个方法。

_____________________________________________________________________
!!! note "笔记"
    以相同元素建立窗体的另一个方法是透过 frame。这作法是把一些原本放在窗体上的视觉组件改为放在 frame 上面。在设计时间，我们可以同时处理两个版本的窗体。然而在视觉窗体继承中，我们是定义了两个不同的类，一个是父代类，另一个是衍生类。但使用 frame 十，我们则是新制作了一个 TFrame 的衍生类，以及用来承载 TFrame 的窗体类

### 从基础窗体进行继承

一旦我们对继承的内涵有了清楚的认知，管理视觉窗体继承的规则其实就相当简单。基本上，衍生的子窗体跟父代表单会有同样的视觉组件。我们不能移除父代表单上面的组件，不过我们可以把该组件(如果该组件是个视觉组件)设定成隐形。重要的是我们可以很容易更改继承后的组件属性。

请注意，如果我们更改了衍生窗体上组件的属性，之前在父代表单中对相同属性的修改，在衍生窗体中都将失去作用。变更组件的其他属性，则仍会影响衍生窗体中各组件的视觉表现。我们可以透过使用对象查看器上面的Revert to Inherited 这个选单指令，让两个属性的内容重新一致化。这样的效果也可以透过手动把两个属性的内容修改成一致之后，再重新编译器来达成。改变多个属性之后，我们仍然可以透过 Revert to Inherited 这个选单指令来把被变更的值回复成跟父代表单中的属性设定相同。

除了继承组件，新的窗体也继承了基础窗体的所有方法，包含事件处理程序。我们可以在衍生窗体中新增，也可以覆写已经存在的事件处理程序。

为 了 示 范 视 觉 窗 体 继 承 的 效 果 ， 我 建 立 了一个简单的 范 例 ， 名 为VisualInheritTest。我会逐步介绍如何编译这个项目。首先，建立一个新的多重装置应用程序项目、选择空白项目，然后在主窗体中加入两个按钮。然后选择 File->New->Others，接着在新增项目(New Items)的对话窗口中选择”Inheritable Items”分页(请参考图 8.3)。以下是我们可以从窗体来选择想要继承的项目。

图 8.3: New 项目对话窗口让我们可以建立一个衍生窗体


新的窗体会同样有两个按钮，以下是该窗体最开头的文字描述：

```pascal
inherited Form2: TForm2
 Caption = ‘Form2’
 ...
end
```

且以下是该类刚建立时的宣告内容，我们可以看到其基础类不是我们常见的 TForm，而是一个实际的基础类窗体了：

```pascal
type
TForm2 = class(TForm1)

 private
 { Private declarations }
 public
 { Public declarations }
 end;
```

请注意 inherited 关键词在文字描述的使用，还有窗体实际上是拥有其他组件的，只是它们是被定义在基础类里面而已。如果我们改掉了其中一个按钮的文字，并且加上一个新的按钮，窗体的文字描述就会变成这样：

```pascal
inherited Form2: TForm2
 Caption = 'Form2'
 ...
 inherited Button1: TButton
 Text = 'Hide Form'
 end
 object Button3: TButton
 ...
 Text = 'New Button'
 OnClick = Button3Click
 end
end
```

只有属性的值不同的项目被列出了，因为其他的项目都是从基础窗体直接继承而来的。

图 8.4: VirtualInheritTest范例在运行时间的两个窗体

第一个窗体中的每一个按钮都有 onClick 事件处理程序，请参考范例程序。

第一个按钮被点击时，会调用 Show 方法来显示出第二个窗体，第二个按钮被点击时则是显示简单的讯息。

在衍生窗体中发生了什么事？我们首先要改变 Show 按钮的规则，让它变成一个隐藏按钮。这样就不会执行基础窗体的事件处理程序了(所以我也把预设调用的 inherited 源码给批注掉了)。相反地，我在 Hello 按钮上加入了第二个讯息给基础类建立出来的窗体，这个函数只留下了 inherited 调用：

```pascal
procedure TForm2.Button1Click(Sender: TObject);
begin
 // inherited;
 Hide;
end;
procedure TForm2.Button2Click(Sender: TObject);
begin
 inherited;
 ShowMessage ('Hello from Form2');
end;
```

记得这跟衍生方法的差异，衍生方法可以使用 inherited 关键词来调用衍生类中的同名方法，在事件处理程序里面使用 inherited 关键词则会调用基础类中对应的同名方法。

当然，我们也该把基础窗体中的每个方法视为子窗体的方法，并且视需要自由调用它们。这个范例允许我们了解一些可视化窗体继承的功能，但要真正看到它的威力，我们需要多看一些复杂的，真实世界的范例，而不要被绑死在书上喔。
Object Pascal 所提供的强型别检查对于提升源码的正确性是很有效的，这也是我在本书中不断提到的。强型别的检查有时候也很烦，就像有时候我们想要写一个程序，让这个程序可以处理不同数据型别或类别。这个议题已经被 Object Pascal 纳入成为功能之一，就像 C#, Java 这些相似的语言一样，我们称之为泛型(Generics)。

泛型的概念，或者用 C++的名词来说，叫做类别样板(template classes)。我在 1994 年所著，关于 C++的书里面有写道:

> 我们可以宣告一个类别，其中的一个或多个数据成员不特别指定使用哪种型别：这个型别的指定可以延迟到当我们需要定义该类别的变量时才来决定。我们在定义函数的时候也可以用相似的作法，不在撰写的函数的时候定义一个或多个参数的型别，直到该函数要被调用的时候才来指定。

!!! note "笔记"
    这本书的书名是”Borladn C++ 4.0 Object-Oriented Programming”，由 Marco Cantu 和 Steve Tendon 合着，在 1990 年代前期出版。


## 通用的键-值对 (Key-Value	Pairs) 424

本章的第一个范例就用一个很常见的类别，我实作了一个键-值对的数据结构。以下第一个程序片段，就是用传统的写法来建立这个数据结构，透过一个对象来储存数据的数值：

```pascal
type
 TKeyValue = class
 private
 FKey: string;
 FValue: TObject;
 procedure SetKey(const Value: string);
 procedure SetValue(const Value: TObject);
 public
 property Key: string read FKey write SetKey;
 property Value: TObject read FValue write SetValue;
  end;
```

要使用这个类别，我们可以建立一件对象，设定它的键与值，然后使用它，就像下列的源码，节录自 KeyValueClassic 范例项目的主窗体中的几个方法：

```pascal
// FormCreate
Kv := TKeyValue.Create;
// Button1Click
Kv.Key := 'mykey';
Kv.Value := Sender;
// Button2Click
Kv.Value := Self; // The form
// Button3Click
ShowMessage('[' + Kv.Key +',' + Kv.Value.ClassName + ']');
```

要是我们需要一个类似的类别，储存的是整数，而不是对象呢?好吧，我们也可以自己把整数作强制型别转换(这么做，出错的风险很高的)，或者建立一个新的类别，储存字符串键以及整数值。或许直接剪贴源码，然后修改里面的一部分也是种解决方法，最后我们就会有两段源码基本上完全一样，这样做，我们就抵触了良好程序设计的原则之一，而且我们以后如果发现源码里面有问题，就得同时改两次源码，如果复制三次，就要改三次，如果复制 20 次呢…… 那就烦死了。

泛型让我们可以对上例中的值的定义变得比较有弹性，而只要写一个泛型类别即可。一旦我们对键-值泛型类别进行了初始化，它就变成了特定的类别，直接跟特定的型别进行连结了。所以我们可以透过同样的作法，在我们的应用程序里面让这个类别宣告分别跟两种、三种，甚至 20 种型别进行连结，但类别的源码还是同一份，只是在变量或者属性宣告的时候，指定这个类别要跟哪一种数据型别进行链接。这样就不会在执行时期产生多余的动作了。让我们接着做，开始为我们成对的键-值，定义一个泛型类别：

```pascal
type
 TKeyValue<T> = class
 private
 FKey: string;
 FValue: T;
 procedure SetKey(const Value: string);
 procedure SetValue(const Value: T);
  public
 property Key: string read FKey write SetKey;
 property Value: T read FValue write SetValue;
 end;
```

在上述的类别定义里，有一个尚未明确定义的型别，以字母 T 来代表。字母 T 在很多语言中都被使用来当做泛型类别中的符号，但我们可以在源码中用任何我们喜欢的字眼来代表泛型的类别或型别。使用 T 这个字母，是为了增加程序的可读性，泛型类别只是用这个符号来表示这个符号出现的地方，未来会以参数指定的型别来进行替换。如果类别中要进行泛型处理的地方有很多个，我们在实务上就会用它的角色来为这个代号进行命名，不用多个字母来代表(T, U, V)，这种方法是早期 C++里面的写法。

!!! note "笔记"
    T 已经是通用的不成文写法，因为 C++语言在 1990 年代前期提出样板(template)这个概念的时候，就直接以 T 来表示样板。当时作者是要用 T 来表示样板(template)还是型别(Type)，目前已不可考。这样的转换在 Delphi的世界里运作完美，型别只要以 T 字母开头即可，用 T 来表示 Type 是很有意义的作法。

泛型类别 TKeyValue<T>使用了尚未明确定义的型别作为它储存的两个数据字段之一、属性的值，以及设定方法(setter)的参数。方法的源码则很平常，但要注意到这当中也是使用了泛型型别，它们的定义包含了该类别的完整名称，包含泛型型别：

```pascal
procedure TKeyValue<T>.SetKey(const Value: string);
begin
 FKey := Value;
end;
procedure TKeyValue<T>.SetValue(const Value: T);
begin
 FValue := Value;
end;
```

然而要使用这个类别时，我们就得完整的写出真正的型别了，必须提供实际的数据型别作为泛型型别。例如我们可以宣告一个键-值对象把按钮作为类别中储存的值，可以这样写:

```pascal
var
Kv: TKeyValue<TButton>;
```

在建立实体的时候，也需要写出完整的名字，因为这已经是确切的型别了(泛型型别中尚未实体化的型别名称看起来则像是一个型别建构机制)。

在键-值对当中使用尚未明确定义的型别来定义值的字段，会使得源码更能有弹性，我们现在只用了 TButton 来当做储存的值的字段，当然 TButton的所有衍生类别对象也都可以存在这里面，我们也可以在解析出值字段的对象之后，使用该对象的各种方法。

以下的程序片段节录自 KeyValueGeneric 范例项目的主窗体：

```pascal
// FormCreate
Kv := TKeyValue<TButton>.Create;
// Button1Click
Kv.Key := 'mykey';
Kv.Value := Sender as TButton;
// Button2Click
Kv.Value := Sender as TButton; // was "Self" but that is now invalid!
// Button3Click
ShowMessage ('[' + Kv.Key + ',' + Kv.Value.Name + ']');
```

在前一版的源码里面，要指派泛型对象的时候，我们可以指派一个按钮或者窗体，但现在只能储存按钮了，这也适用了编译器的强型别规则。但在泛型类别里面，输出字符串 kv.value.ClassName 则可以适用于所有型别，因为组件的Name或者TButton类别的任何方法或属性我们都可以在源码中使用。

当然我们也可以稍微改动一下原始程序中宣告键-值对的定义：

```pascal
var
Kvo: TKeyValue<TObject>
```

这样修改后，我们就可以把任何对象当成值的字段加以储存了。然而，我们就不能对解析出来的对象作太多动作，除非我们先把该对象转型成特定的型别。为了找到一个比较好的平衡点，我们可能会想要在特定的按钮跟任何对象之间找个介于中间的型别，例如说让储存的值只允许视觉组件:

```pascal
var
Kvc: TKeyValue<TComponent>;
```

对应的源码在 KeyValueGeneric 范例项目里面也有。最后，我们也可以建立一个储存一般数据的键-值对类别的实体，不让它储存任何对象，而是储存整数值:

```pascal
var
 Kvi: TKeyValue<Integer>;
begin
 Kvi := TKeyValue<Integer>.Create;
 try
 Kvi.Key := 'Object';
 Kvi.Value := 100;
 Kvi.Value := Left;
 ShowMessage ('[' + Kvi.Key + ',' +
 IntToStr (Kvi.Value) + ']');
 finally
 Kvi.Free;
 end;
```

### 行内变数与泛型型别推定

当我们宣告了一个泛型型别的变量，这个宣告可能写很长。当我们用这个型别建立一个对象时，我们也必须重复相同的宣告，除非我们运用行内变量宣告与这功能的便利，让该变量的型别可以直接被推定，上一个范例源码的宣告就可以改写为:

```pascal
begin
 var Kvi := TKeyValue<Integer>.Create;
 try
 …
```

在这段源码里面，我们就不用重复写两次完整的泛型类型声明，对我们需要使用容器类别的时候方便许多，我们稍后再介绍。


### 泛型的型别规则

当我们宣告了一个泛型型别的实体，这个型别就固定下来了，同时在后续的所有动作中，就会被编译器视为确定型别，所以如果我们有个泛型类别是像这样的:

```pascal
type
 TSimpleGeneric<T> = class
 Value: T;
 end;
```

当我们为这个类型声明特定的对象时，我们在 Value 字段就不能指派跟宣告时不同型别的数据了。以下面两个对象为例，以下的部份指派就是不合法的(以下节录自 TypeCompRules 范例项目):

```pascal
var
 Sg1: TSimpleGeneric<string>;
 Sg2: TSimpleGeneric<Integer>;
begin
 Sg1 := TSimpleGeneric<string>.Create;
 Sg2 := TSimpleGeneric<Integer>.Create;
 Sg1.Value := 'Foo';
 Sg1.Value := 10; // Error
 // E2010 Incompatible types: 'string' and 'Integer'
 Sg2.Value := 'foo'; // Error
 // E2010 Incompatible types: 'Integer' and 'string'
 Sg2.Value := 10;
```

一旦我们在泛型的宣告中确定了特定的型别，编译器就已经确定了要检查的型别，我们的源码就必须要遵循 Object Pascal 的强型别规则了。型别检查也会把泛型对象当成一个特殊的型别。当我们把泛型类别指定了特定的型别，我们就不能把指定另一个型别的泛型类别对象指派到不同泛型类别的变量了。只看文字说明很容易昏头，还是看一下源码，比较容易厘清内容:

```pascal
Sg1 := TSimpleGeneric<Integer>.Create; // Error
// E2010 Incompatible types:
// 'TSimpleGeneric<System.string>'
// and 'TSimpleGeneric<System.Integer>'
```

我们接下来会在”泛型型别兼容性规则”这一节里面用明确的案例，指出型别兼容性规则是以结构检查，而不是以型别名称检查。我们不能在泛型型别已经确认了特定型别之后，又指派一个不同的、不相容的型别给一个泛型型别。


## Object	Pascal 里面的泛型

在前一个范例里，我们已经看过了如何在 Object Pascal 里面定义、使用泛型型别。我决定在深入到技术概念前，先用范例来介绍这个功能。因为泛型的技术概念相当复杂，也相当重要。从编程语言的观点看完泛型之后，我们再回头多看几个范例，包含了定义、使用泛型容器类别，这是 Object Pascal 里面主要使用这个技术的地方之一。

我们已经介绍过，当我们定义一个类别的时候，可以加入额外的参数，使用尖括号把特定的型别括起来即可:

```pascal
type
 TMyClass<T> = class
 ...
 end;
```

泛型型别可以用来当做数据字段的型别(就像我们在前一个例子里面介绍的)、当做属性的型别、或者作为参数的型别，甚至是一个函数的回传型别，还可以用在更多地方。请注意，对一个区域字段(或者数组)使用这个型别并不是一种义务，有些情境下，泛型型别只用在作为回传值、参数，不能用在类别的宣告上，但可以用来定义类别的某些方法。

这种形式的延伸或泛型型别的宣告，不只是能对类别使用，也能用在记录上面(我们在第五章介绍过，记录也可以有方法、属性、覆写的运算方法)。泛型类别也可以有多个参数化的型别，我们用下面的源码作范例，让大家可以了解怎么在泛型的宣告中用上两个型别当成参数，一个当成方法的参数，另一个则是回传值的型别:

```pascal
type
 TPWGeneric<TInput,TReturn> = class
 public
 function AnyFunction (Value: TInput): TReturn;
 end;
```

Object Pascal 里面对泛型的实作，跟其他静态编程语言一样，并不是基于执行时期的支持。这个功能是由编译器跟链接程序来处理的，在运行时间的机制几乎完全没有作什么事。跟虚拟函数的调用不同，虚拟函数是在执行时期进行绑定，而泛型类别的方法则是在我们定义出完整的泛型型别实体时就被建立了，而且是在编译时建立的！我们将会看到这个功能可能的缺陷，但正面来看这个问题，它让我们知道泛型类别比一般类别的效率来的好，甚至连执行时期的检查所需的动作都省下了。在我们深入看到这些问题前，我们先来看些很明确的规则，这些规则打破了传统 Pascal 语言的型别兼容规则。


### 泛型型别兼容性规则

在传统的 Pascal 语言跟 Object Pascal 的核心型别兼容性规则都是基于型别名称是否一致。换句话说，两个变量的型别如果兼容，这两个型别的名称一定是一样的，不管两个型别里面实际上是怎么储存数据或定义方法的。

以下是一个静态数组间型别不兼容的传统例子(节录自 TypeCompRules 范例项目):

```pascal
type
 TArrayOf10 = array [1..10] of Integer;
procedure TForm30.Button1Click(Sender: TObject);
var
 Array1: TArrayOf10;
 Array2: TArrayOf10
 Array3, array4: array [1..10] of Integer;
begin
 Array1 := Array2;
 Array2 := Array3; // Error
 // E2010 Incompatible types: 'TArrayOf10' and 'Array'
 Array3 := Array4;
 Array4 := Array1; // Error
 // E2010 Incompatible types: 'Array' and 'TArrayOf10'
end;
```

我们可以从上面的源码看到，四个数组在结构上是完全相同的。然而编译器只会让我们对型别兼容的数组进行指派。兼容的规则是必须型别名称完全相同(两个变量的型别都是 TArrayof10)，或者根本就是同一个型别(array3, array4 直接是宣告在同一行变量的宣告上)。

这个型别兼容性规则是很有局限性的例外，就像衍生类别的相关性。这个规则的另一个例外，而且是很明显的例外，就是泛型型别的型别兼容性，这个情境也只会发生在编译器内部使用上，编译器会自行决定是否要位这个泛型型别建立一个新的内部型别，套用在该型别所有出现的地方。

新规则会界定泛型型别如果使用的是同样的泛别类别，且在定义时使用同样的实体型别，就视为相同的型别，不管在定义时，型别的名称是否相同。换句话说，泛型型别实体的全名会是泛型型别跟实体型别的组合。

在以下的范例中，四个变量就是完全型别兼容的：

```pascal
type
 TGenericArray<T> = class
 AnArray: array [1..10] of T;
 end;
 TIntGenericArray = TGenericArray<Integer>;
procedure TForm30.Button2Click(Sender: TObject);
var
 Array1: TIntGenericArray;
 Array2: TIntGenericArray;
 Array3, array4: TGenericArray<Integer>;
begin
 Array1 := TIntGenericArray.Create;
 Array2 := Array1;
 Array3 := Array2;
 Array4 := Array3;
 Array1 := Array4;
end;
```

### 标准类别的泛型方法

使用泛型型别来定义类别是最常见的情境，泛型型别也可以用在非泛型的类别中。换句话说，一般的类别也可以有泛型方法。在这个情形下，我们不用在泛型符号出现的位置指定特定的型别，等到调用时再处理即可。以下就是一个简单的泛型方法的例子，节录自 GenericMethod 范例项目:

```pascal
type
 TGenericFunction = class
 public
 function WithParam <T> (t1: T): string;
  end;
```

_____________________________________________________________________
!!! note "笔记"
    当我第一次撰写上面这个源码的时候，或许是怀念以前 C++的日子吧，我把参数写成了(t: T)。不用特别说，Object Pascal 的语法是不分大小写的，在所有不分字母大小写的编程语言里面，这样的写法都是不合法的。编译器会指出上面两个 t 是无法辨识的……

我们没办法在类似的类别方法内部中作太多处理(至少在我们使用特定限制之前，我们会在下一章里面介绍)，所以我用特殊的泛型函数(稍后会介绍)写了一些源码来把这个型别转换成字符串，我们来看一下:

```pascal
function TGenericFunction.WithParam<T>(T1: T): string;
begin
 Result := GetTypeName (TypeInfo (T));
end;
```

我们可以看到这个方法没有使用任何实际的值当做参数，只要求一些型别信息。在还不知道 T1 的型别之前，让写这段程序的时候相对变得很复杂。我们可以用以下各种参数来调用这个『全局泛型函数』，可以使用的版本非常多:

```pascal
var
 GF: TGenericFunction;
begin
 GF := TGenericFunction.Create;
 try
 Show (GF.WithParam<string>('Foo'));
 Show (GF.WithParam<Integer> (122));
 Show (GF.WithParam('Hello'));
 Show (GF.WithParam (122));
 Show (GF.WithParam(Button1));
 Show (GF.WithParam<TObject>(Button1));
 finally
 GF.Free;
 end;
```

以上所有调用这个函数的写法都是正确的，参数化的型别在这些调用的源码里面是暗中传递的。注意到泛型型别是被明确指定的，但参数的型别并没有被指定，所以我们会看到以下的执行结果:

```
string
Integer
string
ShortInt
TButton
TObject
```

如果我们在调用这个方法的时候没有在尖括号中指定型别，实际的型别就会从该参数的型别来指定。如果我们用一个型别、一个参数来调用这个方法，参数的型别就必须跟泛型型别的宣告一致。所以以下三行就无法被编译了:

```pascal
Show (Gf.WithParam<Integer>('Foo'));
Show (Gf.WithParam<string> (122));
Show (Gf.WithParam<TButton>(Self));
```

### 泛型型别实体化

请注意，这一节的主题是比较进阶的，我们会介绍泛型的内部运作机制跟它的潜在优化方式。如果您对泛型已经有研究过，第二次读到这一节，也会对您很有帮助。

因为一些优化的例外，每次我们在为泛型型别实体化的时候，不管是泛型方法或是泛型类别，编译器都会产生一个新的型别。这个新的型别在同一个泛型型别的不同实体(或者是同一个方法的不同版本)之间是不会共享源码的。

我们来看一个范例(节录自 GenericCodeGen 范例项目)。在这个程序中定义了一个泛型类别，定义如下:

```pascal
type
 TSampleClass <T> = class
 private
 FData: T;
 public
 procedure One;
 function ReadT: T;
 procedure SetT (Value: T);
 end;
```

这三个方法的实作源码如下(请注意到 One 方法是绝对跟泛型型别独立的):

```pascal
procedure TSampleClass<T>.One;
begin
 Form30.Show ('OneT');
end;
function TSampleClass<T>.ReadT: T;
begin
 Result := FData;
end;
procedure TSampleClass<T>.SetT(Value: T);
begin
 FData := Value;
end;
```

这个主程序当中使用了泛型型别要把它的方法被实体化时(这个动作会由编译器来处理)内存内的地址厘清。以下是它的源码:

```pascal
procedure TForm30.Button1Click(Sender: TObject);
var
 T1: TSampleClass<Integer>;
 T2: TSampleClass<string>;
begin
 T1 := TSampleClass<Integer>.Create;
 T1.SetT (10);
 T1.One;
 T2 := TSampleClass<string>.Create;
 T2.SetT ('Hello');
 T2.One;
 Show ('T1.SetT: ' +
 IntToHex (PInteger(@TSampleClass<Integer>.SetT)^, 8));
 Show ('T2.SetT: ' +
 IntToHex (PInteger(@TSampleClass<string>.SetT)^, 8));
 Show ('T1.One: ' +
 IntToHex (PInteger(@TSampleClass<Integer>.One)^, 8));
 Show ('T2.One: ' +
 IntToHex (PInteger(@TSampleClass<string>.One)^, 8));
end;
```

执行结果如下(实际的数值每次都不会一样):

```
T1.SetT: C3045089
T2.SetT: 51EC8B55
T1.One: 4657F0BA
T2.One: 46581CBA
```

如我所预期的，编译器不只在内存里面为每一种数据型别的 SetT 方法都建立了不同的版本，就连 One 方法也是如此，尽管事实上各版本的 One 方法都是一模一样的。

不仅如此，如果我们重复宣告了一个完全相同的泛型型别，我们也会得到另一组新的实作函数。同样的，一个泛型型别的相同实作型别，在不同的单元文件里面被使用时，也会强迫编译器一再产生相同的源码，而可能会导致建立出的执行档明显变得很大。为了这个原因，如果我们要建立一个内含很多个方法的泛型类别，而这些方法跟泛型的型别没有什么关系的话，我会建议把这些方法定义在一个非泛型的类别里面，然后以这个非泛型的类别衍生一个需要使用到泛型型别的泛型类别：透过这个方法来实作，基础类别的方法就只会被编译器产出一次，执行档也就不会太大了。

_____________________________________________________________________
!!! note "笔记"
    在目前的编译器、链接程序、以及低阶 RTL 里面有些功能，用来缩减因为使用泛型而导致档案变大的状况，这些状况刚刚我们有提到过了。目前这些功能可以从一些网络上的文章阅读中稍微了解一下:http://delphisorcery.blogspot.it/2014/10/new-language-feature-in-xe7.html


### 泛型型别函数

目前我们在看泛型型别定义的最大问题，就是我们能对泛型类别型别的元素所做的非常少。我们可以用两个科技来降低这个限制。第一项就是使用在 RTL 里面特别用来支持泛型的特殊函数。第二项(也更有效)则是在泛型类别可以使用的类别上面作限制。

这一节我们将聚焦在第一项上面，下一节再来介绍使用上的限制。我们刚提到过，在 RTL 里面有一些函数是可以用来对泛型型别定义中的参数化型别进行处理的:

+ Default(T)是一个和泛型功能一起出现的新函数，如果我们传入了任何一个非泛型的型别，它会回传空值，或 0，或 null，回传值可以是 0、空字符串、nil 等等。以 0 清除过的内存对同一种型别的全局变量也会有一样的值(跟局部变量不同，事实上，全局变量会被编译器以 0 作初始化)
+ TypeInfo(T)回传目前这个泛型型态在运行时间的指针，我们会在第十六章里面介绍更多关于型别信息的相关数据。
+ SizeOf(T)会以 Byte 数回传该型别里面所使用的内存大小(如果 T 是对象或是字符串的话，这个回传值就是每个内存地址的大小，在 32 位系统中会回传 4 bytes, 64 位则回传 8 bytes)。
+ IsManagedType(T)会告诉我们该型别在内存中是否是受管理的，如果是字符串或者动态数组的话，回传值就会是 true.
+ HasWeakRef(T)，这个函数是跟支持 ARC 的编译器相关的，会回传一个内存参考是否为弱参考，需要特定的内存管理支持。
+ GetTypeKind(T)：是让我们能够从型别信息中取得型别种类的快捷方式，这个回传值比 TypeInfo 所回传的型别定义来的更高阶。

!!! note "笔记"
    以上这些方法所回传的，都是编译器处理过的常数，而不是在运行时间中实际调用什么函数所响应的值。重要的不是这些处理很快，而是让编译器跟链接程序可以对产出的源码进行优化，把没有使用到的源码移除。如果我们打算用这些函数的回传值来进行判断，编译器会发现判断式(if..else)其中的一段源码会被执行，而会自动移除掉没有被使用到的那一段。当相同的泛型方法被指定不同的型别，在编译时就会使用不同的判断状况，但要记得，源码都会先被产生，在优化的时候才有这些处理。

在GenericTypeFunc范例项目中有一个泛型类别，会显示三个泛型型别函数:

```pascal
type
 TSampleClass <T> = class
 private
 FData: T;
 public
 procedure Zero;
 function GetDataSize: Integer;
 function GetDataName: string;
 end;
function TSampleClass<T>.GetDataSize: Integer;
begin
 Result := SizeOf (T);
end;
function TSampleClass<T>.GetDataName: string;
begin
 Result := GetTypeName (TypeInfo (T));
end;
procedure TSampleClass<T>.Zero;
begin
 FData := Default (T);
end;
```

在 GetDataName 方法中，我使用了 GetTypeName 函数(宣告在 TypeInfo 单元文件里面)，而不是直接存取数据结构，因为这样会从储存型别名称的已编码字符串进行适当的转换

因为有上述的宣告，我们可以把下列的测试源码进行编译，它会重复三次，使用三个不同的泛型型别实体。我就省略了重复的源码，只显示用来存取data 字段的程序，它们会依照实际型别来进行内容变更：

```pascal
var
 T1: TSampleClass<Integer>;
 T2: TSampleClass<string>;
 T3: TSampleClass<double>;
begin
 T1 := TSampleClass<Integer>.Create;
 T1.Zero; Show ('TSampleClass<Integer>');
 Show ('Data: ' + IntToStr (T1.FData));
 Show ('Type: ' + T1.GetDataName);
 Show ('Size: ' + IntToStr (T1.GetDataSize));
 T2 := TSampleClass<string>.Create;
 ...
 Show ('Data: ' + T2.FData);
 T3 := TSampleClass<double>.Create;
 ...
 Show ('Data: ' + FloatToStr (T3.FData));
```

执行上面这段源码(节录自 GenericTypeFunc 范例项目)，结果如下:

```
TSampleClass<Integer>
Data: 0
Type: Integer
Size: 4
TSampleClass<string>
Data:
Type: string
Size: 4
TSampleClass<Double>
Data: 0
Type: Double
Size: 8
```

请注意，我们也可以对指定的型别使用泛型型别函数，在泛型类别的内容之外，例如可以这样写:

```pascal
var
 I: Integer;
 s: string;
begin
 I := Default (Integer);
 Show ('Default Integer': + IntToStr (I));
 s := Default (string);
 Show ('Default String': + s);
 Show ('TypeInfo String': + GetTypeName (TypeInfo (string));
```

结果很直觉，当然就是:

```
Default Integer: 0
Default String:
TypeInfo String: string
```

_____________________________________________________________________
!!! note "笔记"
    我们不能直接对变量进行 TypeInfo 调用，例如上面的 TypeInfo(s)，这个调用的参数只能是一个型别。

### 泛型类别的类别建构函数

有个很有趣的例子，就是为泛型类别定义一个类别建构函数。事实上，这样的建构函数是由编译器所建立，并由每一个泛型类别的实体所调用的，也就是说，每一个实际的型别被定义时，都使用了泛型样板。这一点就相当有趣了，因为这会让我们的程序在不使用类别建构函数来建立每个泛型类别实体的时候，初始化程序的源码变得相当复杂。

举个例子，想象一下内含一些类别数据的泛型类别。我们只会取得一个类别数据的实体，共享于每一个泛型类别实体上。如果我们需要为这个类别数据进行初始化，指派一个初始值给它，我们就不能透过单元文件的初始区来做这个事情，因为我们并不知道这个类别实际上会使用哪个型别来宣告泛型类别。

以下是一个最简单的范例，范例中，泛型类别里包含有类别建构函数，用来为 DataSize 这个类别数据字段进行初始化，节录自 GEnericClassCtor 范例项目:

```pascal
type
 TGenericWithClassCtor <T> = class
 private
 FData: T;
 procedure SetData(const Value: T);
 public
 class constructor Create;
 property Data: T read FData write SetData;
 class var
 DataSize: Integer;
 end;
```

接下来是这个泛型类别建构函数的源码，用了一个内部的字符串列表(请看完整的实作区源码)来追踪哪一个类别建构函数有被调用到:

```pascal
class constructor TGenericWithClassCtor<T>.Create;
begin
 DataSize := SizeOf (T);
 ListSequence.Add(ClassName);
end;
```

这范例程序建立了，也使用了几个泛型类别的实体并宣告了第三个数据型别，这地三个资料型别则会被链接程序移除掉:

```pascal
var
 GenInt: TGenericWithClassCtor <SmallInt>;
 GenStr: TGenericWithClassCtor <string>;
type
 TGenDouble = TGenericWithClassCtor <Double>;
```

如果我们要求程序显示 ListSequence 的内容，我们只会看到已经被初始化的型别名字:

```pascal
TGenericWithClassCtor<System.SmallInt>
TGenericWithClassCtor<System.string>
```

然而，如果我们用相同的数据型别在不同的单元文件里面建立了泛型实体，链接程序就不会如预期中那样运作，我们会看到同一个型别有多个泛型类别建构函数。

!!! note "笔记"
    类似的程序并不容易界定。为了避免重复进行初始化，我们可能会想要检查类别建构函数是否已经被执行过。通常这个问题对于泛型类别来说，是全面性的限制当中的一个，而链接程序并没有能力对这情形加以优化。

我在本范例的第二个单元文件当中加入了一个名为 Useless 的程序，当我们取消这些源码的批注状态时，编译器就会标明这些源码有问题，当初始的顺序如下:

```pascal
TGenericWithClassCtor<System.string>
TGenericWithClassCtor<System.SmallInt>
TGenericWithClassCtor<System.string>
```

## 泛型守则 (Generic	Constraints)

我们已经看过，在泛型类别中，我们能对泛型型别的值所做的处理很少。我们可以把它传过来传过去，或是对它进行我们已经介绍过的型别处理中的任何一项。

要能够对泛型类别的型态作更确切的动作，我们通常必须给它一些守则才行。例如如果我们规定泛型类别必须是一个类别，编译器就会让我们透过它来使用 TObject 的方法。我们也可以进一步规范该类别必须是类别架构中的特定部分，或者一定要实作特定的接口，这样我们才可能透过泛型类别的实体调用特定的方法。

### 类别守则 (Class	Constraints)

最简单的守则就是我们要求该型别必须是一个类别，我们可以这么写，来达到这个守则：

```pascal
type
TSampleClass <T: class> = class
```

透过特定的类别守则，我们可以指定只有哪些对象型别可以作为泛型型别。以下的源码就可以作为例子(节录自 ClassConstraint 范例项目):

```pascal
type
 TSampleClass <T: class> = class
 private
 FData: T;
 public
 procedure One;
 function ReadT: T;
 procedure SetT (t: T);
 end;
```

我们可以用前两个指令成功建立出泛型实体，但第三个指令就不行了：

```
sample1: TSampleClass<TButton>;
sample2: TSampleClass<TStrings>;
sample3: TSampleClass<Integer>; // Error
```
编译器会指出第三个指令有错，错误讯息为:

`E2511 Type parameter 'T' must be a class type`

指定这个限制的好处是什么?在泛型类别方法中，我们现在已经可以使用TObject 的任何一个方法了，包含虚拟方法喔！以下就是 TSampleClass 泛型类别的方法 One 的源码:

```pascal
procedure TSampleClass<T>.One;
begin
 if Assigned (FData) then
 begin
 Form30.Show ('ClassName: ' + FData.ClassName);
 Form30.Show ('Size: ' + IntToStr (FData.InstanceSize));
 Form30.Show ('ToString: ' + FData.ToString);
 end;
end;
```

!!! note "笔记"
    这里我们有两个建议。第一个是 InstanceSize 会回传该对象的实际大小，跟我们刚用过的 SizeOf 泛型函数不同，SizeOf 会回传参考型别的大小。其次，要留意到我们如何使用 TObject 类别的 ToString 方法。

我们可以执行个几次，玩玩看这个程序，看一下实际的效果，在源码中我们定义了几个不同的泛型型别实体，就像这段程序片段:

```pascal
var
 Sample1: TSampleClass<TButton>;
begin
 Sample1 := TSampleClass<TButton>.Create;
 try
 Sample1.SetT (Sender as TButton);
 Sample1.One;
 finally
 Sample1.Free;
 end;
```

请注意到透过宣告一个具有客制化过的 ToString 方法的类别，这个版本会在数据对象的型别确定的时候被调用，不管实际上是什么型别被指派给泛型型别。换句话说，如果我们建立了一个以 TButton 为类别的泛型类别实体：

```pascal
type
 TMyButton = class (TButton)
 public
 function ToString: string; override;
end;
```

我们可以把这个对象当成 TSampleClass<TButton>型别的对象，或者作为一个特定泛型型别的实体。在两种情形下，One 方法都会调用到 ToString 这个特别版本的方法:

```pascal
var
 Sample1: TSampleClass<TButton>;
 Sample2: TSampleClass<TMyButton>;
 Mb: TMyButton;
begin
 ...
 Sample1.SetT (Mb);
 Sample1.One;
 Sample2.SetT (Mb);
 Sample2.One;
```

跟类别守则一样，我们也可以建立记录守则，例如这样宣告:

```pascal
type
 TSampleRec <T: record> = class
```

然而，这跟大多数的记录并没有太多的不同(并没有共同的基础类别)，所以这个宣告相对的没有太多的新功能。


### 特定的类别守则

如果我们的泛型类别需要跟特定的类别子集一起运作(特定的类别继承结构树)，我们可能会想要以特定的基础类别进行泛型类别守则，例如我们可能会想要这样宣告:

```pascal
type
 TCompClass <T: TComponent> = class
```

这个泛型类别的实体只容许组件类别，也就是 TComponent 的任一个衍生类别。这让我们的泛型类别变得很确切(对，听起来很奇怪，但它的确很奇怪)，而且编译器会让我们在这个泛型类别的实体当中使用 TComponent 的所有方法。

如果这看起来很棒，再多想一下。如果我们考虑到要达成继承的目标与型别兼容性规则，我们可能会指出使用传统面向对象技术的相同问题，而不会使用泛型类别了。我不是说特定的类别守则完全没用，但它显然不如高阶的类别守则或(我发现这个还蛮有趣的)以接口为基础的守则那么强大。



### 接口守则

不限制泛型类别只能使用特定的类别，改以限制只能使用有实作特定接口的类别，可以透过参数型别的开放性来达成泛型类别的通用性。这使得我们可以在泛型赢别的实体当中调用特定接口的方法。在泛型上使用接口守则在 C#编程语言是很常见的。我们用一个例子作为开场白(节录自IntfConstraint 范例项目)。首先，我们得先宣告一个接口：

```pascal
type
 IGetValue = interface
 ['{60700EC4-2CDA-4CD1-A1A2-07973D9D2444}']
 function GetValue: Integer;
 procedure SetValue (Value: Integer);
 property Value: Integer read GetValue write SetValue;
 end;
```

接着我们可以定义一个实作它的类别:

```pascal
type
 TGetValue = class (TSingletonImplementation, IGetValue)
 private
 fValue: Integer;
 public
 constructor Create (Value: Integer = 0);
 function GetValue: Integer;
 procedure SetValue (Value: Integer);
 end;
```

在定义限制使用有实作特定接口的泛型类别时，就开始有趣了：

```pascal
type
 TInftClass <T: IGetValue> = class
 private
 FVal1, FVal2: T; // or IGetValue
 public
 procedure Set1 (Val: T);
 procedure Set2 (Val: T);
 function GetMin: Integer;
 function GetAverage: Integer;
 procedure IncreaseByTen;
 end;
```

请留意实作这个类别的泛型方法的源码：

```pascal
function TInftClass<T>.GetMin: Integer;
begin
 Result := Min (FVal1.GetValue, FVal2.GetValue);
end;
procedure TInftClass<T>.IncreaseByTen;
begin
 FVal1.SetValue (FVal1.GetValue + 10);
 FVal2.Value := FVal2.Value + 10;
end;
```

有了这些定义，我们就可以这样来用这个泛型类别了:

```pascal
procedure TFormIntfConstraint.btnValueClick( Sender: TObject);
var
 IClass: TInftClass<TGetValue>;
begin
 IClass := TInftClass<TGetValue>.Create;
 try
 IClass.Set1 (TGetValue.Create (5));
 IClass.Set2 (TGetValue.Create (25));
 Show ('Average: ' + IntToStr (IClass.GetAverage));
 IClass.IncreaseByTen;
 Show ('Min: ' + IntToStr (IClass.GetMin));
 finally
 IClass.val1.Free;
 IClass.val2.Free;
 IClass.Free;
 end;
end;
```

为了表现这个泛型类别的弹性，我为这个接口建立了另一个完全不同的实作方法:

```pascal
TButtonValue = class (TButton, IGetValue)
public
 function GetValue: Integer;
 procedure SetValue (Value: Integer);
 class function MakeTButtonValue (Owner: TComponent;
 Parent: TWinControl): TButtonValue;
end;
function TButtonValue.GetValue: Integer;
begin
 Result := Left; // use base class property
end;
procedure TButtonValue.SetValue(Value: Integer);
begin
 Left := Value; // use base class property
end;
```

我们在以下的源码里面，用类别函数(没有在本书中列出)为 Parent 控件建立了一个组件，其位置随机指定：

```pascal
procedure TFormIntfConstraint.btnValueButtonClick( Sender: TObject);
var
 IClass: TInftClass<TButtonValue>;
begin
 IClass := TInftClass<TButtonValue>.Create;
 try
 IClass.Set1 (TButtonValue.MakeTButtonValue ( self, ScrollBox1));
 IClass.Set2 (TButtonValue.MakeTButtonValue ( self, ScrollBox1));
 Show ('Average: ' + IntToStr (IClass.GetAverage));
 Show ('Min: ' + IntToStr (IClass.GetMin));
 IClass.IncreaseByTen;
 Show ('New Average: ' + IntToStr (IClass.GetAverage));
 finally
 IClass.Free;
 end;
end;
```

### 接口参考 v.s.泛型接口守则

在刚刚最后一个范例中，我定义了一个泛型类别，可以接受有实作特定接口的任何类别作为其实作类别。我们也可以透过建立一个基于接口参考的标准类别(非泛型类别)来达到相似的效果。事实上，我们可以定义一个类别，像这样(节录自 IntfConstraint 范例项目):

```pascal
type
 TPlainInftClass = class
 private
 FVal1, FVal2: IGetValue;
 public
 procedure Set1 (Val: IGetValue);
 procedure Set2 (Val: IGetValue);
 function GetMin: Integer;
 function GetAverage: Integer;
 procedure IncreaseByTen;
 end;
```

这两个作法之间的差别是什么?首先，在上述的类别里面我们可以传递两个不同型别的对象给设定方法(setter)，提供的类别都实作了特定的接口。但在泛型版本里面，我们只能够传递一种特定型别的对象(要看该泛型类别实体要求哪一种型别)。所以泛型版本的程序在型别检查这一点，比较保守，限制也比较多。

从我的观点来看，主要的不同是使用接口为基础的版本表示当中有 Object Pascal 的参考计算器制在运作着，而使用泛型版本的时候，类别会直接以特定型别的一般对象家里处理，因此参考计算器制并没有介入。再者，泛型版本可能有多重的限制，像是建构函数的守则，以及使用不同的泛型函数(像是位泛型型别要求特定的型别)，有些动作我们就不能做(事实上，当我们透过接口来处理，我们就不能使用基础类别 TObject 的方法)。

换句话说，使用具有接口守则的泛型类别，可以让这个类别具有接口的好处，却没有接口的麻烦。但值得一提的是，这两种技术在大多数的情形来看都是完全一样的，且在其他情形下，这种作法则有更多的弹性。


### 预设建构函数守则

还有另一种可能的泛型型别守则，称为预设建构函数或者无需参数的建构函数。如果我们需要调用预设的建构函数来建立泛型型别的对象(例如要填满一个列表)，我们就可以使用这个守则。理论上(出处为官方说明文件)，编译器应该只让我们在具备预设建构函数的型别上使用它，如果没有预设的建构函数的话，编译器会跳过它，直接调用 TObject 的预设建构函数。一个具备建构函数守则的泛型类别可以用以下的方式来写(节录自IntfConstraint 范例项目)：

```pascal
type 
 TConstrClass <T: class, constructor> = class
 private
 FVal: T;
 public
 constructor Create;
 function Get: T;
 end;
```

!!! note "笔记"
    我们也可以指定不具备类别守则的建构函数守则，在建构函数处理的型别会是一个类别。把两者都列出来，会让程序更具备可读性。

假设用以下的宣告，我们可以使用建构函数来建立一个泛型内部对象，而不用知道该类别实际上的运作方法：

```pascal
constructor TConstrClass<T>.Create;
begin
 FVal := T.Create;
end;
```

我们要怎么使用这个泛型类别，且实际的规则是什么?在下一个范例里面，我们提供了两个类别。第一个是有预设建构函数的(无需参数)，第二个则是要求一个参数的建构函数：

```pascal
type
 TSimpleConst = class
 public
 FValue: Integer;
 constructor Create; // Set Value to 10
 end;
 TParamConst = class
 public
 FValue: Integer;
 constructor Create (I: Integer); // Set Value to I
 end;
```

就像前面提过的，理论上我们应该只能使用第一个类别，但实务上我们却是两个都能使用:

```pascal
var
 ConstructObj: TConstrClass<TSimpleCost>;
 ParamCostObj: TConstrClass<TParamCost>;
begin
 ConstructObj := TConstrClass<TSimpleCost>.Create;
 Show ('Value 1: ' + IntToStr (ConstructObj.Get.Value));
 ParamCostObj := TConstrClass<TParamCost>.Create;
 Show ('Value 2: ' + IntToStr (ParamCostObj.Get.Value));
```

执行结果是:

```
Value 1: 10
Value 2: 0
```

事实上，第二个对象从没有被初始化过，假如我们试着对这个范例项目侦错，并深入到源码，我们就会发现一个调用 TObject.Create 的源码(这里我认为是有错的)。注意，假如我们试着直接调用:

`with TParamConst.Create do`

编译器会指出以下的错误:

`[DCC Error] E2035 Not enough actual parameters`

!!! note "笔记"
    即使直接调用 TParamConst.Create 在编译时期会犯错(如上例所示)。类似的调用如果使用类别参考或者其他间接方式调用就会成功，这或许也说明了建构函数守则效果的规则。

### 泛型守则的总整理以及组合应用

我们可以在泛型型别上应用许多中不同的守则，在此我们做个简单的整理，直接用源码来进行吧:

```pascal
type
 TSampleClass <T: class> = class
 TSampleRec <T: record> = class
 TCompClass <T: TButton> = class
 TInftClass <T: IGetValue> = class
 TConstrClass <T: constructor> = class
```

看过这些守则(我也花了不少时间来熟悉它们)之后，没办法很直觉的知道我们可以把这些守则进行组合。例如我们可以定义一个泛型类别，让它局限在特定类别的子类别架构下并且要求它具备特定的接口，像是:


```pascal
type
 TInftComp <T: TComponent, IGetValue> = class
 ...
 end;
```

并不是所有的组合都有意义：例如我们不可以同时要求使用类别跟记录，在使用类别守则时，合并使用特定的类别守则是多余的。最后，请注意方法守则则是一个特例，它可以达成单一方法接口守则的要求(然而比实际上体验的更复杂)。


## 预先定义的泛型容器


因为在 C++语言发展样板的早期，最常被使用的样板类别已经被定义在样板容器或者整个清单里面了，对这些已定义的类别，C++语言则是把他们定义为一个标准样板函数库(Standard Template Library, 简称 STL)。当我们在定义一个对象的列表时，就像在 Object Pascal 里面提供的TObjectList，我们就拥有了一个可以储存任何型别对象的列表。使用继承或者组合的方式，我们都需要定义一个特殊型别的自定容器，但这会是个乏味(其中也潜藏危机)的功能。

Object Pascal 编译器原本就内建了一些泛型容器的类别，我们可以在Generics.Collections 单元文件里面找到。当中的四个核心容器类别都是独立实作的(彼此之间没有继承关系)，这些类别都是以类似的现代方法实作的(使用动态数组)，而且也都对应到相应的非泛型容器类别中，原来的容器类别都放在 Contnrs 单元文件里面:

```pascal
type
 TList<T> = class
 TQueue<T> = class
 TStack<T> = class
 TDictionary<TKey,TValue> = class
 TObjectList<T: class> = class(TList<T>)
 TObjectQueue<T: class> = class(TQueue<T>)
 TObjectStack<T: class> = class(TStack<T>)
 TObjectDictionary<TKey,TValue> = class(TDictionary<TKey,TValue>)
```

这些类别逻辑上的差异，从它们的命名上应该可以看出明显的不同。要熟悉跟测试它们最好的方法，是在原本使用非泛型容器类别的源码跟使用不同数据型别的泛型版本，比较看看有多少差别。

!!! note "笔记"
接下来要讨论的这个程序，ListDemoMd2005，只使用了一些方法，所以在泛型与非泛型的类别当中，并没有对接口兼容性做太多的测试，不过我决定用一个已存在的程序，不要重新写一个。另一个要使用这个范例的原因，则是我们可能在原有的源码里面进行泛型修改的时候，可以透过泛型这个功能而获得额外的改进。


### 使用 TList<T>
名为 ListDemoMd2005 的这个程序里面，有一个用来定义 TDate 类别的单元文件，而主窗体里面就使用了一个 TList 来储存日期数据。在程序一开始的 uses 区段，我加入了 Generics.Collection 的引用，然后把主窗体里面的宣告改成了这样:

```pascal
private
 FListDate: TList <TDate>;
```

当然，用来建立这个列表的主窗体 OnCreate 事件处理程序也需要做些修改，得改成这样:

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
 FListDate := TList<TDate>.Create;
end;
```

现在，我们可以直接编译看看，先不管其他的源码。此时，程序中还包含一些『待协寻』的问题，试着把 TButton 加入到这个列表里面。对应的源码原本是可以正常编译的，但现在则会出现错误了:

```pascal
procedure TForm1.ButtonWrongClick(Sender: TObject);
begin
 // Add a button to the list
 FListDate.Add (Sender); // Error:
 // E2010 Incompatible types: 'TDate' and 'TObject'
end;
```

新的日期列表在型别检查上比原本通用的指标列表更能自动的对型别进行检查。移除了上面这一行有问题的源码以后，程序就可以正常编译、正常运作了。不过，它还有改进的空间。

以下的源代码，会把列表中所有的日期数据显示在 ListBox 组件里头：

```pascal
var
 I: Integer;
begin
 ListBox1.Clear;
 for I := 0 to ListDate.Count - 1 do
 Listbox1.Items.Add ( (TObject(FListDate [I]) as TDate).Text);
```

请注意当中的型别转换，因为这个程序使用了指针型的列表(TList)，而不是组件列表(TObjectList)。

我们可以把这个程序先改进一下，改写成：

```pascal
for I := 0 to ListDate.Count - 1 do
 Listbox1.Items.Add (ListDate [I].Text);
```

这个程序片段的另一个改进空间，可以是使用列举(预先定义的泛型列表中完全支持此一功能)，而不要使用 for 循环：

```pascal
var
 aDate: TDate;
begin
 for aDate in ListDate do
 begin
 Listbox1.Items.Add (ADate.Text);
 end;
```

最后，这个程序还可以再改进一个地方，就是透过使用 TObjectList 来储存TDate 组件，但这是下一节的主题了。

就像前面提到的 TList<T>这个泛型类别有较高的兼容性。它包含了所有原有的方法，像是 Add, Insert, Remove, 以及 IndexOf。同时也提供了 Capacity跟 Count 属性。只是 Items 变成了 Item，而且是默认属性(可以直接用变量名称加上方括号来存取，不用透过属性名称)，过去我们不常直接用这种方式存取。

### 对 TList<T>进行排序

了解这当中排序的作法也是挺有趣的(我的目的是为 ListDemoMd2005 范例项目加入排序的功能)。Sort 方法是这样定义的:

```pascal
procedure Sort; overload;
procedure Sort(const AComparer: IComparer<T>); overload;
```

这里的 IComparer<T>接口，是定义在 Generics.Defaults 单元文件里面的。如果我们执行了这个程序的第一个版本，它会使用预设的比较函数，由TList<T>的预设建构函数进行初始化。在我们的案例中，这是没有用处的。

反之，我们要做的是为 IComparer<T>定义一个适当的实作方法。为了让型别能兼容，我们得定义能够针对 TDate 类别进行排序的实作源码。有很多个方法可以完成这个目标，包含使用匿名方法(我们虽然在下一章才会介绍到匿名方法，不过下一节会先介绍作法)。这是个有趣的技术，也是因为它让 我们有机 会 可 以 介 绍 许多种泛型的设计模式。这是透过 位 于Generics.Defaults 单元文件的部分结构化类别，名为 TComparer 来达成的。


!!! note "笔记"
    我之所以把这个类别称为结构化类别，是因为它协助了源码结构化，而没有在实作上加入一大堆多余的名词。类似的类别通常也被称为框架类别，通常也用在较为复杂的设计上。

这个类别是定义成抽象化类别，并以泛型实作当中的接口：

```pascal
type
 TComparer<T> = class(TInterfacedObject, IComparer<T>)
 public
 class function Default: IComparer<T>;
 class function Construct(
 const Comparison: TComparison<T>): IComparer<T>;
 function Compare(
 const Left, Right: T): Integer; virtual; abstract;
 end;
```

我们所要做的，是先以特定的数据型别(例如本例中的 TDate)为泛型类别实体化，也继承一个实作了为这个数据型别处理的 Compare 方法的类别。这两个动作可以一次完成，我们透过以下的程序来说明一下:

```pascal
type
 TDateComparer = class (TComparer<TDate>)
 function Compare( const Left, Right: TDate): Integer; override;
 end;
```

如果你觉得这段程序看起来不太适应，那很正常。新类别继承自泛型类别的特定实体，我们可以从以下两个独立的步骤来体验:

```pascal
type
 TAnyDateComparer = TComparer<TDate>;
 TMyDateComparer = class (TAnyDateComparer)
 function Compare( const Left, Right: TDate): Integer; override;
 end;
```

这两个独立的宣告应该可以精简需要建立的源码，我们只要在宣告TAnyDateComparer 型别的单元文件里面宣告它们即可。

我们可以在原始码里面找到 Compare 函数的实际源码，不过因为它不是这一节的关键，所以我就不在这里特别贴出来了。但是要记得，即使我们把列表排序过了，用 IndexOf 方法也不会比较有效率(这一点跟 TStringList 类别完全不同喔)


### 以匿名方法进行排序

在前一节出现的排序源码看起来相当复杂，实际上的确也是如此。把排序函数直接传递给 Sort 方法相对的简单，也清楚多了。在还没有支持泛型功能之前，这一直都是通用排序功能的作法。在 Object Pascal 里面，现在我们也可以透过匿名方法来达成这个功能了(匿名方法是一种方法指标，里面包含几种额外的功能，我们在下一章里面加以介绍)。


!!! note "笔记"
    我建议大家看一下这一节，就算您对匿名方法所知不多，也可以先读一次，等读完下一章之后再回头重看一次。

TList<T>类别的 Sort 方法的参数 IComparer<T>，事实上可以被用来调用TComparer<T>的 Construct 方法，会把一个匿名方法当做参数传递，可以写成:

```pascal
type
 TComparison<T> = reference to function(
 const Left, Right: T): Integer;
```

实务上，我们可以写一个型别兼容的函数，然后把它当成参数传递:

```pascal
function DoCompare (const Left, Right: TDate): Integer;
var
 Ldate, RDate: TDateTime;
begin
 LDate := EncodeDate(Left.Year, Left.Month, Left.Day);
 RDate := EncodeDate(Right.Year, Right.Month, Right.Day);
 if LDate = RDate then
 Result := 0
 else if LDate < RDate then
 Result := -1
 else
 Result := 1;
end;
procedure TForm1.ButtonAnonSortClick(Sender: TObject);
begin
 ListDate.Sort (TComparer<TDate>.Construct (DoCompare));
end;
```

!!! note "笔记"
    上例中的 DoCompare 方法是以类似匿名方法的原理运作的，即使没有函数名称也能运作。我们稍后会以另一个程序片段来说明不需要函数名称的这个事实。我们到下一章会介绍 Object Pascal 这个新功能的更多信息。也请留意到，我们为 TDate 记录也定义了两个比较用的运算符号，可以让源码稍微简化，但即使有类别的存在，比对的源码也必须放在该类别的方法里面才行。

这看起来相当传统，我们在使用这种作法时可以省却独立函数的宣告，直接把源码当做参数传给 Construct 方法，如下:

```pascal
procedure TForm1.ButtonAnonSortClick(Sender: TObject);
begin
 ListDate.Sort (TComparer<TDate>.Construct (
 function (const Left, Right: TDate): Integer
 var
 LDate, RDate: TDateTime;
 begin
 LDate := EncodeDate(Left.Year,
 Left.Month, Left.Day);
 RDate := EncodeDate(Right.Year,
 Right.Month, Right.Day);
 if LDate = RDate then
 Result := 0
 else if LDate < RDate then
 Result := -1
 else
 Result := 1;
 end));
end;
```

这个例子应该有激发你对于匿名方法学习的欲望吧!肯定的是，最后这个例子写起来比前一节里面的源码简单的多，虽然对许多 Object Pascal 开发人员来说建立一个衍生类别看起来已经很简洁易懂了(继承的版本会把逻辑区隔的很清楚，让未来可能重复使用源码时相对简单的多，但许多时候，我们仍然还是不会去使用这个功能)。

### 对象容器(Object	Containers)

除了在这一节一开始介绍的泛型类别，还有四个从定义在 Generics.Collections 单元中的基础类别继承而来的泛型类别，可以模仿现存在Contnrs(这是以容器类别的基础)单元里面的类别功能：

```pascal
type
 TObjectList<T: class> = class(TList<T>)
 TObjectQueue<T: class> = class(TQueue<T>)
 TObjectStack<T: class> = class(TStack<T>)
```

和它们的基础类别相较之下，有两个关键性的差异。第一个是这些泛型类别只能用在对象上，第二则是他定义了一个客制化的 Notification 方法，万一对象要从列表当中(除了选择性的调用OnNotify事件处理常数)被移除了，就会释放掉该对象。

换句话说，TObjectList<T>类别的规则跟它的非泛型类别 OwnsObjects 属性被设定成 true 的时候规则是一样的。如果您觉得对于为什么这个属性不再是可以被设定的感到好奇，可以回想一下 TList<T>也是一样，可以直接使用对象型别，跟它的非泛型类别规则有些不同了。

还有第四个类别 TObjectDictionary<TKey, TValue>，这个类别则是以不同的方法定义的，它可以拥有 Key 对象，Value 对象，或者两者同时拥有。我们可以在类别建构方法的 TDictionaryOwnerships 属性中看到所有可能性。

### 使用泛型字典(Dictionary)

在所有预先定义的泛型容器类别中，Dictionary 或许是最值得我们花时间好好了解的了：TObjectDictionary<K, V>。

!!! note "笔记"
    Dictionary 在这个案例中，意指一种元素的集合，在这个集合当中，可以透过唯一键作为查询与写入的依据，Dictionary 从其作用上，也可以把它想成是关系型数组。在古典的 Dictionary 当中，我们只能用字符串当成查询的关键，但在程序实作的时候，键(Key)未必要是字符串(虽然字符串是比较常用的对象)。在旧版 Delphi 当中的通用集合中，Dictionary 的提示里使用了 TKey跟 TValue 的词语。然而 TValue 是不具关联的运行时间数据型别(我们会在第 16 章里面介绍)，在 Delphi 11 里面这两个词语则被改为 K 跟 V，以避免语意混淆。本版当中也已经做了相应的更新，如大家在前面的范例中可以发现的。

其他的类别也很重要，但是它们似乎相对容易使用，也容易理解。为了示范 Dictionary 的使用，我写了一个范例，可以从数据表里面取出数据，为每个记录建立一个对象，然后使用综合索引值作为键值。这个作法的原因是相似的结构可以很容易就用来建立代理关系(proxy, 延迟初始化)，而这种关系里，键值可以当成从数据库加载数据时的轻量化数据版本。

以下是两个在 CustomerDictionary 范例项目中使用到的类别，用以透过键与值的对应储存数据。第一个只有两个对应数据来呼应数据库的数据表，第二个则有比较复杂的数据结构(我已经省略了私有数据字段，取得数据的方法，以及设定数据的方法)：

```pascal
type
 TCustomerKey = class
 private
 ...
 published
 property CustNo: Double read FCustNo write SetCustNo;
 property Company: string read FCompany write SetCompany;
 end;
 
 TCustomer = class
 private
 ..
 procedure Init;
 procedure EnforceInit;
 public
 constructor Create (aCustKey: TCustomerKey);
 property CustKey: TCustomerKey
 read FCustKey write SetCustKey; published
 property CustNo: Double read GetCustNo write SetCustNo;
 property Company: string read GetCompany write SetCompany;
 property Addr1: string read GetAddr1 write SetAddr1;
 property City: string read GetCity write SetCity;
 property State: string read GetState write SetState;
 property Zip: string read GetZip write SetZip;
 property Country: string read GetCountry write SetCountry;
 property Phone: string read GetPhone write SetPhone;
 property FAX: string read GetFAX write SetFAX;
 property Contact: string read GetContact write SetContact;
 class var
 RefDataSet: TDataSet;
 end;
```

第一个类别非常单纯(每一个对象在被建立的时候就已经完成了初始化)，TCustomer类别使用了延迟初始化(或者代理)模式且把一个参考记录在原始码数据库中，以对象变量的(class var)形式分享给所有对象。

!!! note "笔记"
    在这个范例中，我使用了一个衍生自 TDataSet 的对象来存取数据库的数据，好让它跟现实世界的情境比较贴近点。讨论在 Delphi 中存取数据库的确超越了本书的范围，所以我并不会提供额外的篇幅来描述 TDataSet 类别实际上是如何作用的。

当对象被建立的时候，它的参考就已经被指派为对应的 TCustomerKey，而类别数据则参照到源数据集合(dataset)。在每一个数据取得的方法中，该类别会检查对应的对象是否的确已经完成了初始化，然后才进行回传：

```pascal
function TCustomer.GetCompany: string;
begin
 EnforceInit;
 Result := FCompany;
end;
```

EnforceInit 方法会检查一个区域旗标，最后会调用 Init 从数据库把数据加载到数据库内的内存对象：

```pascal
procedure TCustomer.EnforceInit;
begin
 if not FInitDone then
 Init;
end;
procedure TCustomer.Init;
begin
 RefDataSet.Locate('custno', CustKey.CustNo, []);
 // could also load each published field via RTTI
 FCustNo := RefDataSet.FieldByName ('CustNo').AsFloat;
 FCompany := RefDataSet.FieldByName ('Company').AsString;
 FCountry := RefDataSet.FieldByName ('Country').AsString;
 ...
 FInitDone := True;
end;
```

透过这两个类别，我在这个应用程序中加入了一个特殊用途的 dictionary。这个客制化的 dictionary 类别继承自特定型别实体化的泛型类别，并加入一个特定的方法:

```pascal
type
 TCustomerDictionary = class (
 TObjectDictionary <TCustomerKey, TCustomer>)
 public
 procedure LoadFromDataSet (Dataset: TDataSet);
 end;
```

加载方法则把数据填入了 dictionary、把数据复制到内存中，但只有键值的对象:

```pascal
procedure TCustomerDictionary.LoadFromDataSet( Dataset: TDataSet);
var
 CustKey: TCustomerKey;
begin
 TCustomer.RefDataSet := dataset;
 Dataset.First;
 while not Dataset.EOF do begin
 CustKey := TCustomerKey.Create;
 CustKey.CustNo := Dataset ['CustNo'];
 CustKey.Company := Dataset ['Company'];
 self.Add(custKey, TCustomer.Create (CustKey));
 Dataset.Next;
 end;
end;
```

范例程序中包含了一个主窗体，以及一个数据模块，里面放置了一个ClientDataSet 组件。主窗体里面有一个 ListView 组件，当用户点选窗体上的按钮时，就会加载数据。

!!! note "笔记"
你可能会想要用一个实际的数据集合来换掉 ClientDateSet 组件，把这个范例扩展成真的可以使用的程序。这样就可以透过查询一个键值和每一个实际的 TCustomer 对象的数据进行关连了。我有类似的源码，但是在这里介绍的话有点离题太远，目前这个范例只是一个实验性的泛型 dictionary 类别而已。

把数据加载到 dictionary 之后，btnPopulateClick 方法会把 dictionary 的键值做列举:

```pascal
procedure TFormCustomerDictionary.btnPopulateClick( Sender: TObject);
var
 Custkey: TCustomerKey;
 ListItem: TListItem;
begin
 DataModule1.ClientDataSet1.Active := True;
 CustDict.LoadFromDataSet(DataModule1.ClientDataSet1);
 for custkey in CustDict.Keys do
 begin
 ListItem := ListView1.Items.Add;
 ListItem.Caption := Custkey.Company;
 ListItem.SubItems.Add(FloatTOStr (custkey.CustNo));
 ListItem.Data := Custkey;
 end;
end;
```

这会把 ListView 组件的前两个字段填入数据，所有在 dictionary 的 key 当中的数据都会被显示出来。当用户点选 ListView 组件中的任何一个项目时，程序就会填入第三个字段:

```pascal
procedure TFormCustomerDictionary.ListView1SelectItem(
 Sender: TObject; Item: TListItem; Selected: Boolean);
var
 ACustomer: TCustomer;
begin
 ACustomer := CustDict.Items [Item.data];
 Item.SubItems.Add(IfThen (
 ACustomer.State <> '',
 ACustomer.State + ', ' + ACustomer.Country,
 ACustomer.Country));
end;
```

上面的这个方法会取得该键值相对的对象，并使用对应的数据。在背景里，特定的对象第一次被使用到时，存取属性的方法就会把完整的数据加载到TCustomer 对象。


### Dictionary	v.s.	 字符串列表

经过了这么多年，许多 Object Pascal 的开发人员，包含我自己，都过度使用了 TStringList 类别(译者:我也是)。我们不只可以用 TStringList 来储存字符串，还可以用来储存成对的名称与内容。不仅如此，还可以用来储存成对的名称与对象，更可以透过搜寻名称来取得对应的对象。从简单的介绍来看，字符串列表看起来比泛型好理解多了，简直就像个瑞士万用刀一样了。

特定、聚焦的容器类别，的确相对是比较好的选择。举例来说，一般的TDictionary 类别，以字符串当做键值，以对象当做内容，会比 TStringList来的好，至少有两个优点:程序清晰明白、也比较安全。因为当中会牵涉到的型别转换比较少，且执行速度比较快，这当然是假设该 dictionary 是使用哈希表(Hash table)的。

要表现出这些不同点，我也写了一个相对简单的范例项目，叫做 StringListVsDictionary。它的主窗体储存了两个相同的列表，宣告如下:

```pascal
private
 FList: TStringList;
 FDict: TDictionary<string,TMyObject>;
```

这两个列表会随机的填入数据，但相同的节点则会循环填入，重复执行的源码内容如下:

```pascal
FList.AddObject (AName, AnObject);
FDict.Add (AName, AnObject);
```

窗体上的两个按钮，分别是取得该列表中的每个元素，以及透过名称进行搜寻。两个方法都会搜寻整个字符串列表来找到对应的值，但是第一个方

法则是会找出字符串列表中的对象，第二个方法会使用 dictionary。请注意，使用第一个方法时，我们需要用到 as 型别转换来变成特定的型别，dictionary则是已经跟类别绑定了。以下是这两个方法的主要循环:

```pascal
TheTotal := 0;
for I := 0 to FList.Count -1 do
begin
 aName := FList[I];
 // now search for it
 anIndex := FList.IndexOf (aName);
 // get the object
 anObject := FList.Objects [anIndex] as TMyObject;
 Inc (TheTotal, anObject.Value);
end;
TheTotal := 0;
for I := 0 to FList.Count -1 do
begin
 aName := FList[I];
 // get the object
 AnObject := FDict.Items [aName];
 Inc (TheTotal, AnObject.Value);
end;
```

我不想依序存取字符串，但需要得知存取了几次以后才在已经排序过后的字符串列表中找到要找的内容(字符串列表的搜寻是以二元搜寻法进行)，来跟使用哈希键值的 dictionary 做个比较。毫无意外的，dictionary 当然比较快，以下是测试时用 ms 为单位得到的数字:

```
Total: 99493811
StringList: 2839
Total: 99493811
Dictionary: 686
```

这个结果很明显是相同的，但时间上差的可远了，同样处理一百万笔数据，使用 dictionary 搜寻 1 亿笔数据，大概只花了相同程序使用字符串列表四分之一的时间。


## 泛型接⼝

在『对 TList<T>进行排序』那一小节里，对预先定义的接口比较奇怪的用法，应该还有印象吧，当中有提到泛型的宣告。当中的技术细节值得我们仔细一谈，因为它制造了相当明确的机会。

第一个要提到的技术部分是它完美的合法定义了一个泛型接口，就像我们在 GenericInterface 范例项目中所做的:

```pascal
type
 IGetValue<T> = interface
 function GetValue: T;
 procedure SetValue (Value: T);
 end;
```

!!! note "笔记"
    这是 IntfCotraints 范例项目中，IGetValue 接口的泛型版本，我们在本章稍早的『接口守则』那一节里面介绍过。在该案例中，这个接口是记录一个整数的数值，而在此则改为泛型。

注意到其中和标准接口的差异，在泛型接口中，我们不需要定义明确的GUID 作为该接口的代号(或称 IID)。编译器会在我们为泛型接口进行实体化的时候主动建立一个 IID，也算是隐藏式的宣告。事实上，我们不用为泛型接口建立特定的实体也可以实作它，只要定义一个泛型类别，让该类别实作这个泛型接口即可：

```pascal
type
 TGetValue<T> = class (TInterfacedObject, IGetValue<T>)
 private
 FValue: T;
 public
 constructor Create (Value: T);
 destructor Destroy; override;
 function GetValue: T;
 procedure SetValue (Value: T);
 end;
```

在建构函数指派该对象的初始值的时候，解构函数的唯一要求是把该对象先记录下来注记成未来要释放的对象。我们要建立这个泛型类别的实体(在背景建立一个接口型别的特定实体)，可以这么写：

```pascal
procedure TFormGenericInterface.btnValueClick( Sender: TObject);
var
 AVal: TGetValue<string>;
begin
 AVal := TGetValue<string>.Create (Caption);
 try
 Show ('TGetValue value: ' + AVal.GetValue);
 finally
 AVal.Free;
 end;
end;
```

我们在 IntfConstraint 范例项目里面看过一个替代的作法，是用一个特定型别的接口变量，然后明确的写明该接口型别的定义(不像一般我们在写型别时都是隐藏的写法):

```pascal
procedure TFormGenericInterface.btnIValueClick( Sender: TObject);
var
 AVal: IGetValue<string>;
begin
 AVal := TGetValue<string>.Create (Caption);
 Show ('IGetValue value: ' + AVal.GetValue);
 // freed automatically, as it is reference counted
end;
```

当然，我们也可以定义一个特定的类别来实作这个泛型接口，就像以下这个案例(节录自 GenericInterface 范例项目):

```pascal
type
 TButtonValue = class (TButton, IGetValue<Integer>)
 public
 function GetValue: Integer;
 procedure SetValue (Value: Integer);
 class function MakeTButtonValue (Owner: TComponent;
 Parent: TWinControl): TButtonValue;
 end;
```

请留意，TGetValue<T>泛型类别实作了 IGetValue<T>接口，TButtonValue特定类别实作了 IGetValue<Integer>这个特定接口。在前面的例子当中，这个接口会被重新对应到组件的 Left 属性:

```pascal
function TButtonValue.GetValue: Integer;
begin
 Result := Left;
end;
```

在上面的这个类别中，MakeTButtonValue 这个类别函数是一个已经准备好随时可以用来建立该类别对象的方法。这个方法会在主窗体的地三个按钮里面被用上：

```pascal
procedure TFormGenericInterface.btnValueButtonClick( Sender: TObject);
var
 IVal: IGetValue<Integer>;
begin
 IVal := TButtonValue.MakeTButtonValue (self, ScrollBox1);
 Show ('Button value: ' + IntToStr (IVal.GetValue));
end;
```

虽然这跟泛型类别完全没关系，以下是 MakeTButtonValue 这个类别函数的源码:

```pascal
class function TButtonValue.MakeTButtonValue(
 Owner: TComponent; Parent: TWinControl): TButtonValue;
begin
 Result := TButtonValue.Create(Owner);
 Result.Parent := Parent;
 Result.SetBounds(Random (Parent.Width),
 Random (Parent.Height), Result.Width, Result.Height);
 Result.Caption := 'btnv';
end;
```

### 预先定义的泛型接口

现在我们已经看过了如何定义泛型接口，以及如何把泛型接口跟泛型类别或一般类别结合的方法，我们再回头看一下 Generics.Default 单元文件。这个单元文件定义了两个泛型比较用的接口:

+ IComparer<T>拥有一个 Compare 方法
+ IEqualityComparer<T>则拥有 Equals 跟 GetHashCode 方法

这些接口则由一些泛型类别或者一般类别实作出来，兹列于下(实作的内容就不列了):

```pascal
type
 TComparer<T> = class(TInterfacedObject, IComparer<T>)
 TEqualityComparer<T> = class(
 TInterfacedObject, IEqualityComparer<T>)
 TCustomComparer<T> = class(TSingletonImplementation,
 IComparer<T>, IEqualityComparer<T>)
 TStringComparer = class(TCustomComparer<string>)
```

在上面的列表中，我们可以看到用于实作泛型接口的基础类别要不是传统的参考计数功能的 TInterfacedObject 类别，就是 TSingletonImplementation类别(从 Delphi 11 开始，它只是 TNoRefCountObject 类别的别名了)。这是一个名字很奇怪的类别，因为它只提供了 IInterface 的基本实作，而且没有用到参考计数。

!!! note "笔记"
    singleton 这个名词一般是用来定义只能被建立出一个实体对象的类别，而不是不具备参考计数功能的类别。我觉得这个名字取得真的不恰当。

就像我们在本章『对 TList<T>进行排序』那一节所提到的，这些比较用的类别会被泛型容器使用到。为了让程序能不要太复杂，Generics.Default 单元文件里面大量使用了匿名方法，所以您或许需要先看一下下一章再回来重新阅读一次。

## 在 Object	Pascal 里面的智能指标(Smart	Pointer)

开始接触泛型的时候，我们一开始可能会误以为 Object Pascal 大多数是用它来处理集合对象的。当然处理集合对象对泛型类别来说是最基本的情境，在文件或者书籍里面的第一个范例也大多都是使用集合或者容器类别来说明泛型。在本章的最后一个范例里，我们会介绍非集合类的泛型类别，也就是定义一个智能指标(Smart Pointer)。

如果您原本就很习惯写 Object Pascal，您可能完全没听过智能指标，这个概念是从 C++编程语言而来。在 C++里面，我们可以有指向对象的指针，透过这个指标，我们可以直接进行人工内存管理，区域对象变量则会自动被管理，但有其他的限制(包含缺乏对多型的支持)。智能指针的概念是使用在区域中被管理的对象来处理指向我们会用到的实际对象指针的生命周期。如果这听起来很太复杂，我希望 Object Pascal 版可以协助厘清这个概念。

!!! note "笔记"
    在 OOP 里面，多型(polymorphism)这个名词是用来标注以下情形：我们把一个衍生类别的对象指派给基础类别的变量，并且调用基础类别中的虚拟方法，最后可能会调用到特定子类别所重新实作的版本。


### 使用智能指针的记录

在 Object Pascal 当中的对象都是以参考进行管理，而记录的生命周期跟宣告了该记录变量的方法紧密结合着。当方法执行结束，该记录的内存空间也会自动被清除掉。所以我们可以透过记录来管理 Object Pascal 对象的生命周期。

在 Delphi 10.4 之前，Object Pascal 的纪录并没有提供在释放的时候执行自定源码的功能，这个功能是随着『受管理的记录』推出的新功能。旧式的机制中，是在记录中使用接口字段，随着接口字段也由系统进行管理，用来实作接口的对象也有了自己的参考计数管理。

另一个考虑则是，我们想要使用标准的记录或是泛型记录呢?使用 TObject的标准记录的话，我们可以在需要的时候删除对象，所以一般情形下这已经够用了。使用泛型版本的话，我们则会有两个额外的好处：

+ 泛型智能指针可以回传当中的对象参考，所以我们不用一直维护着两份参考
+ 泛型智能指标可以透过无参数的建构函数，自动建立容器对象

在这里我们要介绍两个范例，使用泛型记录来实作智能指针，虽然有点复杂，最起始的城市还是一个包含对象守则的泛型记录:

```pascal
type
 TSmartPointer<T: class> = record
 strict private
 FValue: T;
 function GetValue: T;
 public
 constructor Create(AValue: T);
 property Value: T read GetValue;
end;
```

记录当中的 Create 跟 GetValue 方法就是单纯的指派、读回该值。以下这段源码的使用情境，是建立一个对象，然后建立一个智能指标来跟它交换，并允许使用智能指标指向该嵌入对象，并且调用它的方法(请看最后一行源码)：

```pascal
var
 SL: TStringList;
begin
 SL := TStringList.Create;
 var SmartP: TsmartPointer<TStringList>.Create (SL);
SL.Add('foo');
 SmartP.Value.Add ('bar');
```

当我们已经让程序运作了，如果没有使用智能指标，上面这段源码可是会导致内存泄漏的情况发生喔。事实上，记录会自动在离开程序区块后被释放，但它没有释放内部对象。


### 用泛型受管理的纪录来实现智能指针

与智能指针记录最相关的行为就是它的终止过程(finalization)，在以下的源码中可以看到，我们也加入了起始过程，在当中把对象参考指向 nil，理想中，我们应该在起始过程中避免任何指派的作业(对内部对象进行多重链接会需要相对复杂的参考计算器制)，但这是不可能的，所以我在起始过程中加入了这个指派作业，以避免该程序一直行就触发例外事件。以下是泛型受管理的纪录完整的宣告:

```pascal
type
 TSmartPointer<T: class, constructor> = record
 strict private
 FValue: T;
function GetValue: T;
 public
 class operator Initialize(out ARec: TSmartPointer<T>);
 class operator Finalize(var ARec: TSmartPointer<T>);
 class operator Assign(var ADest: TSmartPointer<T>; const [ref] ASrc: TSmartPointer <T>);
 constructor Create(AValue: T);
 property Value: T read GetValue;
 end;
```

请留意除了类别守则外，泛型记录也有建构函数守则，因为我想要建立泛型数据型别的对象。这会发生在 GetValue 方法被调用，且该字段还没有被初始化的时候，以下是所有方法的完整源码:

```pascal
constructor TSmartPointer<T>.Create(AValue: T);
begin
 FValue := AValue;
end;
class operator TsmartPointer<T>.Initialize( out ARec: TSmartPointer <T>);
begin
 ARec.FValue := nil;
end;
class operator TsmartPointer<T>.Finalize( var ARec: TSmartPointer<T>);
begin
 ARec.FValue.Free;
end;
class operator TsmartPointer<T>.Assign( var ADest: TSmartPointer <T>;
 const [ref] ASrc: TSmartPointer <T>);
begin
 raise Exception.Create('Cannot copy or assign a TSmartPointer<T>');
end;
function TSmartPointer<T>.GetValue: T;
begin
 if not Assigned(FValue) then FValue := T.Create;
 Result := FValue;
end;
```

上面的源码是 SmartPointsMR 范例项目的一部分，项目中包含了如何使用智能指针的一些范例。第一个是把我们前几页的范例改写成比较严谨的作法:

```pascal
procedure TFormSmartPointers.BtnSmartClick(Sender: TObject);
var
 SL: TStringList;
begin
 SL := TStringList.Create;
 var SmartP := TSmartPointer<TStringList>.Create (SL);
 SL.Add('foo');
 SmartP.Value.Add('bar');
 Log ('Count: ' + SL.Count.ToString);
end;
```

然而，有鉴于泛型智能指标支持对指定型别对象自动建构的功能，我们也可以透过明确宣告该变量指向字符串列表的作法，用以下的源码来建立它:

```pascal
procedure TFormSmartPointers.BtnSmartShortClick(Sender: TObject);
var
 SmartP: TSmartPointer<TStringList>;
begin
 SmartP.Value.Add('Foo');
 SmartP.Value.Add('Bar');
 Log ('Count: ' + SmartP.Value.Count.ToString);
end;
```

在这个程序中，我们可以验证所有对象真的被释放，并且在初始程序中把全局变量ReportMemoryLeaksOnShutdown设定为True来确保没有内存泄漏的情况发生。为了凸显这个问题，在程序中我们特别做了一个按钮，点击它就会造成内存泄漏，程序执行就会异常结束。



### 用泛型记录与接口来实现智能指针

如我之前提过的，在 Delphi 10.4 推出受管理的记录这个功能之前，可以用来实现智能指标的作法是使用接口，因为记录会自动释放被接口字段参考的对象。虽然这个功能比较不受重视，但它的确提供了一些额外的功能，例如隐晦的转换功能。

也因为这主题还是有一些有趣的、复杂的范例，我决定还是保留它，但描述的篇幅短一点(请参考 SmartPointers 范例项目)。

要用接口来实作智能指针，我们可以写一个内部的支持类别、让它跟接口绑定，并使用参考计数的机制来决定何时要释放对象。这个内部类别的源码会像这样:

```pascal
type
 TFreeTheValue = class (TInterfacedObject)
 private
 FObjectToFree: TObject;
 public
 constructor Create(AnObjectToFree: TObject);
 destructor Destroy; override;
  end;
constructor TFreeTheValue.Create( AnObjectToFree: TObject);
begin
 FObjectToFree := anObjectToFree;
end;
destructor TFreeTheValue.Destroy;
begin
 FObjectToFree.Free;
 inherited;
end;
```

我把这个类别当成泛型智能指标宣告成嵌套类型。我们需要在智能指标泛型型别上所做的，好让这个功能能够使用的，是新增一个接口参考，并用TFreeTheValue 对象进行初始化，以参照到内部对象：

```pascal
type
 TSmartPointer<T: class> = record
 strict private
 FValue: T;
 FFreeTheValue: IInterface;
 function GetValue: T;
 public
 constructor Create(AValue: T); overload;
 property Value: T read GetValue;
 end;
```

虚构的建构函数变成了:

```pascal
constructor TSmartPointer<T>.Create(AValue: T);
begin
 FValue := AValue;
 FFreeTheValue := TFreeTheValue.Create(FValue);
end;
```

透过前述的源码，我们现在就可以在程序里面写以下的源码，而不会造成内存泄漏了(这段源码也跟我一开始提到过，并使用在受管理的纪录那一节介绍过的很像):

```pascal
procedure TFormSmartPointers.btnSmartClick( Sender: TObject);
var
 SL: TStringList;
 SmartP: TSmartPointer<TStringList>;
begin
 SL := TStringList.Create;
 smartP.Create (SL);
 SL.Add('Foo');
 SL.Add('Bar');
 Show ('Count: ' + IntToStr (SL.Count));
end;
```

在方法的最后，smartP 记录会被释放掉，同时也会连带使得内部接口对象一起被清除，并释放掉 TStringList 对象。

!!! note "笔记"
    虽然可能会发生例外，但这段程序还是可以执行的。事实上，当我们使用到受管理的型别时，编译器还是会自动在编译时在这些源码中加入try-finally 区块。就像在刚刚这案例中，记录中使用了接口字段。


### 加入隐晦转换(Adding	Implicit	Conversion)

使用受管理的纪录方案，我们需要额外花些功夫来避免记录复制的功能，这会需要多加一些源码手动控制参考计算器制，并且把结构做的更复杂。

然而这个功能在接口为主的作法中是内建的，我们在这个模型中加入转换的功能，这样就可以简化起始程序跟数据结构的建立。我要特别在指派功能中把目标对象加入用 Implicit 转换为智能指标的步骤:

```pascal
class operator TSmartPointer<T>. Implicit(AValue: T): TSmartPointer<T>;
begin
 Result := TSmartPointer<T>.Create(AValue);
end;
```

透过这段源码(以及使用 Value 数据字段)我们现在可以让源码更为精简了，精简过的版本如下:

```pascal
var
 SmartP: TSmartPointer<TStringList>;
begin
 SmartP := TStringList.Create;
 SmartP.Value.Add('foo');
 Show ('Count: ' + IntToStr (SmartP.Value.Count));
```

作为替代方案，我们可以使用一个 TStringList 变量，并使用一个比较复杂的建构函数来位智能指针记录进行初始化，即使没有特别写明其参考：

```pascal
var
 SL: TStringList;
begin
 SL := TSmartPointer<TStringList>.
 Create(TStringList.Create).Value;
 SL.Add('Foo');
 SL.Add('Bar');
 Show ('Count: ' + IntToStr (SL.Count));
```

正如我们已经开始进行的，我们也可以定义完全相反的转换，并使用转换符号，而不要用 Value 属性：

```pascal
class operator TSmartPointer<T>.
 Implicit(AValue: T): TSmartPointer<T>;
begin
 Result := TSmartPointer<T>.Create(AValue);
end;
var
 SmartP: TSmartPointer<TStringList>;
begin
 SmartP := TStringList.Create;
 TStringList(SmartP).Add(‘Bar’);
```

现在，我们应该也要注意到上面这段源码里面使用了虚构建构函数，但这对记录并不需要。我们需要的是找到一个方法对内部对象进行初始化，可能是调用它的建构函数，当我们第一次使用到它的时候。

我们无法检查内部对象是否已经被指派，因为记录(跟类别不同)并不会被初始化为 0。然而我们可以从接口变量来测试，接口变量会被初始化。或者我们也可以用额外的建构函数源码，把该记录用 0 全部填满作初始化。


### 比较几个智能指标的方案

使用『受管理的记录』来实作智能指标的方案，相对来说是比较简单，也是比较有效率的，但『接口为基础』的实作版本提供了可以转换的功能。尽管两个版本都有各自的优点，我个人比较喜欢『受管理的纪录』的实作版本。

!!! note "笔记"
    如果大家想要在这个议题上有更清楚的分析，以及更深入的实作范例(超出本书的范围)，我推荐以下的部落格文章，由 Erik van Bilsen 所著: https://blog.grijjy.com/2020/08/12/custom-managed-records-fro-smart-pointers/

## 以泛型处理协同变异(Covariant)回传型别

在 Object Pascal 当中(以及大多数静态面向对象编程语言)，一般来说一个方法可以回传一个类别的对象，但我们不能把一个对象覆写成另一个衍生类别之后，当成该类别来回传。这个作法称为『协同变异回传型别』，在一些编程语言里面是有明确支持的，例如 C++。


### 关于 Animals,	Dogs,跟 Cats

从源码的词语来看，如果 TDog 是继承自 TAnimal，我们就可以调用这些方法:

```padcal
function TAnimal.Get (name: string): TAnimal;
function TDog.Get (name: string): TDog;
```

在 Object Pascal 里面我们不能让虚拟方法回传不同的值，我们也不能对回传型别进行多载，只能在参数上进行多载。我们来透过简单的范例介绍完整的源码吧，以下是三个我们会用到的类别:

```pascal
type
 TAnimal = class
 private
 FName: string;
 procedure SetName(const Value: string);
 public
 property Name: string read FName write SetName;
 public
 class function Get (const aName: string): TAnimal; function ToString: string; override;
 end;
  TDog = class (TAnimal)
 end;
 TCat = class (TAnimal)
 end;
```

这两个方法的实作源码非常简单，我们注意到类别函数是实际上用来建立新组件的，它会从内部调用一个建构函数。

理由是我不想直接建立一个建构函数，这已经介绍过很多次了，建构函数是一个类别用来建立对象的方法(或者类别架构)。源码如下:

```pascal
class function TAnimal.Get(const aName: string): TAnimal;
begin
 Result := Create;
 Result.fName := aName;
end;
function TAnimal.ToString: string;
begin
 Result := 'This ' + Copy (ClassName, 2, maxint) +
 ' is called ' + FName;
end;
```

现在我们可以用以下的源码来使用这个类别了，这不是我喜欢的用法，假设我们要把回传来的结果转成适当型别:

```pascal
var
 ACat: TCat;
begin
 ACat := TCat.Get('Matisse') as TCat;
 Memo1.Lines.Add (ACat.ToString);
 ACat.Free;
```

再次强调，我想做的是让TCat.Get的回传值能够被指派到TCat型别的参考，而不要多做一次转型，我们该怎么做呢?



### 回传泛型结果的方法

泛型可以协助我们解决这个问题。并不是泛型型别，泛型型别是最常用的泛型形式。但我们已经在本章前面的篇幅里面介绍过提供非泛型型别的泛型方法了。我们可以在 TAnimal 类别中加入的是一个以泛型型别作为参数的方法：


`class function GetAs<T: class> (const aName: string): T;`

这个方法会要求一个泛型型别作为参数，在这个例子里泛型型别是个类别(或实际的型别)，并回传该型别的物件。简单的实作源码如下:

```pascal
class function TAnimal.GetAs<T>(const aName: string): T;
var
 res: TAnimal;
begin
 res := Get (aName);
 if res.inheritsFrom (T) then
 Result := T(res)
 else
 Result := nil;
end;
```

现在我们可以建立一个实际的案例了，透过 as 转型，不过我们还是可以把型别当成参数传进去:

```pascal
var
 ADog: TDog;
begin
 ADog := TDog.GetAs<TDog>('Pluto');
 Memo1.Lines.Add (ADog.ToString);
 ADog.Free;
```

### 回传不同类别的衍生对象

当我们回传相同类别的对象时，我们可以直接改上面的源码来当做建构函数。但使用泛型来取得协同变异回传型别是更有弹性的。事实上我们可以用它来回传不同类别的对象，甚至是不同架构的类别：

```pascal
type
 TAnimalShop = class
 class function GetAs<T: TAnimal, constructor> ( const aName: string): T;
 end;
```

!!! note "笔记"
    像这样的类别，被用来为其他类别(或者不只一个类别，视其参数或者状态而定)建立对象，通常称为类别工厂(class factory)。

我们现在可以使用这个特定的类别守则(在该类别来说，也许不可能达成)，透过确立建构函数守则，好让泛型方法可以用来建立特定的类别对象：

```pascal
class function TAnimalShop.GetAs<T>(const AName: string): T;
var
 Res: TAnimal;
begin
 Res := T.Create;
 Res.Name := AName;
 if Res.inheritsFrom (T) then
 Result := T(res)
 else
 Result := nil;
end;
```

要注意，现在在这个调用的写法中，我们不用重复该类别两次了:

`ADog := TAnimalShop.GetAs<TDog>('Pluto');`

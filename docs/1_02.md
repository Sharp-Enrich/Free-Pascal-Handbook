Object Pascal 是一个强型别的编程语言，在写程序的时候，变量被宣告时就需要标明其所属的资料型别（也可以是用户自定的数据型别）。所谓的资料型别，所指的是该变量当中可以储存什么样的资料内容，而我们又能对它做些什么运算。这同时让编译器可以用更快的速度处理我们的源码，也更容易发现哪些源码有错误。

这就是 Pascal 语言的型别理论强于其它语言（例如 C 或 C++）的地方，后来发展出的很多语言都在语法承袭了 C 语言，但却打破了与 C 语言的兼容性，例如 Java 跟 C#，就承袭了 C 语言，也学习了 Pascal 对数据型别强固的概念。举例来说，在 C 语言中，连算数型别都几乎可以互相交换。相对之下，原始的 BASIC 语言，就没有这样的概念，而今日的许多脚本式语言，（例如 Javascript 就是最好的例子）对型别的概念跟 Pascal 都是大相径庭的。

!!! note "笔记"
    事实上，虽然 Object Pascal 是强型别语言，但仍然有一些技巧可以用来避开型别安全的规范，像是使用可变记录型别(Variant)，这个作法我们强烈建议大家别用，且今日已经很少被使用了。

一如我提过的，所有可变动的编程语言，从 JavaScript 以降，对于数据型别都没有很确切的描述，或是只有很概略性的描述。在这些编程语言当中，变量的型别大多取决于我们赋予什么数据进去。而该变量的型别可能在执行当中随着执行状态而改变。值得正视的是，数据型别在大型的应用程序的编译作业时，是可以用以判断程序正确性的关键，所以不能在运行时间才加以检查。数据型别需要更多的规范与结构，并在源码撰写前就应该要加以规划，这些地方很明显的都有其优缺点。

!!! note "笔记"
    我比较喜爱强型别的编程语言，这一点已经不用再多说了，不过本书的目标还是在说明编程语言是怎么运作的，这比提倡我的想法里什么才是一个伟大的编程语言还要来的强烈。

## 变量与指派数据(Assignments)

跟任何一个强型别的编程语言相同，Object Pascal 也要求所有变量在被使用之前要先行宣告，每次我们宣告一个变量，都必须明白的说明它属于哪种数据型别，以下就是几个变量宣告的样子：

```pascal
var
 Value: Integer;
 IsCorrect: Boolean;
 A, B: Char;
```

上面范例源码里面的 var 关键词，可能在一个源码的好多个地方会出现，例如在程序与函式开头的部份，我们都会宣告一些局部变量，好在程序、函式这些『子程序』当中使用，或者在一个单元文件中宣告整个单元的全局变量。

!!! note "笔记"
    我们在后面一点的章节会介绍到，最近几版的 Delphi 已经加入了可以在源码当中随处宣告变量(inline)的功能。这跟古典传统的 Pascal 是很显著的不同。

在 var 这个关键词后面，我们可以宣告一连串的变量名称，以分号来区隔变量名称和其所属的资料型别。我们可以在一行里面输入多个变量名称，例如上面范例中最后的 A 跟 B，多个变量名称之间以逗点来做为区分(早期有一种程序写作风格是把每个变量放在单独一行里面: 用独立的一行也方便于阅读源码、做版本之间的比较，以及源码合并)。

我们定义好一个特定型别的变量之后，就可以用该型别的运算来处理这个变量了，例如我们可以用布尔值来检查条件是否符合，以及把整数值用在数字的运算上。我们不能在未加入特定型别转换函式的情形下把布尔值跟整数拿来混用，也不能把不兼容的各种变量值拿来互相处理（即使它们内部处理的数据兼容也不行，例如布尔值跟整数，它们的数据格式是兼容的，但还是不能把布尔值跟整数混在一起运算）。

最简单的数据指派指令，就是把一个实际的、特定的值指派进该型别的变量里面，例如我们现在有个变量名为 Value，我们希望在 Value 这个变量里面存放 10 这个数字，但是我们要怎么直接撰写实际的值？接下来就让我们来看一下这个实作的方法，以及当中所蕴含的细节。



### 实际值（文字值、字面意义：Literal	Value）

Literal Value 就是在源码当中直接输入一个数据，例如我们需要一个整数20，就可以在源码当中直接输入：

`20`

相同的数值也可以用十六进制来表示：

`$20`

从 Delphi 11 开始，我们也可以用二进制表示数值，例如可以写成:

`%10100;`

对于数值很大的数字，也是从 Delphi 11 开始，我们可以用底线来做为数值分隔的逗点(西方的数值分隔符, 是每三位数加一个逗点)，作为分隔数值符号的底线，会自动被编译器忽略，例如，我们可以把 2 千万写成:

`20_000_000`

这个写法表示是整数型态的 2 千万，如果我们需要表示浮点数的数值的话，就需要在数字结尾加上小数点，例如:

`20.0`

在源码的字面意义，不限于数字，我们也可以输入字符跟字符串，字符与字符串的字面意义，只要用单引号包起来即可：

```pascal
//字符
‘K’
#55
//字符串
‘Marco’
```

如我们上面所介绍的，我们也可以用数值来表示字符（起初这个方式是用来表示 ASCII 字符，但目前已经可以用来表示 Unicode 了），只需在数字前面加一个井字号即可，例如#32 就代表空格符。透过这个方法，我们就可以不用实际输入字符，只要直接透过数值就可以处理许多控制用的字符了，例如tab 或者删除键。

万一我们在这个字符串当中必须包含单引号这个字符，就直接输入两个单引号字符即可：

`‘Marco Cantu’’’; //这样就代表了 Marco Cantu’`

在上面的范例字符串当中，最后三个单引号当中，前面两个重复的单引号用来表示单引号字符，最后一个单引号则是用来表示字符串结束。另外也要注意到，字符串必须要在单行当中输入完毕，如果字符串太长，会超过一行，我们就必须要把它写成两行，然后两行之间用加号 + 来把两个字符串连接在一起。如果我们希望在字符串中加入换行符号，不要把他们写成两行，而是要在字符串当中加入一个换行符号：sLineBreak 这个系统常数：

`‘Marco’+ sLineBreak +’ Cantu’’’`

### 指派叙述句（Assignment	Statements）

在Object Pascal 里面，要进行数据指派的符号，是冒号加上等号(:=)，这个符号对于只熟悉其他语言的开发人员来说，是一个很奇怪的符号。而单纯一个等号 =, 在其他编程语言当中大多用来作为指派数据的运算符，而在Object Pascal 里面则是用来进行比对两个数据是否相同。


!!! quote "典故"
    := 这个符号，是从 Pascal 的前身，Algol 语言来的，这个编程语言对现在的程序开发人员来说都已经是很少听到的，更遑论用过，大多数目前的编程语言都不再使用:=这个符号，而比较常用=了。

也因为用了不同的符号来处理数据指派跟数据比对，Pascal 的编译器(就像C 的编译器一样)处理源码的速度就更快，因为无需花时间把整段源码判读过后才去判断等号在出现的时候是代表什么意义。而使用不同的符号也让程序人员在阅读源码的时候更容易读懂。Pascal 语言选择的这两个符号跟 C相关的语言(从 C 取经而来的语言包含有 Java, C#, JavaScript)不同，C 相关的语言是用=作为指派数据的符号，而用==作为判断数据内容是否相同的运算符号。

!!! note "笔记"
    为了完整性，我得再多提一下 JavaScript 还有个===符号，这个符号是用来判断两个变量或数据的数据型别与内容是否一样，因为除了判断型别是否相同，还会把两个数据先转成相同型别再去判断其内容，所以这个运算符号所花的时间会比较久，而且就连 JavaScript 的程序人员都常被搞混。

在指派叙述句当中的双方，我们通常称之为左值(lvalue)跟右值(rvalue)，所谓的左值，就是在叙述句的左方的家伙，它必须是个内容可以被改变的识别符号，例如变量、指针、对象，在这个叙述句当中，右值的内容会被复制一份到左值的内存空间当中。

另一个规则则是左值与右值的数据型别必须一致，或者两者之间能够有自动的型别转换，这我们会在接下来的篇幅中介绍。


### 指派（Assignment）与转换（Conversion）

单纯的指派动作中，我们可以写出以下的源码：(您可以在 variableTest 这个测试项目档中，找到这个章节里面的范例源码)

```pascal
Value := 10;
Value := Value + 10;
IsCorrect := True;
```

透过适当的变量宣告，这段范例源码的三个叙述句都是正确的，而以下这个叙述句就是错的了：

```pascal
Value := IsCorrect;
```

当我们输入这段源码的时候，Delphi 的编辑器会立刻在源码的变量下方显示一段红色的曲线，意指源码是有错的。如果我们试着编译上面这句程序叙述句，编译器会回报一个如下所述的错误：

`[dcc32 Error]: E2010 Incompatible types: 'Integer' and 'Boolean'`

编译器会告诉我们，在源码当中有错误，错误的描述则是不兼容的资料型别（Incompatible data types），当然，我们也可以把一个变量的型别转换成另一种型别。在某些情形下，这样的转换是自动的，例如我们如果把一个整数值指派给一个浮点数型别的变量，就会自动转换（当然了，反之要把浮点数指派给整数型别的变数则不行）。有时我们也需要呼叫一些特定的系统函式来做数据转换的动作。

### 为全局变量进行初始化

我们可以在宣告全局变量的时候顺便把初始值指派给它，用的是定义常数内容时候的符号(=)，而不是指派变量内容时所使用的(:=)，所以我们可以写成以下范例源码：

```pascal
var
  Value: Integer = 10;
  Correct: Boolean = True;
```

### 为局部变量进行初始化

这样的初始化动作，只能对全局变量使用，在子程序，也就是程序或者函式当中的变量宣告，是不能够使用这个语法的，子程序的变量初始化，必须在子程序的源码当中进行：

```pascal
var
 Value: Integer;
begin
 Value := 0; // 初始化
```

我要再强调个 100 次、10000 次，如果局部变量不经初始化就直接使用它，变量里面的内容是完全无法预料的，它将会是内存被变量取得的当下，内存里头的随机数据，在许多情形下，编译器都会警告说这会有潜在的错误发生。例如我们如果这么写：

```pascal
var
 Value: Integer;
begin
 ShowMessage (Value.ToString); // Value 就没有初始化
```

编译器会警告说 Value 这个变量没有被初始化，而如果我们执行这个程序，会发现执行的结果中，显示的内容完全无法预料，因为显示的内容将会是内存被配置成 Value 这个变量时，该段内存里面的随机数据。

### 行内变量 (在源码中宣告的变量 Inline	Variable)

在最近几版的 Delphi 里面(是从 10.3 Rio 开始的)加入了一个新的概念，这个概念改变了早期 Pascal 跟 Turbo Pascal 编译器开始的变量宣告概念:在源码中宣告变量，我把它称之为行内变数 (inline variable declarations)。

这个新的行内变量语法，让我们可以直接在任意的源码区块当中宣告变量(可以用传统的变量宣告方式，在一行里面宣告多个变量):

```pascal
procedure Test;
begin
 var I, J: Integer;
 I := 22;
 J := I + 20;
 ShowMessage(J.ToString);
end;
```

虽然表面上看起来，差别并不大，但是这个语法的影响所及，牵涉到初始化、型别推定(type inference)，以及变量的生命周期，本章的后段我会再详述这些部分


### 为行内变数初始化

跟传统的宣告模式相比，第一个显著的改变就是在源码里面宣告跟为变量初始化可以用一个叙述句就完成。相较之下，这会比把变量都宣告在函式起始的区块容易阅读，我们接着用前一节的范例来看:

```pascal
procedure Test;
begin
 var I : Integer := 22;
 ShowMessage(I.ToString);
end;
```

这么写的好处，就是当我们要连续宣告几个变量时，可以直接用上前一个变量，不用再写常数(例如 0 或者 nil)，也可以直接用上变量计算结果作为另一个变量的初始值了，例如底下这个例子里面的 K:

```pascal
procedure Test1;
begin
 var I : Integer := 22;
 var J : Integer := 22 + I;
 var K : Integer := I + J;
 ShowMessage(K.ToString);
end;
```

从另一个角度来看，传统的宣告方式中，只要是在变量宣告区里面宣告了的变量，在整个函式里面都可以使用。但新的行内变量写法，是只有在该变量宣告的位置之后的源码，才可以使用该变量喔。用上面这个例子来对照，变量 K 在前面两行是不能使用的，在宣告前使用该变量，编译过程就会出错了。

### 行内变数的型别推定

另一个行内变量的明显好处，就是从现在起，编译器可以从几个不同的角度，例如初始值的型别，来推定这个行内变数的型别。底下是个简单的范例:

```pascal
procedure Test;
begin
 var I := 22;
 ShowMessage(I.ToString);
end;
```

右值的算式型别(就是在 := 符号右边的内容)可以算出来决定该变量的型别。如果指派了一个字符串常数，该变量很单纯的，就会被定为字符串型别，但如果我们指派了函式的结果或者复杂的算式，这个型别推定就会由编译器来处理了。

要记得，这个变量仍旧是强型别，当编译器在编译阶段决定了该变量的型别，并且做了初始化，我们就不能在后面的源码里面试图指派不同型别的数据到该变量里面了。型别推定只是让我们偷个懒，可以不要写型别而已(例如复杂的变异数据型别，或者是泛型型别)，但并没有改变这个语言强型别的基础，也不会让它在运行时间因而变慢。

!!! note "笔记"
    在进行型别推定的时候，有时数据型别会被『扩展』为比较大的型别，例如前面的例子里，数字型别的值 22 (就是一个 ShortInt)，会被推定为 Integer。这会作为通用规则，当右值是整数型别，并且小于 32 bits 的范围时，该变量会被推定宣告为 32 bit 整数，我们也可以自行指定特定的、范围较小的值类型。

## 常数 (常量，Constants)

Object Pascal 也允许我们宣告常数，常数的存在，让我们可以把特定的数据赋予名称，在程序执行的过程中，常数的内容是不能被变更的。同时常数的存在，也会让我们的源码在编译之后的 Size 小一点。

要宣告常数，我们可以不用指定资料型别，只要直接指定初始值就行了，编译器会由我们指定的初始值内容，自动辨识该内容应该使用的数据型别，以下就是一些简单的常数宣告（这些源码仍然可以从 VariablesTest 项目中找到）：

```pascal
const
Thousand = 1000;
Pi = 3.14;
AuthorName = 'Marco Cantu';
```

编译器会依照数据的内容自动判断常数的数据型别，上述的源码中Thousand 这个常数的型别会被指派为 SmallInt，这是所有整数型别中占用最小空间就能储存 1000 这个数字的。如果我们要告诉编译器，我们要用特定的型别来储存该数值，那就可以改写为如下的源码：

```pascal
const
Thousand: Integer = 1000
```

!!! warning "警示"
    『应该会这样吧』的这种梦想，在程序里面通常都不会如你的意，尤其在编译器更新过几个版本之后，通常这种程序人员没来由的梦想都无法如意。所以如果你能设法让源码看起来更清楚，不要有假设、如果这种幻想参杂在其中的话，就那么做吧，让源码永远看起来能够明明白白，不要有任何幻想、灰色地带的机会！

当我们宣告了一个常数，编译器会决定要把这个数据储存在内存的哪个地方，或者在每次使用到这个常数的时候，把内容复制过去。第二个目标在处理简单的数据内容时尤其有用。

一旦我们宣告了常数，我们就可以把常数像其他变量一样使用，只是我们不能企图变更常数里面的数据，如果我们在指派叙述句里面把常数放在左值的位置，编译器就会回报错误。


!!! note "笔记"
    够奇怪的了，Object Pascal 居然允许我们在运行时间变更常数的内容，等于把常数当成变量来用，只是我们必须先设定$J 这个编译器设定，或者透过适当的编译器选项，名为 Assigned typed constant。这个选项的规则是为了兼容于旧版的编译器，这作法很明显的，不是我们建议的程序风格，而我在这里介绍这个功能，也只是为了完整的呈现 Pascal 的历史，以及曾经有过这样的程序技术而已。




### 行内常数 (在源码中宣告常数、常量 Inline	Constants)

我们刚刚介绍过行内变量，我们也可以在源码里面宣告行内常数。用这个方式宣告的常数，可以宣告其型别或者省略类型声明，在省略型别的常数宣告时，其型别也是用推定的方式定义出来的(这个推定的作法在处理常数的宣告早已行之有年)。我们来看个简单的范例：

```pascal
begin
 // 某些源码…
 const M: Integer = (L +H) div 2; //把型别透过标识符清楚定义
 // 又来一些源码
 const M = (L + H)
```


### 资源字符串常数（Resource	String	Constants）

虽然这是一个稍微进阶的主题，当我们定义一个字符串常数，而不是写一个标准的常数宣告，我们可以使用特定宣告方法：资源字符串常数（resourcestring），它会告诉编译器和链接程序要对待该字符串常数如同对待 Windows 的资源一样。（或在非 Windows 平台上 Object Pascal 对等的数据结构）：

```pascal
const
 sAuthorName = 'Marco';
resourcestring
 strAuthorName = 'Marco';
begin
 ShowMessage (strAuthorname);
```

在上述的两个宣告中，我们都是宣告一个常数，在程序执行过程中不能变更里面的内容，差别只在于程序内部是怎么实作而已。透过 resourcestring区段定义的常数都会被储存在程序的资源字符串表里面，这个资源字符串表可以被一些外部程序编辑，例如作多国语言在地化的程序(可以把当中的字符串编辑成各个不同语系的内容)

使用资源的好处就是在 Windows 应用程序处理内存的时候可以节省更多空间，在其他平台也有类似的机制，这个方法也是在处理多国语系应用程序时比较好的作法，源码的内容就不用做任何修改了。实际执行时，我们需要把所有在程序当中要显示的文字全部都以 resourcestring 来宣告，这样一来所有的文字都会被以 Windows 资源字符串表被储存起来，我们只需要用Windows 资源编辑工具，把资源字符串表的内容进行翻译、另存成另一语系的资源文件，那么当使用者在不同语系的 Windows 上面执行这个程序的时候，就会加载该语系对应的资源字符串表，也就会用该语系的文字内容来显示程序接口跟讯息，应用程序的文件名也无须修改了

!!! tip "提示"
    IDE 环境的编辑器有自动重构(refactoring)的功能，我们可以用它来把我们源码里面的字符串取代成对应的 resourcestring 宣告。只要把编辑光标移到我们要修改的字符串标识符上，然后按 Ctrl+Shift+L 就可以启动重构功能了。



### 变量的生命周期(Lifetime)与可视范围(Visibility)

依照我们定义一个变量的方式，变量使用内存的空间与时间都会不一样(通常这段时间我们称为变量的生命周期)，同时也会在源码当中不同的地方对该变量有可辨识与不可辨识的分别（这个界限我们称之为变量的可视范围）。

在这么前面的章节里，我们还没办法完整的把所有可能的选项都介绍完，但我们可以先试想最常用的几种案例：

+ **全局变量：** 如果我们在一个单元的interface部分宣告了一个变量（或者其他识别符号，例如类别、常数），这个变量的可视范围将会扩及所有参照(或叫使用)了这个单元的所有单元源码。程序一开始执行后，就会尽快为这个变量配置内存空间，直到程序结束为止都维持这个内存空间的存在。我们可以在单元的initialization区段指派一个初始值给这个变数。

+ **全局隐藏变数：**如果我们在一个单元的implementation区段宣告一个变量，则我们在整个程序的其他单元是无法看到这个变量的，但在这个宣告变量的单元中的任何一个函式、方法、程序当中则都可以使用这个变量，这样的变量使用了全局的内存，并且与刚介绍过的全局变量拥有相同的生命周期，相异者只有可视范围，初始化的方法也跟全局变量相同。

+ **局部变量：**如果我们在任何一个函式、方法、程序当中宣告一个变量，我们只能在该段子程序当中使用这个变量，一离开该段子程序，就无法再存取这个变量了。这个变量的可视范围涵盖了该段子程序，以及其下的其他所有子程序（除非其下的子程序当中有用到相同名称作为其他识别符号之用）。在内存当中，这个变量是在该段子程序被呼叫的时候由操作系统配置空间给当时所在的内存堆栈里面，而该段子程序执行完成时，配置给这个变量的空间也会自动被回收给系统。

+ **区域⾏内变量：**如果我们在函式、方法或程序的程序区块中宣告了一个行内变量，跟传统局部变量相较，行内变量只多了一个限制，就是该变量的生命周期是从它被宣告的那行开始，一直到该程序区块结束的地方为止。

+ **程序区块内的⾏内变量：**如果我们是在特定程序区块(例如在程序区块中又另外写了 begin-end 这样的区块，例如 if-then 或者 while begin-end 这样的区块)，则该变量的生命周期就只局限在该区块里面。这个概念在很多早已能够在任何程序区块中宣告变量的编程语言来说早已是见怪不怪，但对于 Object Pascal 来说，这是最近几个版本才加入的概念。请特别注意，在多重 begin-end 程序区块中宣告的行内变量，只能在该阶层的区块中被使用，离开该层区块，到外层就不能使用了。

!!! note "笔记"
    对程序区块内的行内变量来说，受限的不仅是该变数能否被看见，还有该变数的生命周期。受管理的数据型别(例如interface, string或managed record)都会在该程序区块结束时就被自动释放，而不会等到该函式、程序或方法结束时才释放。这个原则也适用于暂存计算结果的暂时变量喔。

任何在单元的interface区段当中宣告的识别符号，在整个程序中都是可视的，只要该单元有被其他单元使用到。画面窗体类别的变量就是用这个方法宣告的，所以我们可以在整个程序的任何其他画面窗体中，随时取用任何一个画面窗体（当然也包含其下的public范围的方法、属性、以及组件）。把所有东西都宣告成全局可视，绝对是很糟的程序技巧。除了会占用内存空间之外，使用全局变量也会使一个程序项目很难维护、更新下去，换句话说，我们在使用全局变量的时候，应该要尽量精简也要避免使用Delphi建立的全局变量，例如窗体。


## 资料型别

在Pascal当中，有一些数据型别是预先定义好的，我们可以将之区分为三个组别：有序型别(ordinal types)、实数型别，以及字符串。我们会在接下来的篇幅当中讨论前两个，然后在第六章里面特别介绍字符串。

Delphi也包含了未特定型别的资料型别，称之为variant，还有另一些有弹性的数据型别，像是TValue (是进阶的RTTI功能的一部分，RTTI是RunTime Type Information，运行时间型别信息的缩写)。这类进阶的数据型别我们会在稍后第五章里面加以介绍。

### 有序与数值类型别 

有序型别是根据顺序的概念而来的，我们不只能够算出两个资料之间的大小，而且还可以得知数据的下一个或前一个数据是什么，当然也能够算出该数据的最大值与最小值。

这组类别当中，最重要的三个型别分别是：Integer(整数), Boolean(布尔值), 以及Char(字符)。当然，还有其他相同意义的型别，与这三个相异者只在内部实作的方式，以及可表示的数值范围。

以下的表格列出了有序型别可表示的数字范围：

|⼤⼩ |有正负号之分| ⽆正负号之分|
|-------|-------|-------|
|8 bits |ShortInt: -128到127 |Byte:0到255|
|16 bits |SmallInt:-32768到32767 (-32K到32K) | Word:0到65535 (0到64K)|
|32 bits|Integer: -2,147,483,648 到 2,147,483,647 (-2GB到正2GB)|Cardinal:0 到 4,294,967,295 (0到4GB)|
|64 bits |Int64:-9,223,372,036,854,775,808 到9,223,372,036,854,775,807|Uint64:0 到18,446,744,073,709,551,615(我已经无法读出这个数字了)|


我们可以发现，这些数据型别各有其可表示的数字范围，端视其所使用的内存空间大小，以及其表示的数字是否包含正负号。要表示负数的型别，就会比使用同样空间但不表示负数的型别少了一倍的数字可以表示。

例如Int64这个型别可以表示十进制的18位数数字，函式库中对于这个型别也支持有序类别的一些子程序(例如High跟Low)，以及用来计算的子程序（像是Inc跟Dec），以及字符串转换的子程序(例如IntToStr)。

### 整数类型型别的别名

有时候我们会很难记住ShortInt跟SmartInt之间的差异，例如到底哪一个型别可储存的数字比较小，这时候我们就可以参考在System这个单元当中预先定义的类别别名：

```pascal
type
Int8 = ShortInt;
Int16 = SmallInt;
Int32 = Integer;
UInt8 = Byte;
UInt16 = Word;
UInt32 = Cardinal;
```

请记得，这些型别并没有新增新的型别，而只是为了容易记忆，例如Int16当然比SmallInt更容易从字面上知道它比ShortInt(也就是Int8)来得大。这些型别别名也让从C或其他编程语言转换过来Object Pascal的程序开发人员更容易上手。


### 整数型别,	64 位与 NativeInt.

在64位版本的Object Pascal里面，我们会觉得很惊讶，因为它的整数型别仍然还是32位。这么做的原因，是因为这样对于在CPU层级的数字运算最有效率。

指标型别（我们在稍后的篇幅当中会加以介绍）与其他与内存地址相关的数据型别都是64位，如果我们需要一个值类型转换成指标的大小，并想要符合CPU原生平台使用，我们可以使用两个特别的型别：NativeInt跟NativeInt的别名类别。这两个类别会在特定平台中保持相同的长度，在32位系统中，他们就是32位，在64位系统中，就会变成64位。

但有个很显著的特殊案例：LargeInt 型别，这个型别通常用来对应原生平台的 API 函式。它在Windows 32位版以及其他32位的平台中都是32位，而在64位ARM平台时就是64位。所以除非您需要特殊处理特定原生源码让您的程序能套用在该平台上，不然最好不要随便碰触这个议题啊。


### 整数型别助手

整数型别在Object Pascal里面是享有特殊待遇的型别，我们可以在处理整数变量，甚至于整数型别的常数时，在识别符号后面加上一个. 就会有跟其他类别相似的法可以使用喔。

!!! note "笔记"
    从技术上来说，对原生数据型别的这些操作，都是被定义为要使用『内建的纪录助手』（intrinsic record helpers）。类别与记录的助手会在第 12 章介绍，简单的说，我们可以对核心的数据型别自定操作方法。有经验的开发人员会发现到，型别的操作方法会被定义为类别的固定方法，以符合内建记录助手。

我们可以在下面的范例当中看到许多从IntegersTest范例项目撷取出来的实例：

```pascal
var
 N: Integer;
begin
 N := 10;
 Show (N.ToString);
 // display a constant
 Show (33.ToString);
 // type operation, show the bytes required to store the type
 Show (Integer.Size.ToString);
```

!!! note "笔记"
    上面的范例中，show 这个函式是用来把数据显示在一个 TMemo 组件里面的简单函式，使用这个函式，我们可以先避免太靠近 ShowMessage 对话框，而顺带的好处，则是我们可以把执行的结果从 TMemo 组件上直接复制下来，如下面的执行结果所示，在本书中的大多数范例也都会用这个方式来处理执行结果。

上面的源码执行结果如下：

```
10
33
4
```

这些操作方法的确很重要(比其他被列在运行时间函式库当中的更重要)，所以值得被我们列在这里：

|||
|----|----|
|**ToString** |把数值转成字符串，以十进制表示|
|**ToBoolean** |把数值转换成布尔型别|
|**ToHexString**| 把数值转换成字符串，以十六进制表示|
|**ToSingle** |把数值转换成单精度浮点数型别|
|**ToDouble** |把数值转换成倍精度浮点数型别|
|**ToExtended** |把数值转成extend浮点数型别|


第一和第三个操作方法会把数值转换成字符串，分别使用十进制与十六进制格式来显示，第二个操作方法则是转换为布尔型别，后面三个则是把数值转成浮点数型别，这个型别我们稍后会介绍。

整数型别还有一些操作方法我们可以使用的（大多数其他值类型也有），例如

|||
|----|----|
|**Size**| 该型别使用多少个字节来存放数据|
|**Parse**| 把一个字符串转换成字面上显示的数值，如果该字符串并不是数值，就会抛出一个型别转换例外事件。|
|**TryParse**| 试着把字符串转换成数值，如果字符串不是合法的数字，则会回传0|



### 标准有序型别函式 


除了由整数型别助手定义的方法，以及前列的这些方法，还有一些标准、古典的函式我们可以用来处理任何有序型别的（不一定只有数值类的型别）。最简单的例子，就是查询该型别的大小(SizeOf)、最大值(High)、最小值(Low)。SizeOf这个系统函式回传的值（我们可以在任何型别上使用这个函式），会是一个整数，告诉我们这个型别会使用多少个字节来储存数据（很像前面提到的Size这个方法所做的）

系统内建了一些可以用来处理有序型别的函式，我们以下表列出：

|||
|-----|-----|
|Dec |把参数一的数据递减，如果有参数二，则把参数一递减参数二所述的数值|
|Inc |把参数一的数据递增，如果有参数二，则把参数一递增参数二所述的数值|
|Odd |回传参数数据是否为奇数，如果要测试是否为偶数，请直接加个 not 在前面做反向运算即可：not Odd|
|Pred| 回传参数数据的前一个数值，系统会依据参数型别来判定前一个数值应该是什么|
|Succ| 回传参数数据的后一个数值，系统会依据参数型别来判定后一个数值应该是什么|
|Ord |回传参数的数值在该型别中的序列编号（通常用在非数字型的有序型别）|
|Low |回传参数数据的型别中的最小值|
|High| 回传参数数据的型别中的最大值|

!!! note "笔记"
    C 和 C++语言的程序人员应该要注意，Inc 函式这里有两种版本，有一个参数的版本，也有两个参数的，分别对应 C 语言语法里面的++和+=(Dec 当然也有两种版本，分别对应--和-=)，Object Pascal 编译器会对这些函式进行优化，就像 C 和 C++编译器所做的一样。然而，跟 C/C++的功能不同，Delphi提供的这两个函式，只能提供处理前先计算(先加或者先减)的功能，无法提供处理后再计算的功能，并且也没有提供回传值。

请注意，这些函式当中，有些是由编译器自动计算好，然后直接替换掉其中的数值的，例如，如果我们呼叫了High(X)，这里的X是一个整数型别的变量，编译器会自动把该段源码直接替换成整数型别的最大值。

在IntegersTest范例中，我已经为一些有序型别函式加入了一个事件：

```pascal
var
 N: UInt16;
begin 
 N := Low (UInt16);
 Inc (N);
 Show (IntToStr (N));
 Inc (N, 10);
 Show (IntToStr (N));
 if Odd (N) then
 Show (IntToStr (N) + ' is odd');
```

执行结果如下：

```
1
11
11 is odd
```

您可以把上述源码里面的Uint16修改成Integer或者任何其他的有序型别，观察看看结果会有什么改变。


### 超过范围的运算.

一个变量都有其有效范围的数值，就像上面这个范例里面的N一样。如果我们指派了太大的数值，或者一个负数给它，上面的执行结果就会是错误的，事实上一共有三种不同的错误可能会发生在这种超过范围的运算当中。

第一种是编译错误，会发生在我们指派一个超过范围的常数数值时，例如我们如果在上面的范例里面加入这行源码：

`N := 100 + High(N)`

编译器就会回报错误如下:

`[dcc32 Error] E1012 Constant expression violates subrange bounds`

第二种情况，则是编译器不会回报错误，因为还得看程序执行的时候会不会导致错误，假设我们在上面的程序片段中改写成：

```pascal
Inc (n, High(n));
Show(IntToStr(n));
```

编译器不会在编译的时候告诉我们源码有错，因为编译器也无法在程序执行前预先知道错误可能发生（因为会不会有错，得看N这个变量的初始值才知道）。万一有两种可能性：假如我们编译了，并执行了这个程序，我们最后指派了不合逻辑数值给这个变量，则这行程序的动作将会是减法，这也是最糟的情形，我们不会得到错误，但这个程序也不正确。

我们能做的（也建议大家这么做）就是把编译器选项当中的Overflow checking（溢位侦测）这个选项设成打开({$Q+} 或者{$OVERFLOWCHECKS ON})，这样一来编译器就会对类似的溢位错误进行防御并加以阻拦、抛出名为”Integer overflow”的错误。


### 布尔值.

逻辑上的是(True)与非(False)被以布尔型别加以表示，这个型别也用来作为条件判断叙述句，我们在下一章就会介绍，布尔值只有两种可能的数值内容，也就是True或者False。


!!! warning "警示"
    为了跟微软的 COM 以及 OLE automation 兼容，ByteBool, WordBool, 以及LongBool 都以-1 表示 True, 以 0 表示 False。然而我们应该可以忽略这三种特殊的型别，也避免直接用系统定义的数字来表示布尔值，除非绝对必要的情形。

跟C语言或其他C阵营的语言不同，布尔值在Object Pascal当中是以枚举数据类型来实作的，所以没有其他数值可以直接被用来表示布尔值。而且我们绝对要避免企图把布尔值转换为其他值类型，即使布尔值的型别助手当中也包含了ToInteger跟ToString这两个方法。我会在本章稍后的篇幅当中介绍枚举数据类型。

请注意，布尔值的ToString方法会把布尔值的内容以数值回传，就像我们用另一个函式BoolToStr的结果一样，当我们把第二个参数的内容设成True，来表示要在输出中以字符串(True或者False)来回传(请见下面介绍字符型别操作的范例程序)


### 字符

字符变量是以字符型别来定义的，今日的字符型别已经是以双字节的Unicode字符(也可以用WideChar型别来表示)来储存资料了，和旧版的单字节是完全不同的。

!!! note "笔记"
    Delphi 编译器仍然提供了单字节的字符型别，以 AnsiChar 这个型别来储存单位元的 ANSI 字符，而用 wideChar 来储存 Unicode 字符，Char 型别的定义则只是一个型别别名，我们建议只要是处理字符，都一律使用 wideChar，如果要处理单字节的数据，别再像以往很多人会用 Char 来处理，现在请改用 Bytes 这个类别吧。然而从 Delphi 10.4 开始，所有版本的编译器又都支持 AnsiChar 了，这是为了对目前已经存在的源码有更高的兼容性。

如果您需要关于Unicode字符的定义，包含字符代号与显示关系（当中有不少深入的主题），请阅读第六章，而在目前这个章节中，我将只聚焦于字符类型的核心概念。

一如稍早在介绍实际值的时候我所提到的，常数字元可以用文字符号直接来表示，像’k’这个符号，也可以用数值来表示，写作#78。字符也可以透过Chr这个系统函式来表示，例如Chr(78)，而相对的要把文字内容以数值来表示，则要透过Ord这个函式，通常直接用文字符号来表示字符、数字、标点符号是比较好的。

当我们在使用特殊字符，例如在#32以下的控制字符，我们也只能用数值来
表示，以下的列表包含了最常使用的几个控制字符：

+ \#8 删除键
+ \#9 tab定位键
+ \#10 换行符号
+ \#13 回到行首
+ \#27 esc键



### 字符型别的运算.

跟其他的有序数据型别一样，字符型别也有几个原生的运算方法，可以让我们透过在该型别的变量之后加个.就能直接使用，也就是透过内建记录助手来处理。

然而，使用的情境已经相当不同，首先，我们必须在要使用这个功能的单元当中先use Character这个单元，跟其他的转换函式不同，字符型别的助手包含了一二十个跟Unicode专属的处理函式，例如IsLetter, IsNumber以及IsPunctuation这几个查验用的函式，以及ToUpper, ToLower这两个转换用的函式，以下是从CharsTest范例当中节录的一些源码：

```pascal
uses
 Character;
...
var
 ch: Char;
begin
 ch := 'a';
 Show (BoolToStr(ch.IsLetter, True));
 Show (ch.ToUpper);
```

这段源码的结果会是：

```
True
A
```

!!! note "笔记"
    字符型别助手当中的 ToUpper 处理函式，已经完全支持 Unicode 了，这表示如果我们传了 Unicode 字符的 ù 就会回传大写的 Ù，部分传统的运行时间函式库当中的函式就没有这么聪明，而只能处理一般的 ASCII 字符而已。目前还没能支持这么多，因为对应的 Unicode 处理速度还很慢。




### 把 Char 视为有序型别.

Char型别涵盖的范围相当大，但它仍旧是有序型别，所以我们就可以对Char型别使用Inc, Dec这样的函式来取得前一个、下一个字符，就像我们在前面介绍基础有序型别的章节所介绍的那样。也可以写个for循环，把Char当成里面用来记录顺序的元素。

底下是一个简单的范例，用for循环来显示一些字符，以开始值到结束值的数字作为要显示的字符数值：

```pascal
var
ch: Char;
 str1: string;
begin
 ch := 'a';
 Show (ch);
 Inc (ch, 100);
 Show (ch);
 str1 := '';
 for ch := #32 to #1024 do
 str1 := str1 + ch;
 Show (str1)
```

在CharsTest范例的 for 循环当中，把很多文字加入了字符串中，使得执行结果相当的长，这个字符串是以底下的文字开头的：

```
a
Å
!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abc 
defghijklmnopqrstuvwxyz{|}~
```


### 以 Chr 函式进行转换 .

我们之前已经介绍过Ord这个函式，可以把字符的数值数据回传(更精确的说，是回传Unicode的字符码节点)，同样的我们也有另一个函式Chr可以把数值转换成字符。

### 32 位的字符.

虽然目前默认的字符型别已经对应成WideChar，我们还是需要知道Delphi也同时提供了一种使用4个字节来定义字符数据的型别UCS4Char，这是Universal Character Set 4位的缩写。在System单元当中，定义如下：

```pascal
type
  UCS4Char = type LongWord;
```

和UCS4Char对应的字符串型别是UCS4String(定义成UCS4Char的数组)，虽然这组型别不常用到，但一样定义在Character单元里，也是这个编程语言运行时间函式库的一部分。


### 浮点数型别.

不同型态的整数能够表示有序的数据集合，而浮点数则是不具顺序的（虽然可以进行数值大小的比较，但却不具顺序，因为无从决定下一个数值与目前的数值要差距多少），浮点数型别可以用来表示一些数字的近似值，依据这些型别的表示范围，会多少有些误差。

浮点数依照不同型别使用不同长度记录数据，而有不同的格式，以下是在Object Pascal里面浮点数型别的列表：

+ **Single** 浮点数里面使用空间最小的就是Single，这个型别 使用4个字节来储存数值，Single这个名字，正意指 着它使用单精度浮点数，这个型别也正对应了其他语 言里面的float型别
+ **Double** 使用Double的型别，就会使用8个字节来储存数据，Double这个名字指的就是它使用倍精度浮点数来储存数据，其他语言中也有使用Double这个型别，其他语言的Double也是使用8个字节来储存数据，在旧版的Pascal当中，这个型别则是被称为Real。
+ **Extended** 这个型别在原本的Delphi Win32版的编译器中，是使用10个字节来储存数据，但这个型别并不是所有操作系统都能使用的(在部分的操作系统上，例如Win64，就被转回了Double，在macOS上面它则是16个字节)。其他的语言则称这个数据型别为long Double

以上就是所有不同精确度的浮点数型别，分别对应了IEEE定义的标准浮点数表示方法，且CPU都可以直接支持，指令周期也最快（精确的说，应该是FPU，也就是浮点运算器才对）

另外还有两个很特别的不具顺序的数字型别，我们可以用来记录精确，而非近似值的型别：


+ **Comp** 使用8个字节来表示非常大的整数（可以记录到18位数的十进制数），由于是整数，透过这个型别来记录，就可以记录完全准确的数值，不像浮点数只能记录近似值。

+ **Currency** 同样使用8个字节来记录数字，但固定使用十进制的四位数来记录小数点数值。跟型别的名字一样，Currency型别是用来处理货币数值的，必须精确到小数点以下四位数，而且不能有所误差。

!!! note "笔记"
    Delphi 11 当中为 Currency 这个型别新增了新的记录助手。跟后面的篇幅中会介绍到的浮点数型别的助手类似，都提供了取整数的功能、转换为字符串，以及从字符串转换为浮点数的功能。

所有不具顺序的型别，都没有High, Low, Ord这些函数，因为实数型别在理论上，是可以用来表示不具上限的数值的，有序型别只能储存一定数量的数据，也就有了边界值。



### 为何浮点数的数值特别不同

我们来深入讨论一下，当我们观察整数23的时候，我们可以确切的知道下一个数字是多少，整数是有限的，因为整数是有序的数值，每次向前或向后的变化量都是整数1。

而浮点数则是用来表示连续的数字，即使只是表示很小的区段，请想象一下，浮点数，也就是实数，就像是一条线，是由无限个点组成的，例如在23到24之间到底有几个数？或者说23.46的下一个数值是多少？是23.47?23.461?或23.4601?由于实数是连续的，所以是完全无法得知的。

同样的道理，我们可以知道char型别数值中，w的下一个字符是什么，但完全无法得知7143.1562的下一个数字是什么？我们当然可以判别两个实数之间孰大孰小，但无法从一个实数推测知道它的下一个数值是什么。

另一个对于浮点数数值的关键概念，则是浮点数无法精确记录所有数字的数值，通常有些数字只能记录其近似值，例如从范例FloatTest摘录的以下源码：

```pascal
var
 s1: Single;
begin
 s1 := 0.5 * 0.2;
 Show (s1.ToString);
```

以上的程序执行后，我们可能会预期屏幕上出现的结果是0.1, 但事实上它可能会出现0.100000001490116这个接近0.1的数字，但结果仍旧不是0.1，当然，如果我们对小数二位作四舍五入，结果就会是0.1，如果我们把范例中的s1型别改成Double,输出结果就会变成0.1，FloatTest就会这样显示。

!!! note "笔记"
    目前我们还没有时间作对浮点数在计算机的处理进行数学上的深入讨论，所以我会再这里暂时不再作更多的说明，如果您对于 Object Pascal 语言的这方面处理有兴趣，我推荐给您 Rudy Velthuis 的精辟文章，您可以从这个网址看到：http://rvelthuis.de/articles/articles-floats.html




### 浮点数类别助手与 Math 单元

从前一个程序范例可以看出，浮点数资料型别也提供了类别助手，我们可以透过助手直接对特定变量的转换作处理，就像把它当成一个类别实体一样。事实上，对浮点数型别的处理可是相当多种的。

以下是对Single型别的一些处理(部分函式可以从它们的名称看得出来是做什么处理，其他的函式可能就得看一下文件才知道是什么功能了)：

||||
|----|----|----|
|Exponent |Fraction |Mantissa|
|Sign |Exp |Frac|
|SpecialType |BuildUp |ToString|
|IsNan |IsInfinity |IsNegativeInfinity|
|IsPositiveInfinity |Bytes| Words|

运行时间函式库也提供了一个名为Math的单元，在这里面定义了许多进阶的数学函式，包含了三角函数函式（例如ArcCosh），财务用的函式（例如InterestPayment），以及统计用的函式（例如MeanAndStdDev程序）。里面包含了许多数学函式，很多我们可能都没听过，例如MomentSkewKurtosis（我想让大家去搜寻一下这个函式的用途）

System.Math这个单元在功能上已经非常多元了，但我们还是可以找到许多额外的Object Pascal的数学函式库。

## 简单的使用者自定型别

随着类型的概念，由Nikalaus Wirth带入Pascal语言的伟大想法之一，就是在程序中定义新数据型别的能力(很多功能我们今天早已觉得理所当然，但在当时大家并还不这么想)。我们可以透过型别定义，在程序中引入我们自定的数据型别，例如次范围型别、数组型别、记录型别、列举型别、指针型别，以及集合型别，最重要的使用者自定型别就是类别（Class），这是Pascal这个编程语言面向对象能力的一部分，将在本书的第二部分介绍。

您或许会觉得型别定义在许多编程语言里面都是很常见的，没有错，但Pascal是第一个正式以精确定义的方式把它作为一个基本功能的编程语言。Object Pascal仍有一些很独特的功能，例如次范围的定义、列举功能、集合等，将在接下来的章节里介绍。更复杂的数据型别（像数组或记录）则在第五章进行介绍。

### 命名与非命名型别 

我们可以为使用者自定型别取个名字，好在后面的源码里面使用，或者直接用在变量上面。在Object Pascal的惯例中，是在任何数据型别的名称前面加个T开头，包含类别也是如此，但这规则并不只限于使用在类别上。我会强烈的建议您遵守这个规则，如果您原来是习惯写JAVA或C#的程序，或许您会不太习惯，但还是建议您遵守它。

当您为一个数据型别命名时，您必须在源码的type区段当中宣告（我们可以在每个单元当中加入数据型别，不限数量），以下则是一个简单的程序片段，示范宣告几个新的数据型别：

```pascal
type
 // subrange definition
 TUppercase = 'A'..'Z';
 // enumerated type definition
 TMyColor = (Red, Yellow, Green, Cyan, Blue, Violet);
 // set definition
 TColorPalette = set of TMyColor;
```

有了这些数据型别，我们就可以宣告一些变量：

```pascal
 UpSet: TUpperLetters;
 Color1: TMyColor;
```

在上述的情境中，我们使用了命名型别，在另一种情形下，也可以不为这个新的数据型别命名，如下面的源码所示：

```pascal
var
 Palette: set of TMyColor;
```

在一般的情形下，我们应该避免使用非命名的数据型别，就像上面这个范例中所写的，因为这样写，我们没办法把它作为其他函式或者程序的参数。由于这个语言最后在进行型别比对的时候，会直接以型别名称来比对，而不会用型别当中的每个字段定义一一比对，所以为每个数据型别赋予一个名称就格外的重要。也要记得在一个单元文件的interface区段所做的型别定义，将会让所有使用该单元的其他源码都可以辨识它。

上面的型别定义是什么意思呢？我会用一些篇幅为不熟悉传统Pascal型别定义宣告的读者介绍，也会试着把Pascal的型别定义跟其他语言不同的地方特别点出来，所以大家不论如何，都可能对以下的篇幅感到有兴趣。


### 型别别名

如同我们所见的，Delphi语言在判别型别之间是否兼容时，是比对型别的名称是否相同，而非实际比对两个型别的真实定义是否相同。如果两个定义完全相同的型别用了两个不同的名称来命名的话，就会被视为不同的型别。

当我们使用型别别名的时候，这个情况也有部分是成立的，对系统来说，用了别名的新型别，就会被视为是全新的型别。令人迷惑的是两个相同的语法会产生相当不同的效应。让我们看一下在TypeAlias范例里面的源码:

```pascal
type
 TNewInt = Integer;
 TNewInt2 = type Integer;
```

这两个新的型别都能跟原始的Integer型别兼容(透过自动型别转换功能)，然而 TNewInt2 型别却无法让编译器视为与 TNewInt 相同的型别，例如在函式当中的引用参数中，就无法把 TNewInt2 的变量传给 TNewInt 的字段：

```pascal
procedure TForm40.Button1Click(Sender: TObject);
var
 I : Integer;
 NI: TNewInt;
 NI2: TNewInt2;
begin
 I := 10;
 NI := I; //没问题
 NI2 := I; //也没问题
 Test(I);
 Test(NI);
 Test(NI2); //会报错
```

最后一行的代码会报出下面的错误信息：

`E2033 Types of actual and formal var parameters must be identical (var 的参数域类型必须一致)`

类似的状况也发生在型别助手，Integer型别助手可以用在 TNewInt 上，但不能用在 TNewInt2 上面，这情况我们稍后会在介绍记录助手的时候再深入介绍。


### 次范围型别

次范围型别是把特定范围的数据特别取个名字，所以称为次范围型别。举例来说，我们可以把一个小范围的整数，例如1到10，或者100到1000定为一个新的型别，或者也可以定义英文字母的大写部分成一个新的型别：

```pascal
type
 TTen = 1..10;
 TOverHundred = 100..1000;
 TUppercase = 'A'..'Z';
```

在使用次范围定义新型别的时候，我们不用特别写出原始型别的名字，只需写出该型别的上下限即可，原始型别必须是有序型别，定义出来的新型别则会是另一个有序型别。当我们把变量宣告为任一个次范围型别时，就只能指派其范围中的任一数值给该变量，例如这样的写法就是正确的：

```pascal
var
 UppLetter: TUpperCase;
begin
 UppLetter := 'F';
```

而以下的写法则是有误的：

```pascal
var
 UppLetter: TUpperCase;
begin
 UppLetter := 'e'; //编译时期会发生错误
```

以上这段源码会在编译的时候，造成编译器错误，讯息则会是：Constant expression vio- lates subrange bounds." 但如果改成以下写法，编译器就会接受喔：

```pasca;
var
 UppLetter: TUpperCase;
 Letter: Char;
begin
 Letter := ‘e’;
 UppLetter := Letter;
 ```


如果在运行时间，我们有启用范围检查的编译器设定(在Project Option对话框的Compiler分页中)，就会得到Range check error的错误讯息。这也类似我们前面介绍过的整数型别溢位错误的问题。

我假设大家在开发程序的时候都会把这个编译器选项开启，这样一来在开发程序的时候就更容易及早发现问题，即使有些问题是在程序复合状况下才会出错。我们可以在最后要建立正式版本的源码时再把这个编译器选项关闭，这样会让最后发布出去的程序执行速度快一些。然而关闭这些选项后能让程序增加的速度也少到几乎可以忽略，所以我会建议把这些运行时间检查的选项都开启，即使已经到了最后要发布阶段的编译作业也一样



### 列举型别81


列举型别(通常被缩写成enums)可以构成另一个使用者自定有序型别。在列举型别中，我们不指定特定型别的范围，而是直接列出其中几个可能的数值，换句话说，我们只把我们需要的特定数值列出即可，举例如下：

```pascal
type
 TColors = (Red, Yellow, Green, Cyan, Blue, Violet);
 TSuit = (Club, Diamond, Heart, Spade);
```

列表当中的每个值都对应一个序号，从0开始。当我们透过Ord函式来寻找列举型态中的特定数值，函式会回传该数值在列举型态中的顺序，以0为第一个元素的编号，因此Ord(Diamond)会回传1。

列举型态有不同的内部表示方法，预设情形下，Delphi使用8位来表示它，除非有超过256个数值被列在列举型别当中，才会使用16位来表示，当然也有32位的表示法，这方法会在需要跟C或C++的函式库兼容时使用。

!!! note "笔记"
    我们可以改变列举型别的预设表示法，可以要求编译器给一个大一点的数值范围，只需使用$Z 这个编译器设定。这设定并不常被用到。


### 范围列举82

列举型别的特殊常数值可以从其效应将之视为全局常数，有时在不同的列举型别当中，也有一些元素的名称会出现冲突，这就是为什么这个语言有支持范围列举，这个功能可以透过编译器设定$SCOPEENUMS来启用，而要使用特定列举型别的内容时，就需要把该列举型别的名称写在前头：

```pascal
// classic enumerated value
s1 := Club;
// "scoped" enumerated value
s1 := TSuit.Club;
```

当这个功能被引入时，默认的规则仍沿用了传统的规则，以免使已经写好的源码无法执行。事实上范围列举已经改变了传统列举型别的规则，它使得列举型别必须强制使用一个型别名称作为前导描述。

给每个列举值一个绝对的名称，消除了名称重复的风险，有了型别名称作为列举值的前导描述，也可以让源码更容易阅读，不管源码写的多长，都不容易认错。

举例来说，IOUtils单元当中定义了这个型别：

```pascal
{$SCOPEDENUMS ON}
type
 TSearchOption = (soTopDirectoryOnly, soAllDirectories);
```

这表示我们不能直接使用当中的第二个值soAllDirectories，需要使用它的时候，需要写出它的全名：

`TSearchOption.soAllDirectories`

在FireMonkey平台的函式库当中使用了许多范围列举型别，因此我们需要使用到这些型别的列举值时，就需要写出其完整的名称。旧版的VCL函式库通常还是使用比较传统的模型。而RTL则是两者的混合。


!!! note "笔记"
    在 Object Pascal 的函式库里面，通常会在列举型别的列举值里面名称的前导字符(通常不成文的规定中会用小写)，例如在前一个例子里，用 so 代表Search Option，但有了完整的型别名称作为前导，以字符作为名称前导字符就有些多余了，但以一般程序写作的习惯，这个作法短期内应该还不会全部消失。

### 集合型别

集合型别指的是一群数据的集合，这群数据会以其顺序作为整个型别的有序基础。这些有序型别通常是有限个数，而且通常会以列举型别或者次范围来表示。

如果我们以次范围1..3来表示一个集合型别，在Pascal的注记会写成1..3，这个集合当中可能的数值就只会包含单独的1或2或3、或者1和2, 2和3, 3和1, 或者1和2和3，或者完全不包含其中任何一个元素这几种组合，我们可以用数学里的组合来想象它，会是完全一致的。

集合型别的变量通常会储存一个集合当中任一个可能的数值组合，以上面的例子来说，这个变量可能储存的内容会是：没数据、1或2或3，或是前述的组合当中的任一种情形，也可能包含所有元素，以下是一个组合型别的范例：

```pascal
type
 TSuit = (Club, Diamond, Heart, Spade);
 TSuits = set of TSuit;
```

现在我们可以定义一个这个型别的变量，然后存放一些数据到这个变量里面了。要定义一个集合型别里面的元素，我们得用逗点来分隔每个元素，做成一个列表，然后以方括号把这些元素括起来，以下的源码就示范如何把多个元素、一个元素、没有元素的这几种集合储存到一个集合型别的变量里：

```pascal
var
 Cards1, Cards2, Cards3: TSuits;
begin
 Cards1 := [Club, Diamond, Heart];
 Cards2 := [Diamond];
 Cards3 := [];
```

在Object Pascal里面，一个集合通常用来储存几个不重复的数值，例如用来储存字体样式的变量，就是使用集合型别，这个变量可能包含粗体、斜体、底线、删除线等样式。所以字体样式当然可以同时包含粗体、斜体，或者没有包含任何样式。因此这个变量就使用集合型别来储存。

我们可以在源码当中指派任何值给这个集合型别变量，举例如下：

```pascal
Font.Style := []; // 没有特别样式
Font.Style := [fsBold]; // 只有粗体
Font.Style := [fsBold, fsItalic]; // 同时具备粗体与斜体
```

### 集合型别的运算方法

我们已经介绍了集合型别，这是只有Pascal特有的使用者自定型别，所以也必须介绍一下集合型别的运算方法。集合型别的运算方法有连集(+)、差集(-)以及交集(*)、是否属于该集合(in)，以及一些相关的运算方法。

要把一个元素加入集合中，我们可以使用连集(+)方法，把两个集合进行连接，以下是用来处理字体样式的相关范例：

```pascal
// 加入粗体
Style := Style + [fsBold];
// 加入粗体和斜体，移除底线（如果底线存在 Style 变量当中的话）
Style := Style + [fsBold, fsItalic] - [fsUnderline];
```

当然我们也可以使用Include跟Exclude这两个程序，这样会比较有效率（但无法使用在组件的集合型别属性上面）：

```pascal
Include (Style, fsBold);
Exclude (Style, fsItalic);
```

## 表达式和运算⽅法84

我们已经介绍过，可以把兼容型别的数据指派给变量、或把常数指配给变量，甚至把一个变量的内容指派给另一个变量。在许多情形里，我们也可以把一个表达式的结果指配给变量储存，包含一个或多个数据的运算，也可能是一个运算或多个运算的结果。表达式是Pascal这个语言的另一个核心元素。


### 使用运算方法

建立表达式并没有一定的规则，表达式只端赖运算方法的使用，在Object Pascal里面有许多运算方法，包含了逻辑运算、数学运算、布尔、实数、以及集合运算，以下是一些简单的例子：

```pascal
//简单的表达式
20*5 // 乘法
30+n // 加法
a<b // 小于（比较判别式 ）
-4 // 负数
c=10 // 检验两个数是否相等 (等同于 C 语法的 == 符号)
```

表达式在绝大多数的编程语言里面都很常见，且大多数的运算方法与符号也大同小异。一个表达式可以是常数、变量、文字数据、运算符号、或者函式回传结果的任意合法组合，表达式可以用来决定要指派给变量的数据内容，计算函式或程序的参数，或者检查是否合于特定条件。我们只要有对任一个识别符号做处理，而不是单纯使用该符号，我们就是在使用表达式了。

!!! note "笔记"
    表达式的结果通常都会储存为该型别的临时变量，这动作会由编译器自动处理好。我们可能会希望用特定的变量来储存这些结果，这样就不用一直重复同样的运算了。请记得，复合运算就会需要多个临时变量来存放计算结果，而这些动作已经都由编译器自动处理好了。



### 显示表达式的结果 

如果您想对某些表达式进行实验，直接写个简单的程序最为直接了当，就相本书大多数的范例，就是以窗体画面程序建立简单的程序，然后透过自定的Show函式把某些执行结果显示给用户看。万一我们想显示的内容不是字符串，而是数字或者布尔逻辑值，我们就必须要做一些转换，例如呼叫IntToStr或者BoolToStr函式

!!! note "笔记"
    在Object Pascal里面，所有传给函式或者程序的参数都会以小括号括起来，有些其他的编程语言，例如 Rebol 与 Ruby，则会要求我们直接把参数写在函式或者程序的后面。而 Object Pascal 如果遇到重复呼叫程序或函式的情形时，就只要把第二层或第三层的函数调用写在参数的字段即可，如以下的范例源码：

以下是从ExpressionsTest范例中节录的一些源码(在这当中我使用传统的IntToStr 语法让大家比较容易理解，当中我用表达式作为参数)：

```pascal
Show (IntToStr (20 * 5));
Show (IntToStr (30 + 222));
Show (BoolToStr (3 < 30, True));
Show (BoolToStr (12 = 10, True));
```

执行结果如下：

```
 100
 252
 True
 False
```

我提供了这个范例作为架构，让您尝试不同型别的表达式与运算方法，并且可以看到对应的输出结果。

!!! note "笔记"
    我们在 Object Pascal 里面所写的表达式，会被编译器处理，并产生汇编程序码，如果您想要变更其中一个表达式，就必须修改原始码并重新编译整个应用程序。然而系统函式库支持动态表达式，可以在运行时间进行计算，这个功能会在第 16 章进行介绍。


### 运算方法与其优先性

表达式是由运算符号和数值所组成的。前面曾提到过，在大多数的编程语言里面，大多数的运算符号都很相似，例如基本的比对符号。在这个章节里，我会就Object Pascal里面特有的运算符号做介绍。

以下是Object Pascal的运算符号列表，我们以运算优先级分组，并和C#，Java，Objective-C(以及大多数以C为基础的编程语言)的运算符号做一些比较。


*关联与比较运算符号(优先级最低)*

+ **=** 测试运算符号两边的识别符号内容是否相同(C语言是使用==)
+ **<>** 测试运算符号两边的识别符号内容是否不同(C语言是使用!=)
+ **<** 测试运算符号左方的内容是否小于右方的内容
+ **>** 测试运算符号左方的内容是否大于右方的内容
+ **<=** 测试运算符号左方的内容是否小于等于右方的内容，或左方的运算符号内容是否为右方的子集合。
+ **>=** 测试运算符号左方的内容是否大于等于右方的内容，或右方的运算符号内容是否为左方的子集合。
+ **in** 测试运算符号左方的内容是否为右方集合的元素之一
+ **is** 测试运算符号左方的内容是否为特定的型别（将在第8章里面介绍），或实作了特定的interface(将在第11章里面介绍)


*相加或相减运算符号*

+ **+** 数学运算的相加、集合的连集、字符串的连接、指针内容的相加
+ **-** 数学运算的相减、集合的差集、指针内容的相减
+ **or** 布尔或位数值之间的or运算(任一者成立即成立)，在C语言则是||或|
+ **xor** 布尔或位数值之间的xor运算(奇数个内容为true的时候即成立)，在C语言的位运算xor是使用ˆ符号。



## 日期与时间

早期的Pascal语言并没有提供原生的日期与时间型别，Object Pascal则有提供原生的日期时间型别，是透过使用浮点数来记录日期与时间信息。准确的说，是在System单元里面，提供了TDateTime这个型别来处理日期与时间。

使用浮点数的原因，是需要足够的字段来记录年、月、日、时、分、秒，甚至精确到千分之一秒，这些都记录在一个Sinlge变量当中：

+ TDateTime的日期部分是以一个整数数值来记录与1899-12-30的差别（如果是负数的话，则代表该日期是早于1899年的日期）

+ TDateTime的时间部分则是以小数部分来记录当时是当天的哪个时间

!!! quote "典故"
    如果我们觉得该日期很奇怪，在这个表示法之后，有着跟 Excel 以及Windows 应用程序用来处理日期的数据处理方式一个很长的故事。因为原本是以 1 来当做 1900 年一月一日，所以 1899 年的最后一天就是以 0 来表示。然而当时定义这个表示法的开发人员可能忘了 1900 年不是闰年，所以又把起始日向后调了一天，所以 1900 年的一月一日又变成了以 2 来表示。

刚刚提到过，TDateTime不是一个编译器中定义的预先定义型别，它是在System单元里面定义的：

```pascal
type
 TDateTime = type Double;
```

!!! note "笔记"
    System 单元已经几乎可以视为 Object Pascal 语言的一部分了，因为它几乎会自动被所有的单元文件引入，即使不写在 uses 区段里面（其实如果在 uses区段里面写了 System，反而还会引起编译错误）。技术上来说，这个单元就是运行时间函式库的核心之一，我们会在第 17 章介绍它。

还有两个跟TDateTime一起用来处理时间与日期的型别，分别是TDate跟TTime，这两个型别只是TDateTime型别的别名，但他们常被系统函式用来去除掉日期或时间当中没有使用到的部份。

在Delphi里面使用日期或时间型别是相当容易的，因为Delphi为这个型别提供了许多处理的函式与方法。这些函式大多都放在SysUtils单元里面，或者是放在DateUtils单元里面(其中还有不少是用来处理时间的函式)。

以下列出一些常用的日期/时间函式：

+ **Now** 回传内容为现在日期时间的值
+ **Date** 回传现在日期
+ **Time** 回传现在的时间
+ **DateTimeToStr** 把一个时间日期的值转换为字符串，使用默认的格式。如果需要更多控制选项，请使用 FormatDateTime 函式
+ **DateToStr** 把日期时间变量的日期部分转换为字符串
+ **TimeToStr** 把日期时间变量的时间部分转换为字符串
+ **FormatDateTime** 用特定的格式对日期时间进行限定格式显示，我们可以只选择我们想要显示的日期时间部分数据来显示，只需要透过格式字符串来设定即可
+ **StrToDateTime** 把一个字符串转换为日期时间值，如果字符串没有符 合格式字符串的设定，系统会传出一个例外。对应的函式StrToDateTimeDef则会在遇到系统例外时，
回传预设的值。
+ **DayOfWeek** 回传我们以参数传入的日期时间值是当周的星期几。
+ **DecodeDate** 从日期时间值取出年、月、日各个部分。
+ **DecodeTime** 从日期时间值取出时、分、秒各个部分。
+ **EncodeDate** 把年月日转换成日期时间值。
+ **EncodeTime** 把时分秒转换成时间值。

为了示范怎么使用这个数据型别以及其相关的一些函式，我建立了一个范例，名为TimeNow，当范例程序执行时，会自动把目前的时间与日期显示出来：

```pascal
var
 StartTime: TDateTime;
begin
 StartTime := Now;
Show ('Time is ' + TimeToStr (StartTime));
Show ('Date is ' + DateToStr (StartTime));
```

第一行程序是呼叫了Now函式，然后把目前的日期与时间存放在StartTime变量里面。

!!! note "笔记"
    当 Object Pascal 的函式被呼叫，而没有传递参数时，是不需要多打一组小括号在上面的，这一点跟 C 语言阵营的编程语言不同。

接下来的两行源码，则是把TDateTime的时间部分显示出来，当然要把它转换成字符串，我们才看的懂，然后是显示日期部分，执行结果如下：

```pascal
Time is 6:33:14 PM
Date is 10/7/2014
```

要编译这个程序，我们需要引入SysUtils单元（是System Utilities的缩写），除了TimeToStr跟DateToStr这两个函式，我们也还可以用更强的FormatDateTime函式。

请留意，日期跟时间值在转换成字符串的时候，会根据系统的语言与地区设定(Windows Vista/Windows 7/Windows 8)。这个设定会从系统读取，而后储存为TFormatSettings这个型别的数据结构中。如果我们想要自己设定显示的样式，我们就得自己依照这个结构的规定，设定好要显示的样式，然后把它当成参数传给大多数的日期与时间函数

!!! note "笔记"
    TimeNow 范例程序当中，还有第二个按钮，我们可以透过它启动一个定时器。定时器组件可以依照我们的设定，每隔我们设定的时间间隔驱动一次事件。在这个范例中，如果您按了这个按钮，就会每隔一秒钟更新一次画面上的时间字符串。更有用的用户接口会是每秒钟更新时间的内容，我们也可以根据这个逻辑来做出一个时钟程序。



### 日期时间助手(DateTime	Helper)

为了让程序人员方便处理TDateTime型别，Delphi 11提供了一个特殊的型别助手，跟本章前面的篇幅提过的内建数据型别类似。为TDateTime这个型别所提供的记录助手，名为TDateTimeHelper，它放在System.DateUtils单元里面。当中包含的操作功能，包含取得日期当中的年、月。或者转换为Unix的日期格式、检查AM/PM，检查该日期时间变量的内容是否为闰年等等。这个记录助手有超过150个方法，所以我们不在这里一一列出。

TDateTime助手型别也新增了一个新的方法名为NowUTC(目前的时间，但以UTC时区表示)，这个方法在传统RTL里面是没有的。我们用以下的源码来示范两个助手型别中的方法:Tomorrow跟 ToString:

```pascal
uses
 DateUtils;
Procedure TForm1.Button1Click(Sender: TObject);
begin
 var MyDate: TDateTime := TDateTime.NowUTC;
 MyDate.Tomorrow.ToString;
end;
```

## 型别切换(Typecasting)与转型(Type	conversions)

如我们介绍过的，在源码当中不能把一种型别的内容指派给另一种型别的变量去。原因是如果每次都要依照数据实际表示的方法来判断，我们可能会花上许多时间纠结在没有意义的环节上。

现在对每一种数据型别来说，这倒不一定正确。举例来说，数字型别就永远可以被标示为向上指派安全型别，因为我们永远可以把较短的数字型别指派给较长的型别，例如我们可以把Word指派给integer，或把integer指派给Int64。但另外一种指派，也就是把较长的数值指派给较短的数值时，编译器就会提出警告，因为我们可能只能把部分数值存到新的变量里面，举例来说，我们可以把整数数值指派到浮点数变量里面，但反之就不行了。

有些时候我们会想要改变数据型别，使得当时的数据处理合法。当我们需要这样做的时候，我们有两个选择，第一种是直接进行型别切换(Type casting)，这个作法会把数据复制一份，进行适当的转换，不依照该数据原始的型别与内容。当我们要进行型别切换的时候，等于是在告诉编译器说”我知道我自己在做什么，让我执行它吧”。如果我们使用型别切换，但并不确定自己正在做什么，这个处理会让我们失去编译器型别检查建构出来的安全网所提供的保护，当然，只有在源码初问题的时候才会出问题。

型别切换使用了简单的写法，像是在写呼叫数学函数一样，把要切换过去的数据型别当成这个数学函数的名称：

```pascal
var
 I: Integer;
 C: Char;
 B: Boolean;
begin
 I := Integer ('X');
 C := Char (I);
 B := Boolean (I);
```

在使用同样长度数据储存数据的型别之间进行型别切换是安全的(因为数据会完整的被复制到被切换过去的型数据空间，上面的范例源码就不是这样喔，那三个型别并不是使用相同长度的空间来储存数据的)。在有序型之间的型别切换通常是安全的，但我们也可以在指标型别（当然，对象也可以）进行切换，只要我们自己真切知道这些切换会有什么效应。

直接进行型别切换，对程序撰写来说是很危险的，因为这使得我们可以用另外一种表现方式来对数据进行处理。由于不同型别的内部数据储存常常是不一致的（且在不同平台上也有不同的处理方式），我们在这个动作上可能埋下日后难以找寻的问题，也因为如此，建议大家应该尽量避免型别切换！

第二种选择，是在把数据指派给另一种不同数据型别的变量之前，先透过型别转换函式处理。以下是我们在不同的几个基本型别上进行转换的常用函式（在本章的范例中，我也已经使用了其中的几个作为例子）：

+ **Chr** 把有序的数字转换为字符
+ **Ord** 把有序型别的数值转换为其序号
+ **Round** 把实数型别转换为整数型别，以四舍五入进行
+ **Trunc** 把实数型别转换为整数型别，以无条件舍去进行
+ **Int** 把浮点数的整数部分转换为整数表示
+ **FloatToDecimal** 把浮点数的内容转换为10进位表示
+ **FloatToStr** 以默认的数据格式，把浮点数转成字符串
+ **StrToFloat** 把一个字符串转换为浮点数

!!! note "笔记"
    Round 这个函数的实作，是以 CPU 的内建功能来处理的。现代的处理器通常都会内建一个称为”Banker’s Rounding”的功能，这个功能会把两个整数之间的数值(例如 5.5 或者 6.5)向上或向下取为整数，端看他们的整数部分是奇数还是偶数。或者我们可以使用 RoundTo 这个函数，这个函数就赋予我们控制权，看是要向上还是向下，不用由 CPU 决定了。

在本章前面的篇幅曾经提到，这些转换函式有些是直接在数据型别当中就提供了的（感谢型别助手这个功能）。当然有些从旧版Pascal语言就一直存在的转换程序，例如IntToStr，我们也已经可以透过大多数数值的型别助手的ToString来处理了。大多数的型别助手都提供了这些转换功能，但我们可以自己决定要用哪种方式来做转换，毕竟我们还是可以决定自己的源码风格在使用型别切换时要怎么写。

有些型别的转换函式我们会在后面的章节里面介绍，请注意上面的列表并没有把一些特殊型别包含进去，(例如TDateTime或者Variant)，也没有对一些对转换的功能提供许多延伸处理的函式做介绍，例如Format与FormatFloat这两个函式。